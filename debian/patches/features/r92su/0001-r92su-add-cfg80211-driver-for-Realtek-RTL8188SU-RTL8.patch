From 51207e878b6ec3f01055658da349678a170aea3a Mon Sep 17 00:00:00 2001
From: Christian Lamparter <chunkeey@googlemail.com>
Date: Sat, 23 Mar 2013 23:36:12 +0100
Subject: [PATCH 01/65] r92su: add cfg80211 driver for Realtek RTL8188SU,
 RTL8191SU and RTL8192SU

This commit adds a new driver for the Realtek RTL8188SU, RTL8191SU and
RTL8192SU products.

It supports:
 - passive monitor and station mode
 - (firmware/hardware) encryption and decryption of 802.11 data frames
     legacy: WEP40, WEP104
     wpa, wpa2 (EAP and PSK): TKIP and CCMP
 - 802.11b/g/n (yes, HT is working!)
 - wps push button events

What still needs to be done:
 - support hardware with 6 and 11 endpoints
 - big endian architectures
 - FPGA and A-Cut hardware init
 - proper rx/tx statistics
 - checkpatch fixes
 - misc stuff (efuse/eeprom programming, APs with hidden ssids)
 - better access to the LEDs
 - integration into the kernel
 - ...

Signed-off-by: Christian Lamparter <chunkeey@googlemail.com>
---
 Makefile        |   32 +-
 README          |   12 +-
 TODO            |   37 --
 r92su/Kconfig   |   24 +
 r92su/Makefile  |    3 +
 r92su/cmd.c     |  277 +++++++++++
 r92su/cmd.h     |   75 +++
 r92su/debugfs.c |  507 ++++++++++++++++++++
 r92su/debugfs.h |   74 +++
 r92su/def.h     |  364 +++++++++++++++
 r92su/eeprom.c  |  224 +++++++++
 r92su/eeprom.h  |  118 +++++
 r92su/event.c   |  204 ++++++++
 r92su/event.h   |   39 ++
 r92su/fw.c      |  323 +++++++++++++
 r92su/fw.h      |  216 +++++++++
 r92su/h2cc2h.h  |  471 +++++++++++++++++++
 r92su/hw.c      |  541 +++++++++++++++++++++
 r92su/hw.h      |   48 ++
 r92su/main.c    | 1392 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 r92su/michael.c |   86 ++++
 r92su/michael.h |   24 +
 r92su/r92su.h   |  299 ++++++++++++
 r92su/reg.h     |  835 +++++++++++++++++++++++++++++++++
 r92su/rx.c      | 1187 +++++++++++++++++++++++++++++++++++++++++++++++
 r92su/rx.h      |   49 ++
 r92su/sta.c     |  261 +++++++++++
 r92su/sta.h     |  154 ++++++
 r92su/tx.c      |  600 ++++++++++++++++++++++++
 r92su/tx.h      |   38 ++
 r92su/usb.c     |  581 +++++++++++++++++++++++
 r92su/usb.h     |   64 +++
 32 files changed, 9088 insertions(+), 71 deletions(-)
 create mode 100644 r92su/Kconfig
 create mode 100644 r92su/Makefile
 create mode 100644 r92su/cmd.c
 create mode 100644 r92su/cmd.h
 create mode 100644 r92su/debugfs.c
 create mode 100644 r92su/debugfs.h
 create mode 100644 r92su/def.h
 create mode 100644 r92su/eeprom.c
 create mode 100644 r92su/eeprom.h
 create mode 100644 r92su/event.c
 create mode 100644 r92su/event.h
 create mode 100644 r92su/fw.c
 create mode 100644 r92su/fw.h
 create mode 100644 r92su/h2cc2h.h
 create mode 100644 r92su/hw.c
 create mode 100644 r92su/hw.h
 create mode 100644 r92su/main.c
 create mode 100644 r92su/michael.c
 create mode 100644 r92su/michael.h
 create mode 100644 r92su/r92su.h
 create mode 100644 r92su/reg.h
 create mode 100644 r92su/rx.c
 create mode 100644 r92su/rx.h
 create mode 100644 r92su/sta.c
 create mode 100644 r92su/sta.h
 create mode 100644 r92su/tx.c
 create mode 100644 r92su/tx.h
 create mode 100644 r92su/usb.c
 create mode 100644 r92su/usb.h

#--- a/drivers/net/wireless/Makefile
#+++ b/drivers/net/wireless/Makefile
#@@ -1,42 +1,28 @@
# # fallback to the current kernel source
# KSRC ?= /lib/modules/$(shell uname -r)/build
# 
#-KMOD_SRC ?= $(PWD)/rtlwifi
#+KMOD_SRC ?= $(PWD)/r92su
# 
# # Each configuration option enables a list of files.
# 
#-C ?= 0
#-CF ?= -D__CHECK_ENDIAN__ 
#-KMOD_OPTIONS = CONFIG_RTLWIFI=m 
#-KMOD_OPTIONS += CONFIG_RTLWIFI_DEBUG=m 
#-KMOD_OPTIONS += CONFIG_RTL8192SU=m
#+KMOD_OPTIONS += CONFIG_R92SU=m CONFIG_R92SU_DEBUGFS=y CONFIG_R92SU_WPC=y
# 
# # Don't build any of the other drivers
#-KMOD_OPTIONS += CONFIG_RTL8192CU=n CONFIG_RTL8192DE=n CONFIG_RTL8192CE=n CONFIG_RTL8192SE=n CONFIG_RTL8192C_COMMON=n CONFIG_RTL8723AE=n
#-
#-
#-EXTRA_CFLAGS += -DDEBUG
#+EXTRA_CFLAGS += -DDEBUG -DCONFIG_R92SU=m -DCONFIG_R92SU_DEBUGFS=y -DCONFIG_R92SU_WPC=y
# 
# all:
#-	$(MAKE) -C $(KSRC) M=$(KMOD_SRC) $(KMOD_OPTIONS) C=$(C) CF=$(CF) -j4
#+	$(MAKE) -C $(KSRC) M=$(KMOD_SRC) $(KMOD_OPTIONS) $(MAKECMDGOALS) EXTRA_CFLAGS="$(EXTRA_CFLAGS)"
#+
#+.PHONY: all load unload reload clean
# 
# clean:
# 	$(MAKE) -C $(KSRC) M=$(KMOD_SRC) clean $(KMOD_OPTIONS)
# 
# #debug trace load
#-load:	all
#-	modprobe mac80211
#-	insmod $(KMOD_SRC)/rtlwifi.ko
#-	insmod $(KMOD_SRC)/rtl8192su/rtl8192su.ko debug=5
#-
#-#silent load
#-ld:	all
#-	modprobe mac80211
#-	insmod $(KMOD_SRC)/rtlwifi.ko
#-	insmod $(KMOD_SRC)/rtl8192su/rtl8192su.ko
#+load:	
#+	insmod $(KMOD_SRC)/r92su.ko
# 
# unload:
#-	rmmod $(KMOD_SRC)/rtl8192su/rtl8192su.ko
#-	rmmod $(KMOD_SRC)/rtlwifi.ko
#+	rmmod r92su
# 
# reload:	unload load
#--- a/drivers/net/wireless/README
#+++ b/drivers/net/wireless/README
#@@ -1,7 +1,7 @@
# RTL8192SU mac80211-port driver
# -----------------------
# 
#-This is "a" driver repository for the WIP rtl8192su for
#+This is "a" driver repository for the WIP r92su for
# any interested developer.
# 
# To build the driver you will need to have a compatible
#@@ -17,18 +17,8 @@ make load
# 
# to load the module.
# 
#-Note: This driver might not be compatible with
#-other drivers that use the rtlwifi framework.
# ---
# 
#-Note2: If you don't want to be spammed by debug messages,
#-use "make ld".
#-
#----
#-Note3: The rtl8192su driver and rtlwifi framework is kept
#-in sync with wireless-testing.git:
#-<git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-testing.git>
#-
# If you want to know more about git (in context with wireless-testing
# then visit our Git-Guide at:
# <http://wireless.kernel.org/en/developers/Documentation/git-guide>
#--- a/drivers/net/wireless/TODO
#+++ b/drivers/net/wireless/TODO
#@@ -1,55 +1,18 @@
# TODO:
#- - fw/hw encryption/decryption offload needs to be implemented.
#-   currently everything is done with mac80211 software crypto.
#-
#- - HT / 802.11n support is not implemented or tested. In fact,
#-   this driver might crash if it is to connect to a 11n network.
#-   (With this goes 40MHz channel bandwidth)
#-
#  - rx statistics (Signal/Quality)
#    rtl8192su provides a wide range of noise and signal levels,
#    but they need to be read, processed and passed to mac80211.
# 
#- - WPS PBC handler
#-   Some(all?) rtl8192su sticks have a little wps push button.
#-   The GPIO needs to be polled periodically (2sec in the vendor
#-   driver) and a key event has to be sent to the input layer.
#-
#  - ADHOC
#    Apparently the firmware supports ADHOC, but the driver
#    does not.
# 
#- - code cleanup
#-   Currently there's a lot of debug/rtl8192se/rtl8192cu cruft.
#-   This needs to be removed and some functions needs to be
#-   refactored
#-
#- - rtl8192s_common
#-   rtl8192su and rtl8192se share some functionality. Setup
#-   a shared library for common functions
#-
#- - set the correct RF configuration
#-   (Currently everything is hardcoded to 1:1T1R)
#-
#- - QoS/WMM/802.11e
#-   (cwmin/cwmax/aifs/txop are not set yet)
#-
#  - figure out which firmware commands are really implemented
#    in the firmware. Some just seem to be NOPs.
#    (Note: The same is true for firmware response. This will
#    be harder to figure out, as we need to trigger the condition
#    in the firmware somehow - and this is difficult)  
# 
#-INPROGRESS:
#- - deal with surprise remove and rmmod kernel OOPS
#-   (Currently the kernel crashes when the device is unplugged at
#-   a "bad" (which is basically "always" when it's up) time, or
#-   when the rtl8192su module is unloaded... )
#-   [It no longer crashes! At least not for me]
#-
#- - figure out rate control
#-   [seems to work as well?]
#-
# TESTS:
#  - stability test
#    (How long does a idle/loaded connection last?)
--- /dev/null
+++ b/drivers/net/wireless/r92su/Kconfig
@@ -0,0 +1,24 @@
+
+config R92SU
+	tristate "Realtek RTL8192SU/RTL8191SU/RTL8188SU USB Wireless Network Adapter"
+	depends on USB && CFG80211
+	select FW_LOADER
+	---help---
+	This is the driver for Realtek RTL8192SU/RTL8191SU/RTL8188SU 802.11 USB
+	wireless network adapters.
+
+	If you choose to build it as a module, it will be called r92su
+
+config R92SU_DEBUGFS
+	bool "R92SU Debugfs Support"
+	depends on R92SU && DEBUG_FS
+	default n
+	help
+	 Export several driver and device internals to user space.
+
+	 Say N, unless you have a good reason. 
+
+config R92SU_WPC
+	bool
+	depends on R92SU && (INPUT = y || INPUT = R92SU)
+	default y
--- /dev/null
+++ b/drivers/net/wireless/r92su/Makefile
@@ -0,0 +1,3 @@
+r92su-objs			+= main.o sta.o usb.o eeprom.o fw.o cmd.o event.o hw.o rx.o hw.o tx.o michael.o
+r92su-$(CONFIG_R92SU_DEBUGFS)	+= debugfs.o
+obj-$(CONFIG_R92SU)		+= r92su.o
--- /dev/null
+++ b/drivers/net/wireless/r92su/cmd.c
@@ -0,0 +1,277 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+
+#include "r92su.h"
+#include "cmd.h"
+#include "usb.h"
+#include "reg.h"
+#include "eeprom.h"
+#include "def.h"
+
+void r92su_cmd_init(struct r92su *r92su)
+{
+	r92su->h2c_seq = 1;
+	r92su->c2h_seq = 0;
+	spin_lock_init(&r92su->tx_cmd_lock);
+}
+
+struct sk_buff *r92su_h2c_alloc(struct r92su *r92su, int len, gfp_t flag)
+{
+	struct sk_buff *skb;
+	unsigned int new_len =
+		ALIGN(len + TX_DESC_SIZE + H2CC2H_HDR_LEN, H2CC2H_HDR_LEN);
+	skb = __dev_alloc_skb(new_len, flag);
+	if (skb)
+		skb_reserve(skb, TX_DESC_SIZE + H2CC2H_HDR_LEN);
+
+	return skb;
+}
+
+static void r92su_h2c_fill_header(struct r92su *r92su,
+				  struct sk_buff *skb,
+				  unsigned int len,
+				  enum fw_h2c_cmd cmd,
+				  bool last)
+{
+	struct h2cc2h *h2c;
+	h2c = (struct h2cc2h *) skb_push(skb, H2CC2H_HDR_LEN);
+
+	memset(h2c, 0, sizeof(*h2c));
+	h2c->cmd_seq = r92su->h2c_seq++;
+	h2c->len = ALIGN(len, H2CC2H_HDR_LEN);
+	h2c->event = cmd;
+	h2c->last = last;
+}
+
+static void __r92su_tx_fill_header(struct tx_hdr *tx_hdr, unsigned int len,
+				   bool first, bool last, unsigned int qsel)
+{
+	tx_hdr->pkt_len = len - TX_DESC_SIZE;
+	tx_hdr->offset = TX_DESC_SIZE;
+	tx_hdr->last_seg = last;
+	tx_hdr->first_seg = first;
+	tx_hdr->own = 1;
+	tx_hdr->queue_sel = qsel;
+}
+
+static void r92su_tx_fill_header(struct sk_buff *skb,
+				 unsigned int len, bool first, bool last)
+{
+	struct tx_hdr *tx_hdr;
+	tx_hdr = (struct tx_hdr *) skb_push(skb, TX_DESC_SIZE);
+
+	memset(tx_hdr, 0, sizeof(*tx_hdr));
+	__r92su_tx_fill_header(tx_hdr, len, first, last, QSLT_CMD);
+}
+
+int r92su_h2c_submit(struct r92su *r92su, struct sk_buff *skb,
+		     const enum fw_h2c_cmd cmd)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&r92su->tx_cmd_lock, flags);
+	r92su_h2c_fill_header(r92su, skb, skb->len, cmd, true);
+	r92su_tx_fill_header(skb, skb->len, true, true);
+	err = r92su_usb_tx(r92su, skb, RTL8712_H2CCMD);
+	spin_unlock_irqrestore(&r92su->tx_cmd_lock, flags);
+	return err;
+}
+
+int r92su_h2c_copy(struct r92su *r92su, const enum fw_h2c_cmd cmd,
+		   const int len, const void *data, gfp_t flag)
+{
+	struct sk_buff *skb;
+	int rest;
+
+	skb = r92su_h2c_alloc(r92su, len, flag);
+	if (!skb)
+		return -ENOMEM;
+
+	rest = H2CC2H_HDR_LEN - (len % H2CC2H_HDR_LEN);
+	memcpy(skb_put(skb, len), data, len);
+	memset(skb_put(skb, rest), 0, rest);
+
+	return r92su_h2c_submit(r92su, skb, cmd);
+}
+
+int r92su_h2c_set_mac_addr(struct r92su *r92su, const u8 *addr)
+{
+	struct h2c_set_mac mac_args = { };
+
+	memcpy(&mac_args.mac_addr, addr, ETH_ALEN);
+
+	return r92su_h2c_copy(r92su, H2C_SET_MAC_ADDRESS_CMD, sizeof(mac_args),
+			      &mac_args, GFP_KERNEL);
+
+}
+
+int r92su_h2c_set_opmode(struct r92su *r92su, const enum h2c_op_modes mode)
+{
+	struct h2c_op_mode mode_args = { };
+
+	mode_args.mode = mode;
+
+	return r92su_h2c_copy(r92su, H2C_SETOPMODE_CMD, sizeof(mode_args),
+			      &mode_args, GFP_KERNEL);
+}
+
+int r92su_h2c_set_channel(struct r92su *r92su, const int channel)
+{
+	struct h2c_set_channel chan_args;
+
+	chan_args.channel = cpu_to_le32(channel);
+
+	return r92su_h2c_copy(r92su, H2C_SETCHANNEL_CMD, sizeof(chan_args),
+			      &chan_args, GFP_KERNEL);
+}
+
+int r92su_fw_iocmd(struct r92su *r92su, const u32 cmd)
+{
+	int tries = 25;
+
+	r92su_write32(r92su, REG_IOCMD_CTRL, cmd);
+
+	do {
+		if (--tries == 0)
+			return -ETIMEDOUT;
+		msleep(20);
+	} while (r92su_read32(r92su, REG_IOCMD_CTRL) != 0);
+
+	return 0;
+}
+
+int r92su_h2c_survey(struct r92su *r92su, struct cfg80211_ssid *ssid)
+{
+	struct h2c_site_survey survey = { };
+
+	survey.active = cpu_to_le32(ssid != NULL);
+	survey.bsslimit = cpu_to_le32(48);
+	if (ssid) {
+		survey.ssidlen = cpu_to_le32(ssid->ssid_len);
+		memcpy(&survey.ssid, ssid->ssid, ssid->ssid_len);
+	}
+
+	return r92su_h2c_copy(r92su, H2C_SITESURVEY_CMD, sizeof(survey),
+			      &survey, GFP_KERNEL);
+}
+
+int r92su_h2c_disconnect(struct r92su *r92su)
+{
+	struct h2c_disconnect disconnect = { };
+
+	return r92su_h2c_copy(r92su, H2C_DISCONNECT_CMD, sizeof(disconnect),
+			      &disconnect, GFP_KERNEL);
+}
+
+int r92su_h2c_connect(struct r92su *r92su, const struct h2cc2h_bss *orig_bss,
+		      const u8 *ie, const u32 ie_len)
+{
+	struct h2cc2h_bss *bss;
+	struct sk_buff *skb;
+	int rest;
+
+	skb = r92su_h2c_alloc(r92su, sizeof(*bss) + ie_len, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	bss = (struct h2cc2h_bss *)skb_put(skb, sizeof(*bss));
+	memcpy(bss, orig_bss, sizeof(*bss));
+
+	/* the ie_length also contains the fixed 12-byte ies (tsf/...) */
+	bss->ie_length = cpu_to_le32(12 + ie_len);
+	if (ie && ie_len > 0)
+		memcpy(skb_put(skb, ie_len), ie, ie_len);
+
+	bss->length = cpu_to_le32(skb->len);
+	rest = H2CC2H_HDR_LEN - (skb->len % H2CC2H_HDR_LEN);
+	memset(skb_put(skb, rest), 0, rest);
+	return r92su_h2c_submit(r92su, skb, H2C_JOINBSS_CMD);
+}
+
+static const u8 r92su_enc_alg_len[] = {
+	[NO_ENCRYPTION] = 0,
+	[WEP40_ENCRYPTION] = WLAN_KEY_LEN_WEP40,
+	[WEP104_ENCRYPTION] = WLAN_KEY_LEN_WEP104,
+	/* the rx and tx mic from the tkip key data
+	 * are not uploaded to the firmware */
+	[TKIP_ENCRYPTION] = 16,
+	[TKIP_WTMIC] = 16,
+	[AESCCMP_ENCRYPTION] = WLAN_KEY_LEN_CCMP,
+};
+
+int r92su_h2c_set_key(struct r92su *r92su, const enum r92su_enc_alg algo,
+		      const u8 key_id, const bool group_key, const u8 *keydata)
+{
+	struct h2c_key key = { };
+
+	BUILD_BUG_ON(ARRAY_SIZE(r92su_enc_alg_len) != __MAX_ENCRYPTION);
+
+	key.algorithm = algo;
+	key.key_id = key_id;
+	key.group_key = !!group_key;
+	memcpy(key.key, keydata, r92su_enc_alg_len[algo]);
+	return r92su_h2c_copy(r92su, H2C_SETKEY_CMD, sizeof(key),
+			      &key, GFP_KERNEL);
+}
+
+int r92su_h2c_set_sta_key(struct r92su *r92su, const enum r92su_enc_alg algo,
+			  const u8 *mac_addr, const u8 *keydata)
+{
+	struct h2c_sta_key key = { };
+
+	key.algorithm = algo;
+	memcpy(key.mac_addr, mac_addr, ETH_ALEN);
+	memcpy(key.key, keydata, r92su_enc_alg_len[algo]);
+	return r92su_h2c_copy(r92su, H2C_SETSTAKEY_CMD, sizeof(key),
+			      &key, GFP_KERNEL);
+}
+
+int r92su_h2c_set_auth(struct r92su *r92su, const enum r92su_auth_mode mode,
+		       const enum r92su_auth_1x _1x)
+{
+	struct h2c_auth auth = { };
+
+	auth.mode = mode;
+	auth._1x = _1x;
+	return r92su_h2c_copy(r92su, H2C_SETAUTH_CMD, sizeof(auth),
+			      &auth, GFP_KERNEL);
+}
+
+int r92su_h2c_start_ba(struct r92su *r92su, const unsigned int tid)
+{
+	struct h2c_add_ba_req req = { };
+	req.tid = cpu_to_le32(tid);
+
+	return r92su_h2c_copy(r92su, H2C_ADDBA_REQ_CMD, sizeof(req),
+			      &req, GFP_ATOMIC);
+}
--- /dev/null
+++ b/drivers/net/wireless/r92su/cmd.h
@@ -0,0 +1,75 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_CMD_H__
+#define __R92SU_CMD_H__
+
+#include <linux/mm.h>
+
+#include "def.h"
+
+struct sk_buff;
+struct r92su;
+struct ieee80211_channel;
+
+void r92su_cmd_init(struct r92su *r92su);
+
+struct sk_buff *r92su_h2c_alloc(struct r92su *r92su, int len, gfp_t flag);
+
+int r92su_h2c_copy(struct r92su *r92su, const enum fw_h2c_cmd cmd,
+		   const int len, const void *data, gfp_t flag);
+
+int r92su_h2c_submit(struct r92su *r92su, struct sk_buff *skb,
+		     const enum fw_h2c_cmd cmd);
+
+int r92su_h2c_set_mac_addr(struct r92su *r92su, const u8 *addr);
+int r92su_h2c_set_opmode(struct r92su *r92su, const enum h2c_op_modes mode);
+int r92su_h2c_set_channel(struct r92su *r92su, const int channel);
+int r92su_fw_iocmd(struct r92su *r92su, const u32 cmd);
+int r92su_h2c_survey(struct r92su *r92su, struct cfg80211_ssid *ssid);
+
+int r92su_h2c_disconnect(struct r92su *r92su);
+
+int r92su_h2c_connect(struct r92su *r92su, const struct h2cc2h_bss *bss,
+		      const u8 *ie, const u32 ie_len);
+
+int r92su_h2c_set_key(struct r92su *r92su, const enum r92su_enc_alg algo,
+		      const u8 key_id, const bool group_key,
+		      const u8 *keydata);
+
+int r92su_h2c_set_sta_key(struct r92su *r92su, const enum r92su_enc_alg algo,
+			  const u8 *mac_addr, const u8 *keydata);
+
+int r92su_h2c_set_auth(struct r92su *r92su, const enum r92su_auth_mode auth,
+		       const enum r92su_auth_1x _1x);
+
+int r92su_h2c_start_ba(struct r92su *r92su, const unsigned int tid);
+
+#endif /* __R92SU_CMD_H__ */
--- /dev/null
+++ b/drivers/net/wireless/r92su/debugfs.c
@@ -0,0 +1,507 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+#include <linux/debugfs.h>
+#include "r92su.h"
+
+#include "debugfs.h"
+#include "usb.h"
+#include "hw.h"
+
+#define ADD(buf, off, max, fmt, args...)				\
+	(off += snprintf(&buf[(off)], (max - off), (fmt), ##args))
+
+struct r92su_debugfs_fops {
+	unsigned int read_bufsize;
+	umode_t attr;
+	char *(*read)(struct r92su *r92su, char *buf, size_t bufsize,
+		      ssize_t *len);
+	ssize_t (*write)(struct r92su *r92su, const char *buf, size_t size);
+	const struct file_operations fops;
+
+	enum r92su_state_t req_dev_state;
+};
+
+static ssize_t r92su_debugfs_read(struct file *file, char __user *userbuf,
+				  size_t count, loff_t *ppos)
+{
+	struct r92su_debugfs_fops *dfops;
+	struct r92su *r92su;
+	char *buf = NULL, *res_buf = NULL;
+	ssize_t ret = 0;
+	int err = 0;
+
+	if (!count)
+		return 0;
+
+	r92su = file->private_data;
+
+	if (!r92su)
+		return -ENODEV;
+	dfops = container_of(file->f_op, struct r92su_debugfs_fops, fops);
+
+	if (!dfops->read)
+		return -ENOSYS;
+
+	if (dfops->read_bufsize) {
+		buf = vmalloc(dfops->read_bufsize);
+		if (!buf)
+			return -ENOMEM;
+	}
+
+	mutex_lock(&r92su->lock);
+	if (r92su->state < dfops->req_dev_state) {
+		err = -ENODEV;
+		res_buf = buf;
+		goto out_free;
+	}
+
+	res_buf = dfops->read(r92su, buf, dfops->read_bufsize, &ret);
+
+	if (ret > 0)
+		err = simple_read_from_buffer(userbuf, count, ppos,
+					      res_buf, ret);
+	else
+		err = ret;
+
+	WARN_ONCE(dfops->read_bufsize && (res_buf != buf),
+		  "failed to write output buffer back to debugfs");
+
+out_free:
+	vfree(res_buf);
+	mutex_unlock(&r92su->lock);
+	return err;
+}
+
+static ssize_t r92su_debugfs_write(struct file *file,
+	const char __user *userbuf, size_t count, loff_t *ppos)
+{
+	struct r92su_debugfs_fops *dfops;
+	struct r92su *r92su;
+	char *buf = NULL;
+	int err = 0;
+
+	if (!count)
+		return 0;
+
+	if (count > PAGE_SIZE)
+		return -E2BIG;
+
+	r92su = file->private_data;
+
+	if (!r92su)
+		return -ENODEV;
+	dfops = container_of(file->f_op, struct r92su_debugfs_fops, fops);
+
+	if (!dfops->write)
+		return -ENOSYS;
+
+	buf = vmalloc(count);
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, userbuf, count)) {
+		err = -EFAULT;
+		goto out_free;
+	}
+
+	if (mutex_trylock(&r92su->lock) == 0) {
+		err = -EAGAIN;
+		goto out_free;
+	}
+
+	if (r92su->state < dfops->req_dev_state) {
+		err = -ENODEV;
+		goto out_unlock;
+	}
+
+	err = dfops->write(r92su, buf, count);
+	if (err)
+		goto out_unlock;
+
+out_unlock:
+	mutex_unlock(&r92su->lock);
+
+out_free:
+	vfree(buf);
+	return err;
+}
+
+#define __DEBUGFS_DECLARE_FILE(name, _read, _write, _read_bufsize,	\
+			       _attr, _dstate)				\
+static const struct r92su_debugfs_fops r92su_debugfs_##name ##_ops = {	\
+	.read_bufsize = _read_bufsize,					\
+	.read = _read,							\
+	.write = _write,						\
+	.attr = _attr,							\
+	.req_dev_state = _dstate,					\
+	.fops = {							\
+		.open   = simple_open,					\
+		.read   = r92su_debugfs_read,				\
+		.write  = r92su_debugfs_write,				\
+		.owner  = THIS_MODULE,					\
+	},								\
+}
+
+#define DEBUGFS_DECLARE_FILE(name, _read, _write, _read_bufsize, _attr)	\
+	__DEBUGFS_DECLARE_FILE(name, _read, _write, _read_bufsize,	\
+			       _attr, R92SU_OPEN)
+
+#define DEBUGFS_DECLARE_RO_FILE(name, _read_bufsize)			\
+	DEBUGFS_DECLARE_FILE(name, r92su_debugfs_##name ##_read,	\
+			     NULL, _read_bufsize, S_IRUSR)
+
+#define DEBUGFS_DECLARE_WO_FILE(name)					\
+	DEBUGFS_DECLARE_FILE(name, NULL, r92su_debugfs_##name ##_write,	\
+			     0, S_IWUSR)
+
+#define DEBUGFS_DECLARE_RW_FILE(name, _read_bufsize)			\
+	DEBUGFS_DECLARE_FILE(name, r92su_debugfs_##name ##_read,	\
+			     r92su_debugfs_##name ##_write,		\
+			     _read_bufsize, S_IRUSR | S_IWUSR)
+
+#define __DEBUGFS_DECLARE_RW_FILE(name, _read_bufsize, _dstate)		\
+        __DEBUGFS_DECLARE_FILE(name, r92su_debugfs_##name ##_read,	\
+			       r92su_debugfs_##name ##_write,		\
+			       _read_bufsize, S_IRUSR | S_IWUSR, _dstate)
+
+#define DEBUGFS_READONLY_FILE(name, _read_bufsize, fmt, value...)	\
+static char *r92su_debugfs_ ##name ## _read(struct r92su *r92su,	\
+					    char *buf, size_t buf_size,	\
+					    ssize_t *len)		\
+{									\
+	ADD(buf, *len, buf_size, fmt "\n", ##value);			\
+	return buf;							\
+}									\
+DEBUGFS_DECLARE_RO_FILE(name, _read_bufsize)
+
+static const char *meminfo[__MAX_R92SU_MEM_TYPE] = {
+	[R92SU_8] =  "byte",
+	[R92SU_16] = "word",
+	[R92SU_32] = " int"
+};
+
+static char *r92su_debugfs_eeprom_read(struct r92su *r92su,
+					 char *buf, size_t buf_size,
+					 ssize_t *len)
+{
+	struct r92su_eeprom *e = &r92su->eeprom;
+
+	/* The complete eeprom layout is not known yet.
+	 * Hence, this formatted output is left incomplete.
+	 */
+
+	ADD(buf, *len, buf_size, "id:           %.4x\n", e->id);
+	ADD(buf, *len, buf_size, "hpon:         %.4x\n", e->hpon);
+	ADD(buf, *len, buf_size, "clk:          %.4x\n", e->clk);
+	ADD(buf, *len, buf_size, "testr:        %.4x\n", e->testr);
+	ADD(buf, *len, buf_size, "vid:          %.4x\n", e->vid);
+	ADD(buf, *len, buf_size, "did:          %.4x\n", e->did);
+	ADD(buf, *len, buf_size, "usb_optional: %.2x\n", e->usb_optional);
+	ADD(buf, *len, buf_size, "usb_phy_parm: %.2x %.2x %.2x %.2x %.2x\n",
+	    e->usb_phy_para1[0], e->usb_phy_para1[1], e->usb_phy_para1[2],
+	    e->usb_phy_para1[3], e->usb_phy_para1[4]);
+
+	ADD(buf, *len, buf_size, "mac_addr:     %pM\n", e->mac_addr);
+	ADD(buf, *len, buf_size, "version:      %.2x\n", e->version);
+	ADD(buf, *len, buf_size, "channel plan: %.2x\n", e->channel_plan);
+	ADD(buf, *len, buf_size, "custom_id:    %.2x\n", e->custom_id);
+	ADD(buf, *len, buf_size, "sub_custom_id:%.2x\n", e->sub_custom_id);
+	ADD(buf, *len, buf_size, "board_type:   %.2x\n", e->board_type);
+	return buf;
+}
+DEBUGFS_DECLARE_RO_FILE(eeprom, 1024);
+
+static char *r92su_debugfs_eeprom_raw_read(struct r92su *r92su,
+					   char *buf, size_t buf_size,
+					   ssize_t *len)
+{
+	*len = min(sizeof(r92su->eeprom), buf_size);
+	memcpy(buf, &r92su->eeprom, *len);
+	return buf;
+}
+DEBUGFS_DECLARE_RO_FILE(eeprom_raw, 1024);
+
+static char *r92su_debugfs_sta_table_read(struct r92su *r92su,
+					  char *buf, size_t buf_size,
+					  ssize_t *len)
+{
+	int i;
+	rcu_read_lock();
+	for (i = 0; i < ARRAY_SIZE(r92su->sta_table); i++) {
+		struct r92su_sta *sta = rcu_dereference(r92su->sta_table[i]);
+		struct r92su_key *key;
+
+		ADD(buf, *len, buf_size, "mac_id: %2d ", i);
+		if (!sta) {
+			ADD(buf, *len, buf_size, " - empty -\n");
+			continue;
+		}
+
+		key = rcu_dereference(sta->sta_key);
+		ADD(buf, *len, buf_size,
+		    "mac_addr:%pM aid:%d id2:%d enc:%d qos:%d ht:%d\n",
+		    sta->mac_addr, sta->aid, sta->mac_id, sta->qos_sta,
+		    sta->enc_sta, sta->ht_sta);
+
+		if (key) {
+			ADD(buf, *len, buf_size,
+			    "key: type:%d, key_len:%d, seq_len:%d idx:%d\n",
+			    key->type, key->key_len, key->seq_len, key->index);
+		}
+	}
+	rcu_read_unlock();
+	return buf;
+}
+DEBUGFS_DECLARE_RO_FILE(sta_table, 1024);
+
+static char *r92su_debugfs_connected_bss_read(struct r92su *r92su,
+					      char *buf, size_t buf_size,
+					      ssize_t *len)
+{
+	int i;
+	struct cfg80211_bss *bss;
+	struct r92su_bss_priv *bss_priv;
+
+	rcu_read_lock();
+	bss = rcu_dereference(r92su->connect_bss);
+	if (!bss) {
+		rcu_read_unlock();
+		return buf;
+	}
+
+	bss_priv = r92su_get_bss_priv(bss);
+
+	ADD(buf, *len, buf_size, "BSSID:%pM bcn:%d capa:%d freq:%d\n",
+	   bss->bssid, bss->beacon_interval, bss->capability,
+	   bss->channel->center_freq);
+
+	ADD(buf, *len, buf_size, "mac-id:%d, default multi key index:%d, %d\n",
+	    bss_priv->sta->mac_id, bss_priv->def_multi_key_idx,
+	    bss_priv->def_uni_key_idx);
+
+	for (i = 0; i < ARRAY_SIZE(bss_priv->group_key); i++) {
+		struct r92su_key *key = rcu_dereference(bss_priv->group_key[i]);
+		if (!key)
+			continue;
+
+		ADD(buf, *len, buf_size,
+		    "key: type:%d, key_len:%d, seq_len:%d idx:%d\n",
+		    key->type, key->key_len, key->seq_len, key->index);
+	}
+	rcu_read_unlock();
+	return buf;
+}
+DEBUGFS_DECLARE_RO_FILE(connected_bss, 1024);
+
+static ssize_t r92su_debugfs_hw_ioread_write(struct r92su *r92su,
+					     const char *buf, size_t count)
+{
+	int err = 0, n = 0, max_len = 32, res;
+	unsigned int reg, tmp;
+	enum r92su_mem_type_t type;
+
+	if (!count)
+		return 0;
+
+	if (count > max_len)
+		return -E2BIG;
+
+	res = sscanf(buf, "0x%X %d", &reg, &n);
+	if (res < 1) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	if (res == 1)
+		n = 1;
+
+	switch (n) {
+	case 4:
+		tmp = r92su_read32(r92su, reg);
+		type = R92SU_32;
+		break;
+	case 2:
+		tmp = r92su_read16(r92su, reg);
+		type = R92SU_16;
+		break;
+	case 1:
+		tmp = r92su_read8(r92su, reg);
+		type = R92SU_8;
+		break;
+	default:
+		err = -EMSGSIZE;
+		goto out;
+	}
+
+	r92su->debug.ring[r92su->debug.ring_tail].reg = reg;
+	r92su->debug.ring[r92su->debug.ring_tail].value = tmp;
+	r92su->debug.ring[r92su->debug.ring_tail].type = type;
+	r92su->debug.ring_tail++;
+	r92su->debug.ring_tail %= R92SU_DEBUG_RING_SIZE;
+
+	if (r92su->debug.ring_len < R92SU_DEBUG_RING_SIZE)
+		r92su->debug.ring_len++;
+
+out:
+	return err ? err : count;
+}
+
+static char *r92su_debugfs_hw_ioread_read(struct r92su *r92su, char *buf,
+					  size_t bufsize, ssize_t *ret)
+{
+	int i;
+
+	ADD(buf, *ret, bufsize,
+		"                      33222222 22221111 11111100 00000000\n");
+	ADD(buf, *ret, bufsize,
+		"                      10987654 32109876 54321098 76543210\n");
+
+	while (r92su->debug.ring_len) {
+		struct r92su_debug_mem_rbe *rbe;
+
+		rbe = &r92su->debug.ring[r92su->debug.ring_head];
+		ADD(buf, *ret, bufsize, "%.4x = %.8x [%s]",
+		    rbe->reg, rbe->value, meminfo[rbe->type]);
+
+		for (i = 31; i >= 0; i--) {
+			ADD(buf, *ret, bufsize, "%c%s",
+			    rbe->value & BIT(i) ? 'X' : ' ',
+			    (i % 8) == 0 ? " " : "");
+		}
+		ADD(buf, *ret, bufsize, "\n");
+
+		r92su->debug.ring_head++;
+		r92su->debug.ring_head %= R92SU_DEBUG_RING_SIZE;
+
+		r92su->debug.ring_len--;
+	}
+	r92su->debug.ring_head = r92su->debug.ring_tail;
+	return buf;
+}
+DEBUGFS_DECLARE_RW_FILE(hw_ioread, 160 + R92SU_DEBUG_RING_SIZE * 40);
+
+static ssize_t r92su_debugfs_hw_iowrite_write(struct r92su *r92su,
+					      const char *buf, size_t count)
+{
+	int err = 0, max_len = 22, res;
+	u32 reg, val, n;
+
+	if (!count)
+		return 0;
+
+	if (count > max_len)
+		return -E2BIG;
+
+	res = sscanf(buf, "0x%X 0x%X %d", &reg, &val, &n);
+	if (res != 3) {
+		if (res != 2) {
+			err = -EINVAL;
+			goto out;
+		}
+		n = 1;
+	}
+
+	switch (n) {
+	case 4:
+		r92su_write32(r92su, reg, val);
+		err = 0;
+		break;
+	case 2:
+		r92su_write16(r92su, reg, val);
+		err = 0;
+		break;
+	case 1:
+		r92su_write8(r92su, reg, val);
+		err = 0;
+		break;
+	default:
+		err = -EINVAL;
+		if (err)
+			goto out;
+		break;
+	}
+
+out:
+	return err ? err : count;
+}
+DEBUGFS_DECLARE_WO_FILE(hw_iowrite);
+
+
+DEBUGFS_READONLY_FILE(tx_pending_urbs, 12, "%d",
+		      atomic_read(&r92su->tx_pending_urbs));
+DEBUGFS_READONLY_FILE(chip_rev, 12, "0x%x", r92su->chip_rev);
+
+DEBUGFS_READONLY_FILE(eeprom_type, 12, "0x%x", r92su->eeprom_type);
+
+DEBUGFS_READONLY_FILE(rx_queue_len, 20, "%d", skb_queue_len(&r92su->rx_queue));
+
+DEBUGFS_READONLY_FILE(rf_type, 12, "0x%x", r92su->rf_type);
+
+DEBUGFS_READONLY_FILE(h2c_seq, 12, "%d", r92su->h2c_seq);
+DEBUGFS_READONLY_FILE(c2h_seq, 12, "%d", r92su->c2h_seq);
+
+int r92su_register_debugfs(struct r92su *r92su)
+{
+	r92su->dfs = debugfs_create_dir(KBUILD_MODNAME,
+		r92su->wdev.wiphy->debugfsdir);
+
+#define DEBUGFS_ADD(name)						\
+	debugfs_create_file(#name, r92su_debugfs_##name ##_ops.attr,	\
+			    r92su->dfs, r92su,				\
+			    &r92su_debugfs_##name ## _ops.fops);
+
+	if (!r92su->dfs)
+		return -EINVAL;
+
+	DEBUGFS_ADD(tx_pending_urbs);
+	DEBUGFS_ADD(hw_ioread);
+	DEBUGFS_ADD(hw_iowrite);
+	DEBUGFS_ADD(chip_rev);
+	DEBUGFS_ADD(eeprom_type);
+	DEBUGFS_ADD(rf_type);
+	DEBUGFS_ADD(sta_table);
+	DEBUGFS_ADD(connected_bss);
+	DEBUGFS_ADD(eeprom);
+	DEBUGFS_ADD(eeprom_raw);
+	DEBUGFS_ADD(h2c_seq);
+	DEBUGFS_ADD(c2h_seq);
+	DEBUGFS_ADD(rx_queue_len);
+	return 0;
+
+#undef DEBUGFS_ADD
+}
+
+void r92su_unregister_debugfs(struct r92su *r92su)
+{
+	if (r92su->dfs)
+		debugfs_remove_recursive(r92su->dfs);
+}
--- /dev/null
+++ b/drivers/net/wireless/r92su/debugfs.h
@@ -0,0 +1,74 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_DEBUGFS_H__
+#define __R92SU_DEBUGFS_H__
+
+struct r92su;
+
+enum r92su_mem_type_t {
+	R92SU_8,
+	R92SU_16,
+	R92SU_32,
+
+	/* last entry */
+	__MAX_R92SU_MEM_TYPE
+};
+
+struct r92su_debug_mem_rbe {
+	u32 reg;
+	u32 value;
+	enum r92su_mem_type_t type;
+};
+
+#define R92SU_DEBUG_RING_SIZE			64
+
+struct r92su_debug {
+	struct r92su_debug_mem_rbe ring[R92SU_DEBUG_RING_SIZE];
+	unsigned int ring_head, ring_tail, ring_len;
+};
+
+#ifdef CONFIG_R92SU_DEBUGFS
+
+int r92su_register_debugfs(struct r92su *r92su);
+void r92su_unregister_debugfs(struct r92su *r92su);
+
+#else /* CONFIG_R92SU_DEBUGFS */
+static inline int r92su_register_debugfs(struct r92su *r92su)
+{
+	return 0;
+}
+
+static inline void r92su_unregister_debugfs(struct r92su *r92su)
+{
+}
+#endif /* CONFIG_R92SU_DEBUGFS */
+
+#endif /* __R92SU_DEBUGFS_H__ */
--- /dev/null
+++ b/drivers/net/wireless/r92su/def.h
@@ -0,0 +1,364 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_DEF_H__
+#define __R92SU_DEF_H__
+
+#include "h2cc2h.h"
+
+#define RX_MPDU_QUEUE				0
+#define RX_CMD_QUEUE				1
+#define RX_MAX_QUEUE				2
+#define NUM_ACS					4
+
+#define SHORT_SLOT_TIME				9
+#define NON_SHORT_SLOT_TIME			20
+
+/* Rx smooth factor */
+#define	RX_SMOOTH_FACTOR			20
+
+/* Queue Select Value in TxDesc */
+#define QSLT_BK					0x1
+#define QSLT_BE					0x3
+#define QSLT_VI					0x5
+#define QSLT_VO					0x7
+#define QSLT_BEACON				0x10
+#define QSLT_HIGH				0x11
+#define QSLT_MGNT				0x12
+#define QSLT_CMD				0x13
+
+#define	PHY_RSSI_SLID_WIN_MAX			100
+#define	PHY_LINKQUALITY_SLID_WIN_MAX		20
+#define	PHY_BEACON_RSSI_SLID_WIN_MAX		10
+
+/* Tx Desc */
+#define TX_DESC_SIZE				32
+
+struct tx_hdr {
+	/* DWORD 0 */
+	__le16 pkt_len;		/*  0 - 15 */
+	__u8 offset;		/* 16 - 23 */
+	u8 type:2;		/* 24 - 25 */
+	u8 last_seg:1;		/* 26 */
+	u8 first_seg:1;		/* 27 */
+	u8 linip:1;		/* 28 */
+	u8 amsdu:1;		/* 29 */
+	u8 gf:1;		/* 30 */
+	u8 own:1;		/* 31 */
+
+	/* DWORD 1 */
+	u8 mac_id:5;		/*  0 -  4 */
+	u8 more_data:1;		/*  5 */
+	u8 more_frag:1;		/*  6 */
+	u8 pifs:1;		/*  7 */
+	u8 queue_sel:5;		/*  8 - 12 */
+	u8 ack_policy:2;	/* 13 - 14 */
+	u8 no_acm:1;		/* 15 */
+	u8 non_qos:1;		/* 16 */
+	u8 key_id:2;		/* 17 - 18 */
+	u8 oui:1;		/* 19 */
+	u8 pkt_type:1;		/* 20 */
+	u8 en_desc_id:1;	/* 21 */
+	u8 sec_type:2;		/* 22 - 23 */
+	u8 wds:1;		/* 24 */
+	u8 htc:1;		/* 25 */
+	u8 pkt_offset:5;	/* 26 - 30 */
+	u8 hwpc:1;		/* 31 */
+
+	/* DWORD 2 */
+	u8 data_retry_limit:6;	/*  0 -  5 */
+	u8 retry_limit_en:1;	/*  6 */
+	u8 bmc:1;		/*  7 */
+	u8 tsfl:4;		/*  8 - 11 */
+	u8 rts_retry_count:6;	/* 12 - 17 */
+	u8 data_retry_count:6;	/* 18 - 23 */
+	u8 rsvd_macid:5;	/* 24 - 28 */
+	u8 agg_en:1;		/* 29 */
+	u8 agg_break:1;		/* 30 */
+	u8 own_mac:1;		/* 31 */
+
+	/* DWORD 3 */
+	u8 heap_page;		/* 0  -  7 */
+	u8 tail_page;		/* 8  - 15 */
+	__le16 seq:12;		/* 16 - 27 */
+	u8 frag:4;		/* 28 - 31 */
+
+	/* DWORD 4 */
+	u8 rts_rate:6;		/*  0 -  5 */
+	u8 dis_rts_fb:1;	/*  6 */
+	u8 rts_rate_fb_limit:4;	/*  7 - 10 */
+	u8 cts_en:1;		/* 11 */
+	u8 rts_en:1;		/* 12 */
+	u8 ra_brsr_id:3;	/* 13 - 15 */
+	u8 tx_ht:1;		/* 16 */
+	u8 tx_short:1;		/* 17 */
+	u8 tx_bw:1;		/* 18 */
+	u8 tx_sub_carrier:2;	/* 19 - 20 */
+	u8 tx_stbc:2;		/* 21 - 22 */
+	u8 tx_rd:1;		/* 23 */
+	u8 rts_ht:1;		/* 24 */
+	u8 rts_short:1;		/* 25 */
+	u8 rts_bw:1;		/* 26 */
+	u8 rts_sub_carrier:2;	/* 27 - 28 */
+	u8 rts_stbc:2;		/* 29 - 30 */
+	u8 user_rate:1;		/* 31 */
+
+	/* DWORD 5 */
+	__le16 packet_id:9;	/*  0 -  8 */
+	u8 tx_rate:6;		/*  9 - 14 */
+	u8 dis_fb:1;		/* 15 */
+	u8 data_rate_fb_limit:5;/* 16 - 20 */
+	__le16 tx_agc:11;	/* 21 - 31 */
+
+	/* DWORD 6 */
+	__le16 ip_check_sum;	/* 0  - 15 */
+	__le16 tcp_check_sum;	/* 16 - 31 */
+
+	/* DWORD 7 */
+	__le16 tx_buffer_size;	/* 0  - 15 */
+	u8 ip_hdr_offset:8;	/* 16 - 23 */
+	u8 cmd_seq:7;		/* 24 - 30 */
+	u8 tcp_en:1;		/* 31 */
+} __packed;
+
+/* Rx Desc */
+#define RX_DESC_SIZE				24
+#define RX_DRV_INFO_SIZE_UNIT			8
+
+struct rx_hdr {
+	/* DWORD 0 */
+	__le16 pkt_len:14;	/*  0 - 13 */
+	u8 crc32:1;		/* 14 */
+	u8 icv:1;		/* 15 */
+	u8 drvinfo_size:4;	/* 16 - 19 */
+	u8 security:3;		/* 20 - 22 */
+	u8 qos:1;		/* 23 */
+	u8 shift:2;		/* 24 - 25 */
+	u8 phy_status:1;	/* 26 */
+	u8 swdec:1;		/* 27 */
+	u8 last_seg:1;		/* 28 */
+	u8 first_seg:1;		/* 29 */
+	u8 eor:1;		/* 30 */
+	u8 own:1;		/* 31 */
+
+	/* DWORD 1 */
+	u8 mac_id:5;		/*  0 -  4 */
+	u8 tid:4;		/*  5 -  8 */
+	u8 unkn0100:5;		/*  9 - 13 */
+	u8 paggr:1;		/* 14 */
+	u8 faggr:1;		/* 15 */
+	u8 a1_fit:4;		/* 16 - 19 */
+	u8 a2_fit:4;		/* 20 - 23 */
+	u8 pam:1;		/* 24 */
+	u8 pwr:1;		/* 25 */
+	u8 more_data:1;		/* 26 */
+	u8 more_frag:1;		/* 27 */
+	u8 type:2;		/* 28 - 29 */
+	u8 mc:1;		/* 30 */
+	u8 bc:1;		/* 31 */
+
+	/* DWORD 2 */
+	__le16 seq:12;		/*  0 - 11 */
+	u8 frag:4;		/* 12 - 15 */
+	u8 pkt_cnt;		/* 16 - 23 */
+	u8 unkn0200:6;		/* 24 - 29 */
+	u8 next_ind:1;		/* 30 */
+	u8 unkn0201:1;		/* 31 */
+
+	/* DWORD 3 */
+	u8 rx_mcs:6;		/*  0 -  5 */
+	u8 rx_ht:1;		/*  6 */
+	u8 amsdu:1;		/*  7 */
+	u8 splcp:1;		/*  8 */
+	u8 bw:1;		/*  9 */
+	u8 htc:1;		/* 10 */
+	u8 tcp_chk_rpt:1;	/* 11 */
+	u8 ip_chk_rpt:1;	/* 12 */
+	u8 tcp_chk_valid:1;	/* 13 */
+	u8 htc2:1;		/* 14 */
+	u8 hwpc_ind:1;		/* 15 */
+	__le16 iv0;		/* 16 - 31 */
+
+	/* DWORD 4 */
+	__le32 iv1;		/*  0 - 31 */
+
+	/* DWORD 5 */
+	__le32 tsf32;		/*  0 - 31 */
+} __packed;
+
+struct rx_hdr_phy_cck {
+	/* For CCK rate descriptor. This is an unsigned 8:1 variable.
+	 * LSB bit present 0.5. And MSB 7 bts present a signed value.
+	 * Range from -64 to + 63.5 */
+	u8 adc_pwdb_X[4];
+	u8 sq_rpt;
+	u8 cck_agc_rpt:6;
+	u8 report:2;
+} __packed;
+
+struct rx_hdr_phy_ofdm {
+	u8 gain_trws[4];
+	u8 pwdb_all;
+	u8 cfosho[4];
+	u8 cfotail[4];
+	u8 rxevm[2];
+	u8 rxsnr[4];
+	u8 pdsnr[2];
+	u8 csi_current[2];
+	u8 csi_target[2];
+	u8 sigevm[2];
+	u8 max_ex_power;
+} __packed;
+
+union rx_hdr_phy {
+	struct rx_hdr_phy_cck cck;
+	struct rx_hdr_phy_ofdm ofdm;
+};
+
+#define H2CC2H_HDR_LEN		(8)
+
+struct h2cc2h {
+	__le16 len;
+	u8 event;
+	u8 cmd_seq:7;
+	u8 last:1;
+
+	u8 agg_num;
+	u8 unkn;
+	__le16 agg_total_len;
+
+	u8 data[0];
+} __packed;
+
+struct tx_packet {
+	struct tx_hdr hdr;
+
+	union {
+		struct ieee80211_hdr i3e;
+		struct h2cc2h h2c;
+		u8 raw_data[0];
+	} __packed;
+} __packed;
+
+struct rx_packet {
+	struct rx_hdr hdr;
+	union {
+		/* No direct access to the rx data possible. The rx_hdr
+		 * contains shift value (used to tell the offset of the
+		 * ieee80211_hdr in 64-bit words).
+		 */
+
+		struct h2cc2h c2h;
+		union rx_hdr_phy phy;
+		u8 raw_data[0];
+	} __packed;
+} __packed;
+
+enum rtl_desc92_rate {
+	DESC92_RATE1M = 0x00,
+	DESC92_RATE2M = 0x01,
+	DESC92_RATE5_5M = 0x02,
+	DESC92_RATE11M = 0x03,
+
+	DESC92_RATE6M = 0x04,
+	DESC92_RATE9M = 0x05,
+	DESC92_RATE12M = 0x06,
+	DESC92_RATE18M = 0x07,
+	DESC92_RATE24M = 0x08,
+	DESC92_RATE36M = 0x09,
+	DESC92_RATE48M = 0x0a,
+	DESC92_RATE54M = 0x0b,
+
+	DESC92_RATEMCS0 = 0x0c,
+	DESC92_RATEMCS1 = 0x0d,
+	DESC92_RATEMCS2 = 0x0e,
+	DESC92_RATEMCS3 = 0x0f,
+	DESC92_RATEMCS4 = 0x10,
+	DESC92_RATEMCS5 = 0x11,
+	DESC92_RATEMCS6 = 0x12,
+	DESC92_RATEMCS7 = 0x13,
+	DESC92_RATEMCS8 = 0x14,
+	DESC92_RATEMCS9 = 0x15,
+	DESC92_RATEMCS10 = 0x16,
+	DESC92_RATEMCS11 = 0x17,
+	DESC92_RATEMCS12 = 0x18,
+	DESC92_RATEMCS13 = 0x19,
+	DESC92_RATEMCS14 = 0x1a,
+	DESC92_RATEMCS15 = 0x1b,
+	DESC92_RATEMCS15_SG = 0x1c,
+	DESC92_RATEMCS32 = 0x20,
+};
+
+enum rf_optype {
+	RF_OP_BY_SW_3WIRE = 0,
+	RF_OP_BY_FW,
+	RF_OP_MAX
+};
+
+enum ic_inferiority {
+	IC_INFERIORITY_A = 0,
+	IC_INFERIORITY_B = 1,
+};
+
+enum rf_type {
+	RF_1T1R = 0,
+	RF_1T2R = 1,
+	RF_2T2R = 2,
+	RF_2T2R_GREEN = 3,
+};
+
+enum ht_channel_width {
+	HT_CHANNEL_WIDTH_20 = 0,
+	HT_CHANNEL_WIDTH_20_40 = 1,
+};
+
+enum r92su_enc_alg {
+	NO_ENCRYPTION = 0,
+	WEP40_ENCRYPTION = 1,
+	TKIP_ENCRYPTION = 2,
+	TKIP_WTMIC = 3,
+	AESCCMP_ENCRYPTION = 4,
+	WEP104_ENCRYPTION = 5,
+
+	__MAX_ENCRYPTION
+};
+
+static inline void __check_def__(void)
+{
+	BUILD_BUG_ON(sizeof(struct tx_hdr) != TX_DESC_SIZE);
+	BUILD_BUG_ON(sizeof(struct rx_hdr) != RX_DESC_SIZE);
+	BUILD_BUG_ON(sizeof(struct h2cc2h) != H2CC2H_HDR_LEN);
+
+	BUILD_BUG_ON(offsetof(struct tx_hdr, ip_check_sum) != 24);
+	BUILD_BUG_ON(offsetof(struct tx_hdr, heap_page) != 12);
+	BUILD_BUG_ON(offsetof(struct rx_hdr, tsf32) != 20);
+}
+
+#endif /* __R92SU_DEF_H__ */
--- /dev/null
+++ b/drivers/net/wireless/r92su/eeprom.c
@@ -0,0 +1,224 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#include <linux/kernel.h>
+
+#include "r92su.h"
+#include "eeprom.h"
+#include "cmd.h"
+#include "reg.h"
+#include "usb.h"
+
+static int r92su_parse_eeprom(struct r92su *r92su)
+{
+	if (r92su->eeprom.id != cpu_to_le16(RTL8190_EEPROM_ID)) {
+		wiphy_err(r92su->wdev.wiphy, "eeprom signature check has failed.\n");
+		return -EINVAL;
+	}
+
+	switch (r92su->eeprom.board_type) {
+	case 0:
+		r92su->rf_type = R92SU_1T1R;
+		break;
+	case 1:
+		r92su->rf_type = R92SU_1T2R;
+		break;
+
+	case 2:
+		r92su->rf_type = R92SU_1T2R;
+		break;
+
+	default:
+		wiphy_err(r92su->wdev.wiphy, "unknown board type:%d.\n",
+			  r92su->eeprom.board_type);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void r92su_efuse_initialize(struct r92su *r92su)
+{
+	u8 tmp;
+
+	/* Enable LDOE25 Macro Block */
+	tmp = r92su_read8(r92su, REG_EFUSE_TEST + 3);
+	tmp |= BIT(7);
+	r92su_write8(r92su, REG_EFUSE_TEST + 3, tmp);
+
+	/* Enable EFuse Clock and set it for write action to 40 MHz */
+	r92su_write8(r92su, REG_EFUSE_CLK_CTRL, 0x3);
+
+	r92su_write8(r92su, REG_EFUSE_CTRL + 3, 0x72);
+}
+
+static void r92su_efuse_shutdown(struct r92su *r92su)
+{
+	u8 tmp;
+
+	/* Disable LDOE25 Macro Block */
+	tmp = r92su_read8(r92su, REG_EFUSE_TEST + 3);
+	tmp &= ~BIT(7);
+	r92su_write8(r92su, REG_EFUSE_TEST + 3, tmp);
+
+	/* Change EFuse Clock for write action to 500 KHz */
+	r92su_write8(r92su, REG_EFUSE_CLK_CTRL, 0x2);
+}
+
+static u8 __r92su_efuse_read(struct r92su *r92su, u16 address)
+{
+	u8 tmp;
+	int i = 0;
+
+#define R92SU_EFUSE_READ_RETRIES	10
+
+	r92su_write8(r92su, REG_EFUSE_CTRL + 1, (address & 0xff));
+
+	tmp = r92su_read8(r92su, REG_EFUSE_CTRL + 2);
+	tmp &= ~(BIT(0) | BIT(1));
+	tmp |= (address >> 8) & 0x3;
+	r92su_write8(r92su, REG_EFUSE_CTRL + 2, tmp);
+	r92su_write8(r92su, REG_EFUSE_CTRL + 3, 0x72); /* read */
+
+	do {
+		i++;
+		tmp = r92su_read8(r92su, REG_EFUSE_CTRL + 3);
+	} while (!(tmp & 0x80) && i < R92SU_EFUSE_READ_RETRIES);
+
+	if (i >= R92SU_EFUSE_READ_RETRIES)
+		return 0xff;
+
+	return r92su_read8(r92su, REG_EFUSE_CTRL);
+
+#undef R92SU_EFUSE_READ_RETRIES
+}
+
+u8 r92su_efuse_read(struct r92su *r92su, u16 address)
+{
+	u8 result;
+
+	r92su_efuse_initialize(r92su);
+	result = __r92su_efuse_read(r92su, address);
+	r92su_efuse_shutdown(r92su);
+	return result;
+}
+
+static int r92su_fetch_eeprom_data(struct r92su *r92su)
+{
+	u8 *eimage = (void *) &r92su->eeprom;
+	int off, i, len;
+	u8 eprom;
+
+	eprom = r92su_read8(r92su, REG_EEPROM_CMD);
+
+	if (eprom & EEPROM_CMD_93C46)
+		r92su->eeprom_type = EEPROM_93C46;
+	else
+		r92su->eeprom_type = EEPROM_BOOT_EFUSE;
+
+	if (!(eprom & EEPROM_CMD_AUTOLOAD_OK))
+		return -EAGAIN;
+
+	r92su_efuse_initialize(r92su);
+
+	memset(&r92su->eeprom, 0xff, sizeof(r92su->eeprom));
+
+	len = 0;
+	off = 0;
+#define EFUSE_BLOCK_SIZE (8)
+#define EFUSE_FETCH_SIZE (2)
+
+	/* guard against out-of-bound writes in the following code */
+	BUILD_BUG_ON(sizeof(r92su->eeprom) < 0xf * EFUSE_BLOCK_SIZE);
+
+	/* The eeprom data is stored in sparse blocks. Each block can be
+	 * between 1 byte (just descriptor, but no payload/bad block) and
+	 * 9 bytes (descriptor + 4 * 2 byte payload).
+	 *
+	 * The blocks are organized as follows:
+	 *  1. Block Descriptor Byte [desc]
+	 *      high nibble (= pos)
+	 *		position of the data block in the complete
+	 *		eeprom image (=eimage) [pos]
+	 *
+	 *      low nibble (= map)
+	 *		bitmap of useable data (0 = good, 1 = bad/skip)
+	 *
+	 *  2-9. data block (each 16-bits)
+	 */
+	while (off < R92SU_EFUSE_REAL_SIZE) {
+		u8 desc, map, pos;
+
+		desc = __r92su_efuse_read(r92su, off++);
+		if (desc == 0xff)
+			goto out;
+
+		pos = desc >> 4;
+		map = desc & 0xf;
+		for (i = 0; i < EFUSE_BLOCK_SIZE; i += EFUSE_FETCH_SIZE) {
+			if (!(map & 0x01)) {
+				len += EFUSE_FETCH_SIZE;
+				eimage[pos * EFUSE_BLOCK_SIZE + i] =
+					__r92su_efuse_read(r92su, off++);
+				if (off >= R92SU_EFUSE_REAL_SIZE)
+					goto out;
+
+				eimage[pos * EFUSE_BLOCK_SIZE + i + 1] =
+					__r92su_efuse_read(r92su, off++);
+				if (off >= R92SU_EFUSE_REAL_SIZE)
+					goto out;
+
+			}
+			map >>= 1;
+		}
+	}
+out:
+
+	r92su_efuse_shutdown(r92su);
+	return 0;
+
+#undef EFUSE_BLOCK_SIZE
+#undef EFUSE_FETCH_SIZE
+}
+
+int r92su_eeprom_read(struct r92su *r92su)
+{
+	int err = -EINVAL;
+
+	err = r92su_fetch_eeprom_data(r92su);
+	if (err)
+		return err;
+
+	err = r92su_parse_eeprom(r92su);
+	if (err)
+		return err;
+
+	return err;
+}
--- /dev/null
+++ b/drivers/net/wireless/r92su/eeprom.h
@@ -0,0 +1,118 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_EEPROM_H__
+#define __R92SU_EEPROM_H__
+
+enum r92su_eeprom_type {
+	EEPROM_93C46 = 0,
+	EEPROM_93C56 = 1,
+	EEPROM_BOOT_EFUSE = 2,
+};
+
+#define R92SU_EFUSE_REAL_SIZE	(512)
+
+#define RTL8190_EEPROM_ID	(0x8129)
+
+#define CHAN_NUM_2G     14
+#define RF_PATH         2
+#define CHAN_SET	3
+/* 0 = Chan 1-3, 1 = Chan 4-8, 2 = Chan 9-14 */
+
+enum r92su_custom_id_t {
+	EEPROM_CID_DEFAULT		= 0x00,
+	EEPROM_CID_ALPHA		= 0x01,
+	EEPROM_CID_SENAO		= 0x03,
+	EEPROM_CID_NETCORE		= 0x05,
+	EEPROM_CID_CAMEO		= 0X08,
+	EEPROM_CID_SITECOM		= 0x09,
+	EEPROM_CID_COREGA		= 0x0b,
+	EEPROM_CID_EDIMAX_BELKIN	= 0x0c,
+	EEPROM_CID_SERCOMM_BELKIN	= 0x0e,
+	EEPROM_CID_CAMEO1		= 0x0f,
+	EEPROM_CID_WNC_COREGA		= 0x12,
+	EEPROM_CID_CLEVO		= 0x13,
+	EEPROM_CID_WHQL			= 0xfe,
+};
+
+struct r92su_eeprom {
+	__le16 id;				/*  0 -  1 */
+	__le16 hpon;				/*  2 -  3 */
+	__le16 clk;				/*  4 -  5 */
+	__le16 testr;				/*  6 -  7 */
+	__le16 vid;				/*  8 -  9 */
+	__le16 did;				/* 10 - 11 */
+	u8 usb_optional;			/* 12 */
+	u8 usb_phy_para1[5];			/* 13 - 17 */
+	u8 mac_addr[6];				/* 18 - 23 */
+
+	/* seems to contain vendor and device identification strings */
+	u8 unkn2[56];				/* 24 - 79 */
+
+	/* WARNING
+	 * These definitions are mostly guesswork
+	 */
+	u8 version;				/* 80 */
+	u8 channel_plan;			/* 81 */
+	u8 custom_id;				/* 82 */
+	u8 sub_custom_id;			/* 83 */
+	u8 board_type;				/* 84 */
+
+	/* tx power base */
+	u8 tx_pwr_cck[RF_PATH][CHAN_SET];	/* 85 - 90 */
+	u8 tx_pwr_ht40_1t[RF_PATH][CHAN_SET];	/* 91 - 96 */
+	u8 tx_pwr_ht40_2t[RF_PATH][CHAN_SET];	/* 97 - 102 */
+
+	u8 pw_diff;				/* 103 */
+	u8 thermal_meter;			/* 104 */
+	u8 crystal_cap;				/* 105 */
+	u8 unkn3;				/* 106 */
+	u8 tssi[RF_PATH];			/* 107 - 108 */
+	u8 unkn4;				/* 109 */
+	u8 tx_pwr_ht20_diff[3];			/* 110 - 112 */
+	u8 tx_pwr_ofdm_diff[2];			/* 113 - 114, 124 */
+	u8 unkn5[6];				/* 115 - 120 */
+	u8 tx_pwr_group[1];			/* 121 ??? */
+	u8 regulatory;				/* 122 ??? */
+	u8 rf_ind_power_diff;			/* 123 */
+	u8 tx_pwr_ofdm_diff_cont;		/* 124 */
+	u8 unkn6[3];				/* 125 - 127 */
+} __packed;
+
+static inline void __check_eeprom__(void)
+{
+	BUILD_BUG_ON(sizeof(struct r92su_eeprom) > 128);
+}
+
+struct r92su;
+
+u8 r92su_efuse_read(struct r92su *r92su, u16 address);
+int r92su_eeprom_read(struct r92su *r92su);
+#endif /* __R92SU_EEPROM_H__ */
--- /dev/null
+++ b/drivers/net/wireless/r92su/event.c
@@ -0,0 +1,204 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+
+#include <asm/unaligned.h>
+
+#include "r92su.h"
+#include "event.h"
+#include "h2cc2h.h"
+
+typedef void (*c2h_handler)(struct r92su *, const struct h2cc2h *);
+
+static void c2h_fwdbg_event(struct r92su *r92su, const struct h2cc2h *c2h)
+{
+	wiphy_notice(r92su->wdev.wiphy, "fwdbg: %.*s%s", c2h->len, c2h->data,
+		    c2h->data[c2h->len - 2] == '\n' ? "" : "\n");
+}
+
+static void c2h_survey_event(struct r92su *r92su, const struct h2cc2h *c2h)
+{
+	const struct h2cc2h_bss *c2h_bss = (const void *)&c2h->data;
+	struct r92su_add_bss *bss_priv;
+	u16 len;
+
+	/* Looks like the FW just attaches the raw probe_response IEs
+	 * ... along with the FCS (since we enabled the RX flag for it
+	 */
+	len = le16_to_cpu(c2h->len) - FCS_LEN;
+
+	if (len < sizeof(*c2h_bss) || c2h->len != c2h_bss->length ||
+	    le32_to_cpu(c2h_bss->ie_length) <= 12) {
+		wiphy_err(r92su->wdev.wiphy, "received survey event with bad length.");
+		r92su_mark_dead(r92su);
+		return;
+	}
+
+	bss_priv = kmalloc(len - sizeof(*c2h_bss) + sizeof(*bss_priv),
+			   GFP_ATOMIC);
+	if (!bss_priv)
+		return;
+
+	memcpy(&bss_priv->fw_bss, c2h_bss, len);
+	bss_priv->fw_bss.length = cpu_to_le32(len);
+	bss_priv->fw_bss.ie_length =
+		le32_to_cpu(bss_priv->fw_bss.ie_length) - FCS_LEN;
+	llist_add(&bss_priv->head, &r92su->add_bss_list);
+	queue_work(r92su->wq, &r92su->add_bss_work);
+}
+
+static void c2h_survey_done_event(struct r92su *r92su,
+				  const struct h2cc2h *c2h)
+{
+	/* prevent race with r92su_stop */
+	if (!r92su_is_open(r92su))
+		return;
+
+	if (cancel_delayed_work(&r92su->survey_done_work))
+		queue_delayed_work(r92su->wq, &r92su->survey_done_work, 0);
+}
+
+static void c2h_join_bss_event(struct r92su *r92su, const struct h2cc2h *c2h)
+{
+	const struct c2h_join_bss_event *join_bss = (const void *)c2h->data;
+
+	if (r92su->connect_result)
+		return;
+
+	r92su->connect_result = kmemdup(join_bss, c2h->len, GFP_ATOMIC);
+	queue_work(r92su->wq, &r92su->connect_bss_work);
+}
+
+static void c2h_add_sta_event(struct r92su *r92su, const struct h2cc2h *c2h)
+{
+	const struct c2h_add_sta_event *addsta = (const void *) c2h->data;
+	struct r92su_sta *new_sta;
+	unsigned int id = le32_to_cpu(addsta->aid);
+
+	new_sta = r92su_sta_alloc(r92su, addsta->mac_addr, id, GFP_ATOMIC);
+	if (new_sta) {
+		new_sta->aid = le32_to_cpu(addsta->aid);
+		r92su_sta_replace(r92su, new_sta);
+	}
+}
+
+static void c2h_del_sta_event(struct r92su *r92su, const struct h2cc2h *c2h)
+{
+	const struct c2h_del_sta_event *delsta = (const void *) c2h->data;
+	struct r92su_sta *sta;
+
+	rcu_read_lock();
+	sta = r92su_sta_get(r92su, delsta->mac_addr);
+	if (sta)
+		r92su_sta_del(r92su, sta->mac_id);
+
+	switch (r92su->wdev.iftype) {
+	case NL80211_IFTYPE_STATION:
+		r92su_disconnect_bss_event(r92su);
+		break;
+	default:
+		break;
+	}
+
+	rcu_read_unlock();
+}
+
+static void c2h_atim_done_event(struct r92su *r92su, const struct h2cc2h *c2h)
+{
+
+}
+
+static void c2h_report_pwr_state_event(struct r92su *r92su,
+				       const struct h2cc2h *c2h)
+{
+
+}
+
+static void c2h_wps_pbc_event(struct r92su *r92su, const struct h2cc2h *c2h)
+{
+
+}
+
+static void c2h_addba_report_event(struct r92su *r92su,
+				   const struct h2cc2h *c2h)
+{
+	const struct c2h_add_ba_event *add_ba = (const void *) c2h->data;
+	struct r92su_sta *sta;
+
+	rcu_read_lock();
+	sta = r92su_sta_get(r92su, add_ba->mac_addr);
+	if (sta) {
+		r92su_sta_alloc_tid(r92su, sta, add_ba->tid,
+				    le16_to_cpu(add_ba->ssn));
+	}
+	rcu_read_unlock();
+}
+
+void r92su_c2h_event(struct r92su *r92su, const struct h2cc2h *c2h)
+{
+#define ADD_HANDLER(_id, _handler)	case (_id): (_handler((r92su), (c2h))); break;
+
+	unsigned int sequence = r92su->c2h_seq++;
+
+	if (sequence != c2h->cmd_seq) {
+		wiphy_err(r92su->wdev.wiphy, "received an c2h event out of sequence.\n");
+		wiphy_err(r92su->wdev.wiphy, "expected: %d, got %d\n", sequence,
+			  c2h->cmd_seq);
+
+		r92su->c2h_seq = c2h->cmd_seq + 1;
+	}
+
+	wiphy_notice(r92su->wdev.wiphy, "c2h event:%x len:%d\n",
+		     c2h->event, c2h->len);
+
+	switch (c2h->event) {
+	ADD_HANDLER(C2H_FWDBG_EVENT, c2h_fwdbg_event);
+	ADD_HANDLER(C2H_SURVEY_EVENT, c2h_survey_event);
+	ADD_HANDLER(C2H_SURVEY_DONE_EVENT, c2h_survey_done_event);
+	ADD_HANDLER(C2H_JOIN_BSS_EVENT, c2h_join_bss_event);
+	ADD_HANDLER(C2H_ADD_STA_EVENT, c2h_add_sta_event);
+	ADD_HANDLER(C2H_DEL_STA_EVENT, c2h_del_sta_event);
+	ADD_HANDLER(C2H_ATIM_DONE_EVENT, c2h_atim_done_event);
+	ADD_HANDLER(C2H_REPORT_PWR_STATE_EVENT, c2h_report_pwr_state_event);
+	ADD_HANDLER(C2H_WPS_PBC_EVENT, c2h_wps_pbc_event);
+	ADD_HANDLER(C2H_ADDBA_REPORT_EVENT, c2h_addba_report_event);
+
+	default:
+		wiphy_err(r92su->wdev.wiphy, "received invalid c2h event:%x\n",
+			  c2h->event);
+		print_hex_dump_bytes("C2H:", DUMP_PREFIX_OFFSET, c2h,
+				     c2h->len + sizeof(*c2h));
+		r92su_mark_dead(r92su);
+		break;
+	}
+
+#undef ADD_HANDLER
+}
--- /dev/null
+++ b/drivers/net/wireless/r92su/event.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_EVENT_H__
+#define __R92SU_EVENT_H__
+
+#include "h2cc2h.h"
+
+void r92su_c2h_event(struct r92su *r92su, const struct h2cc2h *c2h);
+
+#endif /* __R92SU_RX_H__ */
+
--- /dev/null
+++ b/drivers/net/wireless/r92su/fw.c
@@ -0,0 +1,323 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+
+#include <linux/firmware.h>
+#include "r92su.h"
+#include "usb.h"
+#include "fw.h"
+#include "def.h"
+#include "reg.h"
+
+static int r92su_parse_firmware(struct r92su *r92su)
+{
+	const struct fw_hdr *hdr;
+	unsigned int sram_size;
+	unsigned int imem_size;
+	unsigned int dmem_size;
+
+	if (r92su->fw->size > RTL8192_MAX_RAW_FIRMWARE_CODE_SIZE) {
+		wiphy_err(r92su->wdev.wiphy, "firmware is too big.\n");
+		return -EINVAL;
+	}
+
+	r92su->fw_header = hdr = (const void *) r92su->fw->data;
+
+	if ((hdr->signature != cpu_to_le32(R8192SU_FW_SIGNATURE)) &&
+	    (hdr->signature != cpu_to_le32(R8712SU_FW_SIGNATURE))) {
+		wiphy_err(r92su->wdev.wiphy, "firmware signature check has failed.\n");
+		return -EINVAL;
+	}
+
+	r92su->fw_version = le16_to_cpu(hdr->version);
+	wiphy_info(r92su->wdev.wiphy, "firmware version: 0x%x\n",
+		 r92su->fw_version);
+
+	r92su->fw_imem_len = imem_size = le32_to_cpu(hdr->img_imem_size);
+	r92su->fw_sram_len = sram_size = le32_to_cpu(hdr->img_sram_size);
+	dmem_size = le32_to_cpu(hdr->dmem_size);
+
+	r92su->fw_imem = r92su->fw->data + RT_8192S_FIRMWARE_HDR_SIZE;
+	r92su->fw_sram = r92su->fw_imem + imem_size;
+
+	if (imem_size == 0 || imem_size >= RTL8192_MAX_FIRMWARE_CODE_SIZE) {
+		wiphy_err(r92su->wdev.wiphy, "firmware's imem size is out of range\n");
+		return -EINVAL;
+	}
+
+	if (sram_size == 0 || sram_size >= RTL8192_MAX_FIRMWARE_CODE_SIZE) {
+		wiphy_err(r92su->wdev.wiphy, "firmware's sram size is out of range\n");
+		return -EINVAL;
+	}
+
+	if (dmem_size != sizeof(struct fw_priv)) {
+		wiphy_err(r92su->wdev.wiphy, "firmware's dmem size is out of range\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int r92su_prepare_firmware(struct r92su *r92su)
+{
+	struct fw_priv *dmem = &r92su->fw_dmem;
+
+	memset(dmem, 0, sizeof(*dmem));
+
+	/* For SDIO:
+	 * dmem->hci_sel = RTL8712_HCI_TYPE_72SDIO;
+	 */
+	r92su_usb_prepare_firmware(r92su);
+
+	dmem->bw_40mhz_en = 1;
+
+	dmem->mp_mode = 0; /* what's mp mode? multi-peer? mesh portal? */
+	dmem->qos_en = 1;
+	dmem->ampdu_en = 1;
+	dmem->rate_control_offload = 1;
+	dmem->aggregation_offload = 1;
+	dmem->mlme_offload = 1;
+	dmem->vcs_type = 2; /* 0: off, 1: on, 2: auto */
+	dmem->vcs_mode = 1; /* 0: off(presumably), 1:RTS/CTS, 2:CTS-Self */
+
+	dmem->turbo_mode = 0;
+	dmem->low_power_mode = 0;
+	dmem->chip_version = r92su->chip_rev; /* not necessarily correct ?! */
+	dmem->usb_ep_num = 0x4;	/* 4 eps */
+	dmem->rf_config = r92su->rf_type;
+
+	/* When scanning, send out two probe requests.
+	 *  1. wildcard ssid
+	 *  2. specified ssid - if set/available
+	 */
+	dmem->rsvd024 = 1;
+
+	return 0;
+}
+
+static int r92su_upload_firmware_part(struct r92su *r92su,
+				      const void *data, unsigned int len)
+{
+	const unsigned int block_size = 2048;
+
+	unsigned int done = 0;
+	const void *iter = data;
+	int err;
+
+	do {
+		struct tx_hdr *hdr;
+		struct sk_buff *skb;
+		unsigned int current_block;
+
+		skb = __dev_alloc_skb(TX_DESC_SIZE + block_size, GFP_KERNEL);
+		if (!skb)
+			return -ENOMEM;
+
+		hdr = (struct tx_hdr *) skb_put(skb, sizeof(*hdr));
+		memset(hdr, 0, sizeof(*hdr));
+
+		current_block = min(block_size, len - done);
+		done += current_block;
+
+		hdr->pkt_len = current_block;
+		hdr->linip = (len == done);
+
+		memcpy(skb_put(skb, current_block), iter, current_block);
+		err = r92su_usb_tx(r92su, skb, RTL8712_VOQ);
+		if (err)
+			return err;
+
+		iter += current_block;
+	} while (done < len);
+
+	return 0;
+}
+
+static int r92su_upload_mem_wait(struct r92su *r92su, const u8 done_flag,
+				 const u8 done2_flag, const char *mem)
+{
+	u8 cpu_status;
+	int tries = 1000;
+
+	do {
+		cpu_status = r92su_read8(r92su, REG_TCR);
+		if (cpu_status & done_flag)
+			break;
+		udelay(50);
+	} while (--tries);
+
+	if (!(cpu_status & done2_flag) || (tries == 0)) {
+		wiphy_err(r92su->wdev.wiphy, "firmware's %s upload %s cpu_status=0x%x\n",
+			mem, (tries == 0) ? "timedout" : "failed", cpu_status);
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static int r92su_firmware_enable_cpu(struct r92su *r92su)
+{
+	u32 tries = 1000;
+	u16 func;
+	u8 clk, cpu_status;
+
+	/* select clock */
+	clk = r92su_read8(r92su, REG_SYS_CLKR);
+	clk |= SYS_CPU_CLKSEL;
+	r92su_write8(r92su, REG_SYS_CLKR, clk);
+
+	/* Enable CPU. */
+	func = r92su_read16(r92su, REG_SYS_FUNC_EN);
+	func |= FEN_CPUEN;
+	r92su_write16(r92su, REG_SYS_FUNC_EN, func);
+
+	/* Polling IMEM Ready after CPU has refilled. */
+	do {
+		cpu_status = r92su_read8(r92su, REG_TCR);
+		if (cpu_status & IMEM_RDY)
+			break;
+
+		udelay(20);
+	} while (--tries);
+
+	return !!(cpu_status & IMEM_RDY) ? 0 : -ETIMEDOUT;
+}
+
+static int r92su_upload_imem(struct r92su *r92su)
+{
+	int err = -EINVAL;
+
+	err = r92su_upload_firmware_part(r92su, r92su->fw_imem,
+					 r92su->fw_imem_len);
+	if (err)
+		return err;
+
+	err = r92su_upload_mem_wait(r92su, IMEM_CODE_DONE,
+				     IMEM_CHK_RPT, "imem");
+	if (err)
+		return err;
+	return 0;
+}
+
+static int r92su_upload_sram(struct r92su *r92su)
+{
+	int err = -EINVAL;
+
+	err = r92su_upload_firmware_part(r92su, r92su->fw_sram,
+					 r92su->fw_sram_len);
+	if (err)
+		return err;
+
+	err = r92su_upload_mem_wait(r92su, EMEM_CODE_DONE,
+				    EMEM_CHK_RPT, "sram");
+	if (err)
+		return err;
+
+	err = r92su_firmware_enable_cpu(r92su);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int r92su_upload_dmem(struct r92su *r92su)
+{
+	int err = -EINVAL;
+
+	err = r92su_upload_firmware_part(r92su, &r92su->fw_dmem,
+					 sizeof(r92su->fw_dmem));
+	if (err)
+		return err;
+
+	err = r92su_upload_mem_wait(r92su, DMEM_CODE_DONE,
+				    DMEM_CODE_DONE, "dmem");
+	if (err)
+		return err;
+
+	/* give firmware some time to boot */
+	msleep(400);
+
+	err = r92su_upload_mem_wait(r92su, FWRDY, LOAD_FW_READY, "boot");
+	if (err)
+		return err;
+
+	return 0;
+}
+
+int r92su_upload_firmware(struct r92su *r92su)
+{
+	int err = -EINVAL;
+
+	err = r92su_upload_imem(r92su);
+	if (err)
+		return err;
+
+	err = r92su_upload_sram(r92su);
+	if (err)
+		return err;
+
+	err = r92su_upload_dmem(r92su);
+	if (err)
+		return err;
+
+	r92su->fw_loaded = true;
+
+	return err;
+}
+
+int r92su_load_firmware(struct r92su *r92su)
+{
+	int err = -EINVAL;
+
+	/* only load and parse the firmware only once. */
+	if (r92su->fw)
+		return 0;
+
+	err = request_firmware(&r92su->fw, RTL8192SU_FIRMWARE,
+			       &r92su->udev->dev);
+	if (err)
+		return err;
+
+	err = r92su_parse_firmware(r92su);
+	if (err)
+		return err;
+
+	err = r92su_prepare_firmware(r92su);
+	if (err)
+		return err;
+
+	return err;
+}
+
+void r92su_release_firmware(struct r92su *r92su)
+{
+	release_firmware(r92su->fw);
+	r92su->fw = NULL;
+}
--- /dev/null
+++ b/drivers/net/wireless/r92su/fw.h
@@ -0,0 +1,216 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_FW_H__
+#define __R92SU_FW_H__
+
+#define RTL8712_HCI_TYPE_72USB			0x12
+#define RTL8712_HCI_TYPE_72SDIO			0x03
+
+#define RTL8192_MAX_FIRMWARE_CODE_SIZE		(64 * 1024)
+#define RTL8192_MAX_RAW_FIRMWARE_CODE_SIZE	200000
+#define RTL8192_CPU_START_OFFSET		0x80
+/* Firmware Local buffer size. 64k */
+#define	MAX_FIRMWARE_CODE_SIZE			0xFF00
+
+#define	RT_8192S_FIRMWARE_HDR_SIZE		80
+#define RT_8192S_FIRMWARE_HDR_EXCLUDE_PRI_SIZE	32
+
+/* support till 64 bit bus width OS */
+#define MAX_DEV_ADDR_SIZE			8
+#define MAX_FIRMWARE_INFORMATION_SIZE		32
+#define MAX_802_11_HEADER_LENGTH		(40 + \
+						MAX_FIRMWARE_INFORMATION_SIZE)
+#define ENCRYPTION_MAX_OVERHEAD			128
+#define MAX_FRAGMENT_COUNT			8
+#define MAX_TRANSMIT_BUFFER_SIZE		(1600 + \
+						(MAX_802_11_HEADER_LENGTH + \
+						ENCRYPTION_MAX_OVERHEAD) *\
+						MAX_FRAGMENT_COUNT)
+
+/* The following DM control code are for Reg0x364, */
+#define	FW_DIG_ENABLE_CTL			BIT(0)
+#define	FW_HIGH_PWR_ENABLE_CTL			BIT(1)
+#define	FW_SS_CTL				BIT(2)
+#define	FW_RA_INIT_CTL				BIT(3)
+#define	FW_RA_BG_CTL				BIT(4)
+#define	FW_RA_N_CTL				BIT(5)
+#define	FW_PWR_TRK_CTL				BIT(6)
+#define	FW_IQK_CTL				BIT(7)
+#define	FW_FA_CTL				BIT(8)
+#define	FW_DRIVER_CTRL_DM_CTL			BIT(9)
+#define	FW_PAPE_CTL_BY_SW_HW			BIT(10)
+#define	FW_DISABLE_ALL_DM			0
+#define	FW_PWR_TRK_PARAM_CLR			0x0000ffff
+#define	FW_RA_PARAM_CLR				0xffff0000
+
+/* 8-bytes alignment required */
+struct fw_priv {
+	/* --- long word 0 ---- */
+	/* 0x12: CE product, 0x92: IT product */
+	u8 signature_0;
+	/* 0x87: CE product, 0x81: IT product */
+	u8 signature_1;
+	/* 0x81: PCI-AP, 01:PCIe, 02: 92S-U,
+	 * 0x82: USB-AP, 0x12: 72S-U, 03:SDIO */
+	u8 hci_sel;
+	/* the same value as register value  */
+	u8 chip_version;
+	/* customer  ID low byte */
+	u8 customer_id_0;
+	/* customer  ID high byte */
+	u8 customer_id_1;
+	/* 0x11:  1T1R, 0x12: 1T2R,
+	 * 0x92: 1T2R turbo, 0x22: 2T2R */
+	u8 rf_config;
+	/* 4: 4EP, 6: 6EP, 11: 11EP */
+	u8 usb_ep_num;
+
+	/* --- long word 1 ---- */
+	/* regulatory class bit map 0 */
+	u8 regulatory_class_0;
+	/* regulatory class bit map 1 */
+	u8 regulatory_class_1;
+	/* regulatory class bit map 2 */
+	u8 regulatory_class_2;
+	/* regulatory class bit map 3 */
+	u8 regulatory_class_3;
+	/* 0:SWSI, 1:HWSI, 2:HWPI */
+	u8 rfintfs;
+	u8 def_nettype;
+	u8 turbo_mode;
+	u8 low_power_mode;
+
+	/* --- long word 2 ---- */
+	/* 0x00: normal, 0x03: MACLBK, 0x01: PHYLBK */
+	u8 lbk_mode;
+	/* 1: for MP use, 0: for normal
+	 * driver (to be discussed) */
+	u8 mp_mode;
+	/* 0: off, 1: on, 2: auto */
+	u8 vcs_type;
+	/* 0: none, 1: RTS/CTS, 2: CTS to self */
+	u8 vcs_mode;
+	u8 rsvd022;
+	u8 rsvd023;
+	u8 rsvd024;
+	u8 rsvd025;
+
+	/* --- long word 3 ---- */
+	/* QoS enable */
+	u8 qos_en;
+	/* 40MHz BW enable */
+	/* 4181 convert AMSDU to AMPDU, 0: disable */
+	u8 bw_40mhz_en;
+	u8 amsdu2ampdu_en;
+	/* 11n AMPDU enable */
+	u8 ampdu_en;
+	/* FW offloads, 0: driver handles */
+	u8 rate_control_offload;
+	/* FW offloads, 0: driver handles */
+	u8 aggregation_offload;
+	u8 rsvd030;
+	u8 rsvd031;
+
+	/* --- long word 4 ---- */
+	/* 1. FW offloads, 0: driver handles */
+	u8 beacon_offload;
+	/* 2. FW offloads, 0: driver handles */
+	u8 mlme_offload;
+	/* 3. FW offloads, 0: driver handles */
+	u8 hwpc_offload;
+	/* 4. FW offloads, 0: driver handles */
+	u8 tcp_checksum_offload;
+	/* 5. FW offloads, 0: driver handles */
+	u8 tcp_offload;
+	/* 6. FW offloads, 0: driver handles */
+	u8 ps_control_offload;
+	/* 7. FW offloads, 0: driver handles */
+	u8 wwlan_offload;
+	u8 rsvd040;
+
+	/* --- long word 5 ---- */
+	/* tcp tx packet length low byte */
+	u8 tcp_tx_frame_len_l;
+	/* tcp tx packet length high byte */
+	u8 tcp_tx_frame_len_h;
+	/* tcp rx packet length low byte */
+	u8 tcp_rx_frame_len_l;
+	/* tcp rx packet length high byte */
+	u8 tcp_rx_frame_len_h;
+	u8 rsvd050;
+	u8 rsvd051;
+	u8 rsvd052;
+	u8 rsvd053;
+} __packed;
+
+#define	R8712SU_FW_SIGNATURE	(0x8712)
+#define	R8192SU_FW_SIGNATURE	(0x8192)
+
+/* 8-byte alinment required */
+struct fw_hdr {
+	__le16 signature;
+
+	/* 0x8000 ~ 0x8FFF for FPGA version,
+	 * 0x0000 ~ 0x7FFF for ASIC version */
+	__le16 version;
+
+	/* define the size of boot loader */
+	__le32 dmem_size;
+
+	/* define the size of FW in IMEM */
+	__le32 img_imem_size;
+	/* define the size of FW in SRAM */
+	__le32 img_sram_size;
+
+	/* define the size of DMEM variable */
+	__le32 fw_priv_size;
+	__le16 efuse_addr;
+	__le16 h2ccnd_resp_addr;
+
+	__le32 svn_evision;
+	__le32 release_time;
+
+	struct fw_priv fwpriv;
+
+} __packed;
+
+static inline void __check_fw__(void)
+{
+	BUILD_BUG_ON(sizeof(struct fw_priv) >= MAX_FIRMWARE_CODE_SIZE);
+}
+
+struct r92su;
+
+int r92su_load_firmware(struct r92su *r92su);
+int r92su_upload_firmware(struct r92su *r92su);
+void r92su_release_firmware(struct r92su *r92su);
+
+#endif /* __R92SU_FW_H__ */
--- /dev/null
+++ b/drivers/net/wireless/r92su/h2cc2h.h
@@ -0,0 +1,471 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_H2CC2H_H__
+#define __R92SU_H2CC2H_H__
+
+#include <linux/ieee80211.h>
+
+struct h2c_rates {
+	u8 rates[8];
+} __packed;
+
+struct h2c_ext_rates {
+	u8 rates[16];
+} __packed;
+
+struct h2c_iocmd {
+	union {
+		struct {
+			u8 cmdclass;
+			__le16 value;
+			u8 index;
+		} __packed;
+
+		u32 cmd;
+	} __packed;
+} __packed;
+
+struct h2c_set_pwrmode {
+	u8 mode;
+	u8 flag_low_traffic_en;
+	u8 flag_lpnav_en;
+	u8 flag_rf_low_snr_en;
+	/* 1: dps, 0: 32k */
+	u8 flag_dps_en;
+	u8 bcn_rx_en;
+	u8 bcn_pass_cnt;
+	/* beacon TO (ms). ¡§=0¡¨ no limit. */
+	u8 bcn_to;
+	__le16	bcn_itv;
+	/* only for VOIP mode. */
+	u8 app_itv;
+	u8 awake_bcn_itvl;
+	u8 smart_ps;
+	/* unit: 100 ms */
+	u8 bcn_pass_period;
+} __packed;
+
+struct h2c_sta_psm {
+	u8 aid;
+	u8 status;
+	u8 addr[ETH_ALEN];
+} __packed;
+
+struct h2c_basic_rates {
+	struct h2c_rates basic_rates;
+} __packed;
+
+enum h2c_channel_plan_types {
+	CHANNEL_PLAN_FCC = 0,
+	CHANNEL_PLAN_IC = 1,
+	CHANNEL_PLAN_ETSI = 2,
+	CHANNEL_PLAN_SPAIN = 3,
+	CHANNEL_PLAN_FRANCE = 4,
+	CHANNEL_PLAN_MKK = 5,
+	CHANNEL_PLAN_MKK1 = 6,
+	CHANNEL_PLAN_ISRAEL = 7,
+	CHANNEL_PLAN_TELEC = 8,
+
+	/* Deprecated */
+	CHANNEL_PLAN_MIC = 9,
+	CHANNEL_PLAN_GLOBAL_DOMAIN = 10,
+	CHANNEL_PLAN_WORLD_WIDE_13 = 11,
+	CHANNEL_PLAN_TELEC_NETGEAR = 12,
+
+	CHANNEL_PLAN_NCC = 13,
+	CHANNEL_PLAN_5G = 14,
+	CHANNEL_PLAN_5G_40M = 15,
+
+	/* keep it last */
+	__MAX_CHANNEL_PLAN
+};
+
+struct h2c_channel_plan {
+	__le32 channel_plan;	/* see h2c_channel_plan_types */
+} __packed;
+
+struct h2c_antenna {
+	u8 tx_antenna_set;
+	u8 rx_antenna_set;
+	u8 tx_antenna;
+	u8 rx_antenna;
+} __packed;
+
+struct h2c_set_mac {
+	u8 mac_addr[ETH_ALEN];
+} __packed;
+
+struct h2c_join_bss_rpt {
+	u8 opmode;
+	u8 ps_qos_info;
+	u8 bssid[6];
+	__le16 bcnitv;
+	__le16 aid;
+} __packed;
+
+struct h2c_site_survey {
+	__le32 active;		/* 0: passive, 1:active */
+	__le32 bsslimit;	/* 1 - 48 */
+	__le32 ssidlen;
+	u8 ssid[IEEE80211_MAX_SSID_LEN + 1];
+} __packed;
+
+struct h2c_disconnect {
+	__le32 rsvd0;
+} __packed;
+
+struct h2c_set_channel {
+	__le32 channel;
+} __packed;
+
+enum r92su_auth_mode {
+	R92SU_AUTH_OPEN = 0,
+	R92SU_AUTH_SHARED = 1,
+	R92SU_AUTH_8021X = 2,
+};
+
+enum r92su_auth_1x {
+	R92SU_WPA_PSK = 0,
+	R92SU_WPA_EAP = 1,
+};
+
+struct h2c_auth {
+	u8 mode;
+	u8 _1x;		/* 0 = PSK, 1 = EAP */
+	u8 rsvd2[2];
+} __packed;
+
+struct h2c_key {
+	u8 algorithm;	/* r92su_enc_alg */
+	u8 key_id;
+	u8 group_key;	/* 0 = unicast key, 1 = group key */
+	u8 key[16];
+} __packed;
+
+struct h2c_sta_key {
+	u8 mac_addr[ETH_ALEN];
+	u8 algorithm;	/* r92su_enc_alg */
+	u8 key[16];
+};
+
+struct h2c_add_ba_req {
+	__le32 tid;
+};
+
+struct c2h_sta_key_event {
+	u8 mac_addr[ETH_ALEN];
+	u8 keyid;
+	u8 rsvd;
+};
+
+struct h2c_11fh_network_configuration {	/* ndis_802_11_configuration_fh */
+	__le32 length;
+	__le32 hop_pattern;		/* as defined by 802.11, MSB set */
+	__le32 hop_set;			/* = 1, if non-802.11 */
+	__le32 dwell_time;		/* units are in Kibi usec */
+} __packed;
+
+struct h2c_network_configuration {	/* ndis_802_11_configuration */
+	__le32 length;
+	__le32 beacon_period;		/* units are in Kibi usec */
+	__le32 atim_window;		/* units are in Kibi usec */
+	__le32 frequency;		/* Spec says units are kHz -
+					 * but the fw gives us
+					 * channel index 1-14?! */
+	struct h2c_11fh_network_configuration fh_config;
+} __packed;
+
+enum h2c_network_infrastruct_mode {
+	MODE_IBSS,
+	MODE_BSS,
+	MODE_AUTO,
+	MODE_INFRA_MAX,		/*
+				 * Apparently that's not a real value,
+				 * just the upper bound
+				 */
+	MODE_AP,		/* maybe this should be = INFRA_MAX? */
+
+	/* keep this last */
+	__MAX_NETWORK_MODE
+};
+
+enum h2c_op_modes {
+	OP_AUTO = 0,		/* Let the driver decides which AP to join */
+	OP_ADHOC,		/* Single cell network (Ad-Hoc Clients) */
+	OP_INFRA,		/* Multi cell network, roaming, ... */
+	OP_MASTER,		/* Synchronisation master or AP - useless */
+	OP_REPEAT,		/* Wireless Repeater (forwarder) - useless */
+	OP_SECOND,		/* Secondary master/repeater (backup) - useless */
+	OP_MONITOR,		/* Passive monitor (listen only) - useless */
+
+	/* keep this last */
+	__MAC_OP_MODES
+};
+
+enum h2c_network_type {
+	TYPE_11FH = 0,
+	TYPE_11DS,
+	TYPE_11OFDM5GHZ,
+	TYPE_11OFDM2GHZ,
+
+	/* keep this last */
+	__MAX_NETWORK_TYPE
+};
+
+struct h2c_op_mode {
+	u8 mode;		/* see h2c_op_modes */
+	u8 padding[3];
+} __packed;
+
+struct h2c_ssid {		/* ndis_802_11_ssid */
+	u32 length;
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+} __packed;
+
+struct h2c_fixed_ies {
+	__le64 timestamp;
+	__le16 beaconint;
+	__le16 caps;
+	u8 ie[0];		/*
+				 * (fixed?) and variable IE content -
+				 * can be up to 768 bytes
+				 */
+} __packed;
+
+struct h2cc2h_bss {		/* ndis_wlan_bssid_ex */
+	__le32 length;		/* length of the full struct */
+	u8 bssid[6];
+	u8 padding[2];
+	struct h2c_ssid	ssid;
+	__le32 privacy;
+	__le32 rssi;		/* ??? - maybe for request/survey */
+
+	__le32 type;		/* see h2c_network_type */
+	struct h2c_network_configuration config;
+	__le32 mode;		/* see h2c_network_infrastruct_mode */
+	struct h2c_ext_rates rates;
+	__le32 ie_length;	/* not sure if this include fixed too */
+	struct h2c_fixed_ies ies;
+} __packed;
+
+struct c2h_survery_done_event {
+	__le32 bss_cnt;
+} __packed;
+
+enum c2h_join_network_types_t {
+	WIRELESS_INVALID	= 0,
+	WIRELESS_11B		= 1,
+	WIRELESS_11G		= 2,
+	WIRELESS_11BG		= (WIRELESS_11B | WIRELESS_11G),
+	WIRELESS_11A		= 4,
+	WIRELESS_11N		= 8,
+	WIRELESS_11GN		= (WIRELESS_11G | WIRELESS_11N),
+	WIRELESS_11BGN		= (WIRELESS_11B | WIRELESS_11G | WIRELESS_11N),
+};
+
+struct c2h_join_bss_event {
+	__le32 head;
+	__le32 tail;
+	__le32 network_type;	/* should be h2c_network_type ...*/
+	__le32 fixed;
+	__le32 last_scanned;
+	__le32 aid;
+	__le32 join_result;
+	struct h2cc2h_bss bss;
+} __packed;
+
+typedef u8 mac_rates_t[13];
+
+struct h2c_data_rates {
+	u8 mac_id;
+	mac_rates_t rates;
+} __packed;
+
+struct c2h_add_sta_event {
+	u8 mac_addr[ETH_ALEN];
+	u8 padding[2];
+	__le32 aid;
+} __packed;
+
+struct c2h_del_sta_event {
+	u8 mac_addr[ETH_ALEN];
+	u8 padding[2];
+} __packed;
+
+struct c2h_add_ba_event {
+	u8 mac_addr[ETH_ALEN];
+	__le16 ssn;
+	u8 tid;
+} __packed;
+
+enum fw_c2h_event {
+	C2H_READ_MACREG_EVENT,				/* 0 */
+	C2H_READBB_EVENT,
+	C2H_READRF_EVENT,
+	C2H_READ_EEPROM_EVENT,
+	C2H_READ_EFUSE_EVENT,
+	C2H_READ_CAM_EVENT,				/* 5 */
+	C2H_GET_BASIC_RATE_EVENT,
+	C2H_GET_DATA_RATE_EVENT,
+	C2H_SURVEY_EVENT,
+	C2H_SURVEY_DONE_EVENT,
+	C2H_JOIN_BSS_EVENT,				/* 10 */
+	C2H_ADD_STA_EVENT,
+	C2H_DEL_STA_EVENT,
+	C2H_ATIM_DONE_EVENT,
+	C2H_TX_REPORT_EVENT,
+	C2H_CCX_REPORT_EVENT,				/* 15 */
+	C2H_DTM_REPORT_EVENT,
+	C2H_TX_RATE_STATS_EVENT,
+	C2H_C2H_LBK_EVENT,
+	C2H_FWDBG_EVENT,
+	C2H_C2HFEEDBACK_EVENT,				/* 20 */
+	C2H_ADDBA_EVENT,
+	C2H_HBCN_EVENT,
+	C2H_REPORT_PWR_STATE_EVENT,
+	C2H_WPS_PBC_EVENT,
+	C2H_ADDBA_REPORT_EVENT,				/* 25 */
+
+	/* keep it last */
+	__MAX_C2H					/* 26 */
+};
+
+enum fw_h2c_cmd {
+	H2C_READ_MACREG_CMD,				/* 0 */
+	H2C_WRITE_MACREG_CMD,
+	H2C_READBB_CMD,
+	H2C_WRITEBB_CMD,
+	H2C_READRF_CMD,
+	H2C_WRITERF_CMD,				/* 5 */
+	H2C_READ_EEPROM_CMD,
+	H2C_WRITE_EEPROM_CMD,
+	H2C_READ_EFUSE_CMD,
+	H2C_WRITE_EFUSE_CMD,
+	H2C_READ_CAM_CMD,				/* 10 */
+	H2C_WRITE_CAM_CMD,
+	H2C_SETBCNITV_CMD,
+	H2C_SETMBIDCFG_CMD,
+	H2C_JOINBSS_CMD,
+	H2C_DISCONNECT_CMD,				/* 15 */
+	H2C_CREATEBSS_CMD,
+	H2C_SETOPMODE_CMD,
+	H2C_SITESURVEY_CMD,
+	H2C_SETAUTH_CMD,
+	H2C_SETKEY_CMD,					/* 20 */
+	H2C_SETSTAKEY_CMD,
+	H2C_SETASSOCSTA_CMD,
+	H2C_DELASSOCSTA_CMD,
+	H2C_SETSTAPWRSTATE_CMD,
+	H2C_SETBASICRATE_CMD,				/* 25 */
+	H2C_GETBASICRATE_CMD,
+	H2C_SETDATARATE_CMD,
+	H2C_GETDATARATE_CMD,
+	H2C_SETPHYINFO_CMD,
+	H2C_GETPHYINFO_CMD,				/* 30 */
+	H2C_SETPHY_CMD,
+	H2C_GETPHY_CMD,
+	H2C_READRSSI_CMD,
+	H2C_READGAIN_CMD,
+	H2C_SETATIM_CMD,				/* 35 */
+	H2C_SETPWRMODE_CMD,
+	H2C_JOINBSSRPT_CMD,
+	H2C_SETRATABLE_CMD,
+	H2C_GETRATABLE_CMD,
+	H2C_GETCCXREPORT_CMD,				/* 40 */
+	H2C_GETDTMREPORT_CMD,
+	H2C_GETTXRATESTATICS_CMD,
+	H2C_SETUSBSUSPEND_CMD,
+	H2C_SETH2CLBK_CMD,
+	H2C_ADDBA_REQ_CMD,				/* 45 */
+	H2C_SETCHANNEL_CMD,
+	H2C_SET_TXPOWER_CMD,
+	H2C_SWITCH_ANTENNA_CMD,
+	H2C_SET_XTAL_CAP_CMD,
+	H2C_SET_SINGLE_CARRIER_TX_CMD,			/* 50 */
+	H2C_SET_SINGLE_TONE_CMD,
+	H2C_SET_CARRIER_SUPPRESION_TX_CMD,
+	H2C_SET_CONTINOUS_TX_CMD,
+	H2C_SWITCH_BW_CMD,
+	H2C_TX_BEACON_CMD,				/* 55 */
+	H2C_SET_POWER_TRACKING_CMD,
+	H2C_AMSDU_TO_AMPDU_CMD,
+	H2C_SET_MAC_ADDRESS_CMD,
+	H2C_DISCONNECT_CTRL_CMD,
+	H2C_SET_CHANNELPLAN_CMD,			/* 60 */
+	H2C_DISCONNECT_CTRL_EX_CMD,
+	H2C_GET_H2C_LBK_CMD,
+	H2C_SET_PROBE_REQ_EXTRA_IE_CMD,
+	H2C_SET_ASSOC_REQ_EXTRA_IE_CMD,
+	H2C_SET_PROBE_RSP_EXTRA_IE_CMD,			/* 65 */
+	H2C_SET_ASSOC_RSP_EXTRA_IE_CMD,
+	H2C_GET_CURRENT_DATA_RATE_CMD,
+	H2C_GET_TX_RETRY_CNT_CMD,
+	H2C_GET_RX_RETRY_CNT_CMD,
+	H2C_GET_BCN_OK_CNT_CMD,				/* 70 */
+	H2C_GET_BCN_ERR_CNT_CMD,
+	H2C_GET_CURRENT_TXPOWER_CMD,
+	H2C_SET_DIG_CMD,
+	H2C_SET_RA_CMD,
+	H2C_SET_PT_CMD,					/* 75 */
+	H2C_READ_RSSI_CMD,
+
+	/* keep it last */
+	__MAX_H2C					/* 77 */
+};
+
+static inline void __check_h2cc2h__(void)
+{
+	BUILD_BUG_ON(sizeof(struct c2h_survery_done_event) != 4);
+	BUILD_BUG_ON(sizeof(struct c2h_del_sta_event) != 8);
+	BUILD_BUG_ON(sizeof(struct c2h_add_ba_event) != 9);
+	BUILD_BUG_ON(sizeof(struct c2h_add_sta_event) != 12);
+	BUILD_BUG_ON(sizeof(struct c2h_sta_key_event) != 8);
+
+	BUILD_BUG_ON(sizeof(struct h2c_op_mode) != 4);
+	BUILD_BUG_ON(sizeof(struct h2c_add_ba_req) != 4);
+	BUILD_BUG_ON(sizeof(struct h2c_set_channel) != 4);
+	BUILD_BUG_ON(sizeof(struct h2c_disconnect) != 4);
+	BUILD_BUG_ON(sizeof(struct h2c_antenna) != 4);
+	BUILD_BUG_ON(sizeof(struct h2c_channel_plan) != 4);
+	BUILD_BUG_ON(sizeof(struct h2c_set_mac) != 6);
+	BUILD_BUG_ON(sizeof(struct h2c_rates) != 8);
+	BUILD_BUG_ON(sizeof(struct h2c_sta_psm) != 8);
+	BUILD_BUG_ON(sizeof(struct h2c_basic_rates) != 8);
+	BUILD_BUG_ON(sizeof(struct h2c_join_bss_rpt) != 12);
+	BUILD_BUG_ON(sizeof(struct h2c_set_pwrmode) != 14);
+	BUILD_BUG_ON(sizeof(struct h2c_ext_rates) != 16);
+	BUILD_BUG_ON(sizeof(struct h2c_key) != 19);
+	BUILD_BUG_ON(sizeof(struct h2c_sta_key) != 23);
+	BUILD_BUG_ON(sizeof(struct h2c_ssid) != 36);
+	BUILD_BUG_ON(sizeof(struct h2c_site_survey) != 45);
+}
+
+#endif /* __R92SU_H2CC2H_H__ */
--- /dev/null
+++ b/drivers/net/wireless/r92su/hw.c
@@ -0,0 +1,541 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+
+#include "r92su.h"
+#include "hw.h"
+#include "reg.h"
+
+#include "usb.h"
+
+static u8 r92su_halset_sysclk(struct r92su *r92su, u16 clk_set)
+{
+	u16 clk;
+	u8 tries = 100;
+	bool result;
+
+	r92su_write16(r92su, REG_SYS_CLKR, clk_set);
+
+	/* Wait until the MAC is synchronized. */
+	udelay(400);
+
+	/* Check if it is set ready. */
+	clk = r92su_read16(r92su, REG_SYS_CLKR);
+	result = ((clk & SYS_FWHW_SEL) == (clk_set & SYS_FWHW_SEL));
+
+	if (!(clk_set & (SYS_SWHW_SEL | SYS_FWHW_SEL))) {
+		do {
+			udelay(10);
+
+			clk = r92su_read16(r92su, REG_SYS_CLKR);
+			if ((clk & SYS_SWHW_SEL))
+				return true;
+
+			wiphy_err(r92su->wdev.wiphy,
+				"wait for SYS_SWHW_SEL in %x\n", clk);
+		} while (--tries);
+		return false;
+	}
+	return result;
+}
+
+static int r92su_usb_init_b_and_c_cut(struct r92su *r92su)
+{
+	unsigned int tries = 20;
+	u8 tmpu1b;
+	u16 tmpu2b;
+
+	/* Prevent EFUSE leakage */
+	r92su_write8(r92su, REG_EFUSE_TEST + 3, 0xb0);
+	msleep(20);
+	r92su_write8(r92su, REG_EFUSE_TEST + 3, 0x30);
+
+	/* Set control path switch to HW control and reset digital core,
+	 * CPU core and MAC I/O core. */
+	tmpu2b = r92su_read16(r92su, REG_SYS_CLKR);
+	if (tmpu2b & SYS_FWHW_SEL) {
+		tmpu2b &= ~(SYS_SWHW_SEL | SYS_FWHW_SEL);
+
+		/* Set failed, return to prevent hang. */
+		if (!r92su_halset_sysclk(r92su, tmpu2b))
+			return -EIO;
+	}
+
+	/* Reset MAC-IO and CPU and Core Digital BIT(10)/11/15 */
+	tmpu1b = r92su_read8(r92su, REG_SYS_FUNC_EN + 1);
+	tmpu1b &= 0x73;
+	r92su_write8(r92su, REG_SYS_FUNC_EN + 1, tmpu1b);
+	/* wait for BIT 10/11/15 to pull high automatically!! */
+	mdelay(1);
+
+	r92su_write8(r92su, REG_SPS0_CTRL + 1, 0x53);
+	r92su_write8(r92su, REG_SPS0_CTRL, 0x57);
+
+	/* Enable AFE Macro Block's Bandgap */
+	tmpu1b = r92su_read8(r92su, REG_AFE_MISC);
+	r92su_write8(r92su, REG_AFE_MISC, (tmpu1b | AFE_BGEN));
+	mdelay(1);
+
+	/* Enable AFE Mbias */
+	tmpu1b = r92su_read8(r92su, REG_AFE_MISC);
+	r92su_write8(r92su, REG_AFE_MISC, (tmpu1b | AFE_BGEN |
+		       AFE_MBEN | AFE_MISC_I32_EN));
+	mdelay(1);
+
+	/* Enable LDOA15 block	*/
+	tmpu1b = r92su_read8(r92su, REG_LDOA15_CTRL);
+	r92su_write8(r92su, REG_LDOA15_CTRL, (tmpu1b | LDA15_EN));
+
+	/* Enable LDOV12D block */
+	tmpu1b = r92su_read8(r92su, REG_LDOV12D_CTRL);
+	r92su_write8(r92su, REG_LDOV12D_CTRL, (tmpu1b | LDV12_EN));
+
+	/* Set Digital Vdd to Retention isolation Path. */
+	tmpu2b = r92su_read16(r92su, REG_SYS_ISO_CTRL);
+	r92su_write16(r92su, REG_SYS_ISO_CTRL, (tmpu2b | ISO_PWC_DV2RP));
+
+	/* For warm reboot NIC disappear bug.
+	 * Also known as: Engineer Packet CP test Enable */
+	tmpu2b = r92su_read16(r92su, REG_SYS_FUNC_EN);
+	r92su_write16(r92su, REG_SYS_FUNC_EN, (tmpu2b | BIT(13)));
+
+	/* Support 64k IMEM */
+	tmpu1b = r92su_read8(r92su, REG_SYS_ISO_CTRL + 1);
+	r92su_write8(r92su, REG_SYS_ISO_CTRL + 1, (tmpu1b & 0x68));
+
+	/* Enable AFE clock source */
+	tmpu1b = r92su_read8(r92su, REG_AFE_XTAL_CTRL);
+	r92su_write8(r92su, REG_AFE_XTAL_CTRL, (tmpu1b | 0x01));
+	/* Delay 1.5ms */
+	mdelay(2);
+	tmpu1b = r92su_read8(r92su, REG_AFE_XTAL_CTRL + 1);
+	r92su_write8(r92su, REG_AFE_XTAL_CTRL + 1, (tmpu1b & 0xfb));
+
+	/* Enable AFE PLL Macro Block *
+	 * We need to delay 100u before enabling PLL. */
+	udelay(200);
+	tmpu1b = r92su_read8(r92su, REG_AFE_PLL_CTRL);
+	r92su_write8(r92su, REG_AFE_PLL_CTRL, (tmpu1b | BIT(0) | BIT(4)));
+
+	/* for divider reset
+	 * The clock will be stable with 500us delay after the PLL reset */
+	udelay(500);
+	r92su_write8(r92su, REG_AFE_PLL_CTRL, (tmpu1b | BIT(0) |
+		       BIT(4) | BIT(6)));
+	udelay(500);
+	r92su_write8(r92su, REG_AFE_PLL_CTRL, (tmpu1b | BIT(0) | BIT(4)));
+	udelay(500);
+
+	/* Release isolation AFE PLL & MD */
+	tmpu1b = r92su_read8(r92su, REG_SYS_ISO_CTRL);
+	r92su_write8(r92su, REG_SYS_ISO_CTRL, (tmpu1b & 0xee));
+
+	/* Switch to 40MHz clock */
+	r92su_write8(r92su, REG_SYS_CLKR, 0x00);
+
+	/* Disable CPU clock and 80MHz SSC to fix FW download timing issue */
+	tmpu1b = r92su_read8(r92su, REG_SYS_CLKR);
+	r92su_write8(r92su, REG_SYS_CLKR, (tmpu1b | 0xa0));
+
+	/* Enable MAC clock */
+	tmpu2b = r92su_read16(r92su, REG_SYS_CLKR);
+	tmpu2b |= BIT(12) | BIT(11);
+	if (!r92su_halset_sysclk(r92su, tmpu2b))
+		return -EIO;
+
+	r92su_write8(r92su, REG_PMC_FSM, 0x02);
+
+	/* Enable Core digital and enable IOREG R/W */
+	tmpu2b = r92su_read16(r92su, REG_SYS_FUNC_EN);
+	r92su_write16(r92su, REG_SYS_FUNC_EN, (tmpu2b | BIT(11)));
+
+	/* enable REG_EN */
+	tmpu2b = r92su_read16(r92su, REG_SYS_FUNC_EN);
+	r92su_write16(r92su, REG_SYS_FUNC_EN, (tmpu2b | BIT(15)));
+
+	/* Switch the control path to FW */
+	tmpu2b = r92su_read16(r92su, REG_SYS_CLKR);
+	tmpu2b |= SYS_FWHW_SEL;
+	tmpu2b &= ~SYS_SWHW_SEL;
+	if (!r92su_halset_sysclk(r92su, tmpu2b))
+		return -EIO;
+
+	r92su_write16(r92su, REG_CR, HCI_TXDMA_EN |
+		HCI_RXDMA_EN | TXDMA_EN | RXDMA_EN | FW2HW_EN |
+		DDMA_EN | MACTXEN | MACRXEN | SCHEDULE_EN |
+		BB_GLB_RSTN | BBRSTN);
+
+	/* Fix USB RX FIFO error */
+	tmpu1b = r92su_read8(r92su, REG_USB_AGG_TO);
+	r92su_write8(r92su, REG_USB_AGG_TO, tmpu1b | BIT(7));
+
+	/* Enable MAC clock */
+	tmpu2b = r92su_read16(r92su, REG_SYS_CLKR);
+	tmpu2b &= ~SYS_CPU_CLKSEL;
+	if (!r92su_halset_sysclk(r92su, tmpu2b))
+		return -EIO;
+
+	/* Fix 8051 ROM incorrect code operation */
+	r92su_write8(r92su, REG_USB_MAGIC, USB_MAGIC_BIT7);
+
+	/* To make sure that TxDMA can ready to download FW. */
+	/* We should reset TxDMA if IMEM RPT was not ready. */
+	do {
+		tmpu1b = r92su_read8(r92su, REG_TCR);
+		if ((tmpu1b & TXDMA_INIT_VALUE) == TXDMA_INIT_VALUE)
+			break;
+
+		udelay(5);
+	} while (--tries);
+
+	if (tries == 0) {
+		wiphy_err(r92su->wdev.wiphy,
+			 "Polling TXDMA_INIT_VALUE timed out! Current TCR(%#x)\n",
+			 tmpu1b);
+		tmpu1b = r92su_read8(r92su, REG_CR);
+		r92su_write8(r92su, REG_CR, tmpu1b & (~TXDMA_EN));
+		udelay(2);
+		/* Reset TxDMA */
+		r92su_write8(r92su, REG_CR, tmpu1b | TXDMA_EN);
+	}
+
+	return 0;
+}
+
+int r92su_hw_early_mac_setup(struct r92su *r92su)
+{
+	int err = -EINVAL;
+
+	/* Clear RPWM to ensure driver and fw are back in the initial state */
+	r92su_write8(r92su, REG_USB_HRPWM, 0x00);
+
+	switch (r92su->chip_rev) {
+	case R92SU_C_CUT:
+	case R92SU_B_CUT:
+		err = r92su_usb_init_b_and_c_cut(r92su);
+		if (err)
+			return err;
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int r92su_upload_finish(struct r92su *r92su)
+{
+	uint32_t cr;
+
+	/* Right here, we can set TCR/RCR to desired value */
+	/* and config MAC lookback mode to normal mode */
+
+	cr = r92su_read32(r92su, REG_TCR);
+	cr &= ~TCR_ICV;
+	r92su_write32(r92su, REG_TCR, cr);
+
+	cr = r92su_read32(r92su, REG_RCR);
+	cr |= RCR_APP_PHYST_RXFF | RCR_APP_ICV | RCR_APP_MIC;
+	r92su_write32(r92su, REG_RCR, cr);
+
+	/* Set to normal mode. */
+	r92su_write8(r92su, REG_LBKMD_SEL, LBK_NORMAL);
+	return 0;
+}
+
+static int r92su_usb_final_macconfig(struct r92su *r92su)
+{
+	u8 tmp;
+	/* Setting TX/RX page size to 128 byte */
+	tmp = r92su_read8(r92su, REG_PBP);
+	tmp |= PBP_PAGE_128B;
+	r92su_write8(r92su, REG_PBP, tmp);
+	r92su->rx_alignment = 128;
+
+	/* enable aggregation */
+	tmp = r92su_read8(r92su, REG_RXDMA_RXCTRL);
+	tmp |= RXDMA_AGG_EN;
+	r92su_write8(r92su, REG_RXDMA_RXCTRL, tmp);
+
+	/* 48 pages * 128 Byte / Page = 6kb */
+	r92su_write8(r92su, REG_RXDMA_AGG_PG_TH, 48);
+
+	/* 1.7 ms / "0x04" */
+	r92su_write8(r92su, REG_USB_DMA_AGG_TO, 0x04);
+
+	/* Fix the RX FIFO issue (USB Error) */
+	tmp = r92su_read8(r92su, REG_USB_AGG_TO);
+	tmp |= BIT(7);
+	r92su_write8(r92su, REG_USB_AGG_TO, tmp);
+	return 0;
+}
+
+static int r92su_macconfig_after_fwdownload(struct r92su *r92su)
+{
+	u32 tmp16;
+
+	/* (re-)start all queues */
+	tmp16 = r92su_read16(r92su, REG_TXPAUSE);
+	tmp16 &= ~(STOPBK | STOPBE | STOPVI | STOPVO | STOPMGT |
+		STOPHIGH | STOPHCCA | BIT(7));
+	r92su_write16(r92su, REG_TXPAUSE, tmp16);
+
+	return 0;
+}
+
+static int r92su_wps_cfg_inputmethod(struct r92su *r92su)
+{
+	u8 u1tmp;
+
+	/* The following config GPIO function */
+	r92su_write8(r92su, REG_MAC_PINMUX_CTRL, (GPIOMUX_EN | GPIOSEL_GPIO));
+	u1tmp = r92su_read8(r92su, REG_GPIO_IO_SEL);
+
+	/* config GPIO4 to input */
+	u1tmp &= ~HAL_8192S_HW_GPIO_WPS_BIT;
+	r92su_write8(r92su, REG_GPIO_IO_SEL, u1tmp);
+	return 0;
+}
+
+static bool r92su_wps_detect(struct r92su *r92su)
+{
+	u8 u1tmp;
+
+	/* The following config GPIO function */
+	r92su_write8(r92su, REG_MAC_PINMUX_CTRL, (GPIOMUX_EN | GPIOSEL_GPIO));
+	u1tmp = r92su_read8(r92su, REG_GPIO_IO_SEL);
+
+	/* config GPIO4 to input */
+	u1tmp &= ~HAL_8192S_HW_GPIO_WPS_BIT;
+	r92su_write8(r92su, REG_GPIO_IO_SEL, u1tmp);
+
+	/* On some of the platform, driver cannot read correct
+	 * value without delay between Write_GPIO_SEL and Read_GPIO_IN */
+	mdelay(10);
+
+	/* check GPIO4 */
+	u1tmp = r92su_read8(r92su, REG_GPIO_CTRL);
+	return !!(u1tmp & HAL_8192S_HW_GPIO_WPS_BIT);
+}
+
+int r92su_hw_late_mac_setup(struct r92su *r92su)
+{
+	int err = -EINVAL;
+
+	err = r92su_upload_finish(r92su);
+	if (err)
+		return err;
+
+	err = r92su_macconfig_after_fwdownload(r92su);
+	if (err)
+		return err;
+
+	err = r92su_usb_final_macconfig(r92su);
+	if (err)
+		return err;
+
+	err = r92su_wps_cfg_inputmethod(r92su);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+int r92su_hw_mac_deinit(struct r92su *r92su)
+{
+	r92su_write8(r92su, REG_RF_CTRL, 0x00);
+	/* Turn off BB */
+	msleep(20);
+
+	/* Turn off MAC */
+	r92su_write8(r92su, REG_SYS_CLKR+1, 0x38); /* Switch Control Path */
+	r92su_write8(r92su, REG_SYS_FUNC_EN+1, 0x70);
+	r92su_write8(r92su, REG_PMC_FSM, 0x06);  /* Enable Loader Data Keep */
+	r92su_write8(r92su, REG_SYS_ISO_CTRL, 0xF9); /* Isolation signals from
+						      * CORE, PLL */
+	r92su_write8(r92su, REG_SYS_ISO_CTRL+1, 0xe8); /* Enable EFUSE 1.2V */
+	r92su_write8(r92su, REG_AFE_PLL_CTRL, 0x00); /* Disable AFE PLL. */
+	r92su_write8(r92su, REG_LDOA15_CTRL, 0x54);  /* Disable A15V */
+	r92su_write8(r92su, REG_SYS_FUNC_EN+1, 0x50); /* Disable E-Fuse 1.2V */
+	r92su_write8(r92su, REG_LDOV12D_CTRL, 0x24); /* Disable LDO12(for CE) */
+	r92su_write8(r92su, REG_AFE_MISC, 0x30); /* Disable AFE BG&MB */
+	/* Option for Disable 1.6V LDO. */
+	r92su_write8(r92su, REG_SPS0_CTRL, 0x56); /* Disable 1.6V LDO */
+	r92su_write8(r92su, REG_SPS0_CTRL+1, 0x43);  /* Set SW PFM */
+	return 0;
+}
+
+int r92su_hw_mac_set_rx_filter(struct r92su *r92su,
+	bool data, bool all_mgt, bool ctrl, bool monitor)
+{
+	u32 rcr;
+
+	rcr = r92su_read32(r92su, REG_RCR);
+	if (data)
+		rcr |= RCR_ADF;
+	else
+		rcr &= ~RCR_ADF;
+	if (ctrl)
+		rcr |= RCR_ACF;
+	else
+		rcr &= ~RCR_ACF;
+
+	rcr |= RCR_AMF;
+
+	if (monitor) {
+		/* Accept all destinations and don't upload garbage ?! */
+		rcr |= RCR_AAP | RCR_CBSSID;
+	} else {
+		rcr &= ~(RCR_AAP | RCR_CBSSID);
+	}
+
+	/* Note: Playing with APPFCS can be dangerous. For example
+	 * the FCS is contained in the firmware survey_done events
+	 * BSS information (handled by "c2h_survey_event")
+	 */
+	rcr |= RCR_APPFCS | RCR_APWRMGT | /* RCR_ADD3 <== what's that? WDS? */
+	       RCR_APP_MIC | RCR_APP_ICV | /* Keep MIC & ICV */
+	       RCR_AICV | /* Accept ICV error */
+	       RCR_AB | RCR_AM  | /* Accept Broadcast, Multicast */
+	       RCR_APM | /* Accept Physical match */
+	       RCR_APP_PHYST_STAFF /* Accept PHY status */;
+
+	r92su_write32(r92su, REG_RCR, rcr);
+
+	/* A cleared bit in the rxfltmapX bitmap means that it won't
+	 * filter a individual frame type */
+	r92su_write16(r92su, REG_RXFLTMAP2, data ? 0 : 0xffff);
+	r92su_write16(r92su, REG_RXFLTMAP1, ctrl ? 0 : 0xffff);
+
+	/* changing RXFLTMAP0 affects the firmware's scan/survey ability*/
+	r92su_write16(r92su, REG_RXFLTMAP0, all_mgt ? 0 : 0x3f3f);
+	return 0;
+}
+
+void r92su_hw_queue_service_work(struct r92su *r92su)
+{
+	queue_delayed_work(system_unbound_wq, &r92su->service_work, 2 * HZ);
+}
+
+int r92su_signal_scale_mapping(u32 raw_signal)
+{
+#define QUAL(val, low_eq, high_eq, res)					\
+	do {								\
+		if (((val) >= (low_eq)) && ((val) <= (high_eq)))	\
+			return res;					\
+	} while (0)
+
+
+	/* is this some sort of scaled SNR ? */
+	QUAL(raw_signal, 51, 100, 100);
+	QUAL(raw_signal, 41, 50, 80 + (raw_signal - 40) * 2);
+	QUAL(raw_signal, 31, 40, 36 + raw_signal);
+	QUAL(raw_signal, 21, 30, 34 + raw_signal);
+	QUAL(raw_signal, 10, 20, 42 + ((raw_signal - 10) * 3) / 2);
+	QUAL(raw_signal, 5, 9, 22 + ((raw_signal - 5) * 3) / 2);
+	QUAL(raw_signal, 1, 4, 6 + ((raw_signal - 1) * 3) / 2);
+	return raw_signal;
+
+#undef QUAL
+}
+
+static void r92su_query_fw_rx_phy_status(struct r92su *r92su)
+{
+	int tries = 50;
+
+	r92su_write32(r92su, REG_IOCMD_CTRL, 0xf4000001);
+	msleep(100);
+	while ((r92su_read32(r92su, REG_IOCMD_CTRL)) && --tries)
+		msleep(20);
+
+	if (tries != 0) {
+		struct cfg80211_bss *bss;
+		int qual;
+		qual = r92su_signal_scale_mapping(
+			r92su_read32(r92su, REG_IOCMD_DATA) >> 4);
+
+		rcu_read_lock();
+		bss = rcu_dereference(r92su->connect_bss);
+		if (bss)
+			bss->signal = qual;
+		rcu_read_unlock();
+	}
+}
+
+static void r92su_hw_service_work(struct work_struct *work)
+{
+	struct r92su *r92su = container_of(work, struct r92su,
+		service_work.work);
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_initializing(r92su))
+		goto out;
+
+	if (r92su->wps_pbc) {
+		bool state = r92su_wps_detect(r92su);
+		if (r92su->wps_pbc_state != state) {
+			r92su->wps_pbc_state = state;
+			input_report_key(r92su->wps_pbc, KEY_WPS_BUTTON,
+					 state);
+			input_sync(r92su->wps_pbc);
+		}
+	}
+
+	r92su_query_fw_rx_phy_status(r92su);
+
+	r92su_hw_queue_service_work(r92su);
+out:
+	mutex_unlock(&r92su->lock);
+}
+
+void r92su_hw_init(struct r92su *r92su)
+{
+	INIT_DELAYED_WORK(&r92su->service_work, r92su_hw_service_work);
+}
+
+int r92su_hw_read_chip_version(struct r92su *r92su)
+{
+	u8 rev;
+
+	rev = GET_VAL(PCM_FSM_VER, r92su_read32(r92su, REG_PMC_FSM));
+	if (rev != R92SU_C_CUT) {
+		rev = (rev >> 1) + 1;
+		if (rev > R92SU_C_CUT) {
+			/* the vendor code will default to B_CUT
+			 * in this case. But I'm not sure what the
+			 * math above is all about. */
+			return -EINVAL;
+		}
+	}
+	r92su->chip_rev = rev;
+	return 0;
+}
--- /dev/null
+++ b/drivers/net/wireless/r92su/hw.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_MAC_H__
+#define __R92SU_MAC_H__
+
+struct r92su;
+
+void r92su_hw_init(struct r92su *r92su);
+
+int r92su_hw_read_chip_version(struct r92su *r92su);
+
+int r92su_hw_early_mac_setup(struct r92su *r92su);
+int r92su_hw_late_mac_setup(struct r92su *r92su);
+int r92su_hw_mac_deinit(struct r92su *r92su);
+bool r92su_hw_wps_detect(struct r92su *r92su);
+int r92su_hw_mac_set_rx_filter(struct r92su *r92su,
+	bool data, bool mgt, bool ctrl, bool monitor);
+void r92su_hw_queue_service_work(struct r92su *r92su);
+int r92su_signal_scale_mapping(u32 raw_signal);
+#endif /* __R92SU_MAC_H__ */
--- /dev/null
+++ b/drivers/net/wireless/r92su/main.c
@@ -0,0 +1,1392 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+#include <linux/ieee80211.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include <net/cfg80211.h>
+
+#include "r92su.h"
+#include "reg.h"
+#include "def.h"
+#include "usb.h"
+#include "cmd.h"
+#include "sta.h"
+#include "tx.h"
+#include "rx.h"
+#include "fw.h"
+#include "hw.h"
+#include "debugfs.h"
+
+#define CHAN2G(_hw_value, _freq, _flags) {	\
+	.band		= IEEE80211_BAND_2GHZ,	\
+	.center_freq	= (_freq),		\
+	.hw_value	= (_hw_value),		\
+	.flags		= (_flags),		\
+	.max_power	= 20,			\
+}
+
+#define RATE(_rate, _hw_value, _flags) {	\
+	.bitrate	= (_rate),		\
+	.hw_value	= (_hw_value),		\
+	.flags		= (_flags),		\
+}
+
+static struct ieee80211_channel r92su_channeltable[] = {
+	CHAN2G(1,  2412, 0),
+	CHAN2G(2,  2417, 0),
+	CHAN2G(3,  2422, 0),
+	CHAN2G(4,  2427, 0),
+	CHAN2G(5,  2432, 0),
+	CHAN2G(6,  2437, 0),
+	CHAN2G(7,  2442, 0),
+	CHAN2G(8,  2447, 0),
+	CHAN2G(9,  2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0),
+};
+
+static struct ieee80211_rate r92su_ratetable[] = {
+	RATE(10,  0, 0),
+	RATE(20,  1, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(55,  2, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(110, 3, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(60,  4, 0),
+	RATE(90,  5, 0),
+	RATE(120, 6, 0),
+	RATE(180, 7, 0),
+	RATE(240, 8, 0),
+	RATE(360, 9, 0),
+	RATE(480, 10, 0),
+	RATE(540, 11, 0),
+};
+
+#undef CHAN2G
+#undef RATE
+
+static const u32 r92su_chiper_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+};
+
+static const struct ieee80211_sta_ht_cap r92su_ht_info = {
+	.ht_supported = true,
+	.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
+	       IEEE80211_HT_CAP_DSSSCCK40 |
+	       IEEE80211_HT_CAP_SM_PS |
+	       IEEE80211_HT_CAP_MAX_AMSDU |
+	       (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT) |
+	       IEEE80211_HT_CAP_TX_STBC |
+	       IEEE80211_HT_CAP_SGI_40 |
+	       IEEE80211_HT_CAP_SGI_20,
+	.ampdu_factor = IEEE80211_HT_MAX_AMPDU_32K,
+	.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16,
+	.mcs = {
+		.tx_params = IEEE80211_HT_MCS_TX_DEFINED,
+		.rx_mask = { 0xff, 00, 00, 00, 0x01, 0x00, 0x00, 0x00 },
+		.rx_highest = cpu_to_le16(150),
+	},
+};
+
+static int r92su_get_station(struct wiphy *wiphy, struct net_device *ndev,
+			     u8 *mac, struct station_info *sinfo)
+{
+	struct r92su *r92su = wiphy_priv(wiphy);
+	int err = -EAGAIN;
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_connected(r92su))
+		goto out;
+
+	err = -EOPNOTSUPP;
+
+out:
+	mutex_unlock(&r92su->lock);
+	return err;
+
+}
+
+static bool r92su_parse_ht_cap_ie(struct r92su *r92su, u8 *ies, const u32 len)
+{
+	u8 *ht_cap_ie;
+
+	ht_cap_ie = r92su_find_ie(ies, len, WLAN_EID_HT_CAPABILITY);
+	if (!ht_cap_ie || ht_cap_ie[1] != sizeof(struct ieee80211_ht_cap))
+		return false;
+
+	return true;
+}
+
+static u8 *r92su_find_wmm_ie(u8 *ies, const u32 len)
+{
+	u8 *wmm_ie = ies;
+	u8 *end = ies + len;
+
+	while (wmm_ie && wmm_ie < end) {
+		wmm_ie = r92su_find_ie(wmm_ie, len, WLAN_EID_VENDOR_SPECIFIC);
+		if (wmm_ie) {
+			u8 elen = wmm_ie[1];
+			u8 *pos = &wmm_ie[2];
+
+			if (elen >= 7 &&
+			    pos[0] == 0x00 && pos[1] == 0x50 &&
+			    pos[2] == 0xf2 /* Microsoft OUI */ &&
+			    pos[3] == 0x02 &&
+			    pos[5] == 1 /* Version Check */)
+				return wmm_ie;
+
+			wmm_ie = wmm_ie + 2 + wmm_ie[1];
+		}
+
+		return NULL;
+	}
+
+	return NULL;
+}
+
+static bool r92su_add_ies(struct r92su *r92su, u8 **ie,
+			 u32 *ie_len_left, const u8 *add_ies,
+			 const u32 add_ies_len)
+{
+	if (*ie_len_left < add_ies_len)
+		return false;
+
+	*ie_len_left -= add_ies_len;
+	memcpy(*ie, add_ies, add_ies_len);
+	*ie += add_ies_len;
+	return true;
+
+}
+
+static bool r92su_add_ie(struct r92su *r92su, u8 ied, u8 **ie,
+			 u32 *ie_len_left, const u8 *add_ie,
+			 const u32 add_ie_len)
+{
+	unsigned int ie_total_len = add_ie_len + 2;
+
+	if (*ie_len_left < ie_total_len)
+		return false;
+
+	*ie_len_left -= ie_total_len;
+
+	*(*ie)++ = ied;
+	*(*ie)++ = add_ie_len;
+	memcpy(*ie, add_ie, add_ie_len);
+	*ie += add_ie_len;
+	return true;
+}
+
+static bool r92su_ht_update(struct r92su *r92su, u8 **ie, u32 *ie_len_left)
+{
+	struct ieee80211_ht_cap ht_cap = { };
+	struct ieee80211_sta_ht_cap *me_ht;
+
+	me_ht = &r92su->band_2GHZ.ht_cap;
+
+	ht_cap.cap_info = cpu_to_le16(me_ht->cap);
+	ht_cap.ampdu_params_info = ((me_ht->ampdu_density <<
+				    IEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT) &
+				    IEEE80211_HT_AMPDU_PARM_DENSITY) |
+				    (me_ht->ampdu_factor &
+				    IEEE80211_HT_AMPDU_PARM_FACTOR);
+	memcpy(&ht_cap.mcs, &r92su->band_2GHZ.ht_cap.mcs,
+	       sizeof(ht_cap.mcs));
+
+	return r92su_add_ie(r92su, WLAN_EID_HT_CAPABILITY, ie, ie_len_left,
+			    (u8 *) &ht_cap, sizeof(ht_cap));
+}
+
+static bool r92su_wmm_update(struct r92su *r92su, u8 **ie, u32 *ie_len_left)
+{
+	static const u8 wmm_ie_add[] = {
+		0x00, 0x50, 0xf2,	/* Microsoft OUI */
+		0x02,			/* Information Element */
+		0x00,
+		0x01,			/* WME Version */
+		0x00			/* WME QoS Info */
+	};
+
+	/* The firmware does something strange with the IE and
+	 * it shouldn't be changed */
+	return r92su_add_ie(r92su, WLAN_EID_VENDOR_SPECIFIC, ie, ie_len_left,
+			    wmm_ie_add, ARRAY_SIZE(wmm_ie_add));
+}
+
+static int r92su_connect_set_auth(struct r92su *r92su,
+				  struct cfg80211_connect_params *sme)
+{
+	enum r92su_auth_mode auth_mode;
+	enum r92su_auth_1x _1x;
+
+	switch (sme->auth_type) {
+	case NL80211_AUTHTYPE_AUTOMATIC:
+	case NL80211_AUTHTYPE_OPEN_SYSTEM:
+		if (sme->crypto.wpa_versions > 0) {
+			auth_mode = R92SU_AUTH_8021X;
+			/* TODO: get the right 802.1x mode */
+			_1x = R92SU_WPA_PSK;
+		} else {
+			auth_mode = R92SU_AUTH_OPEN;
+			_1x = R92SU_WPA_PSK; /* dummy */
+		}
+		break;
+
+	case NL80211_AUTHTYPE_SHARED_KEY:
+		auth_mode = R92SU_AUTH_SHARED;
+		_1x = R92SU_WPA_PSK; /* dummy */
+		break;
+
+	default:
+		wiphy_err(r92su->wdev.wiphy, "Invalid auth type %d\n",
+			  sme->auth_type);
+		return -EINVAL;
+	}
+
+	return r92su_h2c_set_auth(r92su, auth_mode, _1x);
+}
+
+static int r92su_connect_set_shared_key(struct r92su *r92su,
+					struct cfg80211_connect_params *sme)
+{
+	enum r92su_enc_alg algo;
+
+	if (!sme->key_len || !sme->key)
+		return 0;
+
+	switch (sme->key_len) {
+	case WLAN_KEY_LEN_WEP40:
+		algo = WEP40_ENCRYPTION;
+		break;
+	case WLAN_KEY_LEN_WEP104:
+		algo = WEP104_ENCRYPTION;
+		break;
+
+	default:
+		wiphy_err(r92su->wdev.wiphy, "Invalid shared key\n");
+		return -EINVAL;
+	}
+
+	return r92su_h2c_set_key(r92su, algo, sme->key_idx, true,
+				sme->key);
+}
+
+static int r92su_connect(struct wiphy *wiphy, struct net_device *ndev,
+			 struct cfg80211_connect_params *sme)
+{
+	struct r92su *r92su = wiphy_priv(wiphy);
+	struct cfg80211_bss *bss = NULL;
+	struct r92su_bss_priv *bss_priv = NULL;
+	int i, err = -EAGAIN;
+	u8 ie_buf[256];
+	u8 *ie = ie_buf;
+	u32 ie_len_left = sizeof(ie_buf);
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_open(r92su))
+		goto out;
+
+	bss = cfg80211_get_bss(wiphy, sme->channel, sme->bssid,
+			       sme->ssid, sme->ssid_len,
+			       WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
+	if (!bss) {
+		err = -ENOENT;
+		goto out;
+	}
+
+	bss_priv = r92su_get_bss_priv(bss);
+	err = r92su_connect_set_auth(r92su, sme);
+	if (err)
+		goto out;
+
+	err = r92su_connect_set_shared_key(r92su, sme);
+	if (err)
+		goto out;
+
+	for (i = 0; i < ARRAY_SIZE(bss_priv->tx_tid); i++)
+		skb_queue_head_init(&bss_priv->tx_tid[i].agg_queue);
+
+	bss_priv->control_port = sme->crypto.control_port;
+	bss_priv->control_port_ethertype = sme->crypto.control_port_ethertype;
+	bss_priv->control_port_no_encrypt = sme->crypto.control_port_no_encrypt;
+
+	WARN(!r92su_add_ies(r92su, &ie, &ie_len_left, sme->ie, sme->ie_len),
+	     "no space left for cfg80211's ies");
+
+	if (!(sme->flags & ASSOC_REQ_DISABLE_HT)) {
+		WARN(!r92su_ht_update(r92su, &ie, &ie_len_left),
+		     "no space left for ht caps ie");
+	}
+
+	WARN(!r92su_wmm_update(r92su, &ie, &ie_len_left),
+	     "no space left for wmm ie");
+
+	bss_priv->assoc_ie_len = ie - ie_buf;
+	bss_priv->assoc_ie = kmemdup(ie_buf, bss_priv->assoc_ie_len,
+				     GFP_KERNEL);
+	if (!bss_priv->assoc_ie)
+		goto out;
+
+	r92su->want_connect_bss = bss;
+	err = r92su_h2c_connect(r92su, &bss_priv->fw_bss, ie_buf, ie - ie_buf);
+	if (err)
+		goto out;
+
+out:
+	if (err) {
+		if (bss_priv)
+			kfree(bss_priv->assoc_ie);
+
+		r92su->want_connect_bss = NULL;
+	}
+
+	mutex_unlock(&r92su->lock);
+
+	if (bss)
+		cfg80211_put_bss(wiphy, bss);
+	return err;
+}
+
+static void r92su_bss_free(struct r92su *r92su, struct cfg80211_bss *bss)
+{
+	struct r92su_bss_priv *bss_priv;
+	int i;
+
+	if (!bss)
+		return;
+
+	bss_priv = r92su_get_bss_priv(bss);
+
+	for (i = 0; i < ARRAY_SIZE(bss_priv->tx_tid); i++)
+		skb_queue_purge(&bss_priv->tx_tid[i].agg_queue);
+
+	kfree(bss_priv->assoc_ie);
+
+	rcu_read_lock();
+	for (i = 0; i < ARRAY_SIZE(bss_priv->group_key); i++) {
+		struct r92su_key *key;
+		key = rcu_dereference(bss_priv->group_key[i]);
+		rcu_assign_pointer(bss_priv->group_key[i], NULL);
+		r92su_key_free(key);
+	}
+	rcu_read_unlock();
+}
+
+static int r92su_disconnect(struct wiphy *wiphy, struct net_device *ndev,
+			    u16 reason_code)
+{
+	struct r92su *r92su = wiphy_priv(wiphy);
+	struct cfg80211_bss *old_bss;
+	int err = -EAGAIN;
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_connected(r92su))
+		goto out;
+
+	err = r92su_h2c_disconnect(r92su);
+	if (err)
+		goto out;
+
+	old_bss = rcu_dereference_protected(r92su->connect_bss,
+					    lockdep_is_held(&r92su->lock));
+	rcu_assign_pointer(r92su->connect_bss, NULL);
+	r92su_bss_free(r92su, old_bss);
+
+	synchronize_rcu();
+out:
+	mutex_unlock(&r92su->lock);
+	return err;
+}
+
+/* called from irq-context */
+void r92su_disconnect_bss_event(struct r92su *r92su)
+{
+	struct cfg80211_bss *bss;
+
+	cfg80211_disconnected(r92su->wdev.netdev,
+			      WLAN_STATUS_UNSPECIFIED_FAILURE, NULL, 0,
+			      GFP_ATOMIC);
+
+	if (r92su_is_connected(r92su))
+		r92su_set_state(r92su, R92SU_OPEN);
+
+	rcu_read_lock();
+	bss = rcu_dereference(r92su->connect_bss);
+	rcu_assign_pointer(r92su->connect_bss, NULL);
+	r92su_bss_free(r92su, bss);
+	rcu_read_unlock();
+
+	netif_tx_stop_all_queues(r92su->wdev.netdev);
+	netif_carrier_off(r92su->wdev.netdev);
+}
+
+static void r92su_add_bss_work(struct work_struct *work)
+{
+	struct r92su *r92su;
+	struct llist_node *node;
+
+	r92su = container_of(work, struct r92su, add_bss_work);
+	node = llist_del_all(&r92su->add_bss_list);
+	while (node) {
+		const struct h2cc2h_bss *c2h_bss;
+		struct r92su_add_bss *bss_priv;
+		struct r92su_bss_priv *cfg_priv;
+		struct cfg80211_bss *bss;
+		int chan_idx;
+		int ie_len;
+
+		bss_priv = llist_entry(node, struct r92su_add_bss, head);
+		c2h_bss = &bss_priv->fw_bss;
+
+		chan_idx = le32_to_cpu(c2h_bss->config.frequency) - 1;
+		if (chan_idx < 0 || chan_idx >= r92su->band_2GHZ.n_channels) {
+			wiphy_err(r92su->wdev.wiphy, "received survey event on bad channel.");
+			goto next;
+		}
+
+		ie_len = le32_to_cpu(c2h_bss->ie_length) - 12;
+		if (ie_len < 0)
+			goto next;
+
+		bss = cfg80211_inform_bss(r92su->wdev.wiphy,
+			&r92su->band_2GHZ.channels[chan_idx], c2h_bss->bssid,
+			le32_to_cpu(c2h_bss->ies.timestamp),
+			le16_to_cpu(c2h_bss->ies.caps),
+			le16_to_cpu(c2h_bss->config.beacon_period),
+			c2h_bss->ies.ie, ie_len,
+			le32_to_cpu(c2h_bss->rssi), GFP_KERNEL);
+
+		cfg_priv = (void *) bss->priv;
+		memcpy(&cfg_priv->fw_bss, c2h_bss, sizeof(*c2h_bss));
+
+		if (bss)
+			cfg80211_put_bss(r92su->wdev.wiphy, bss);
+
+next:
+		node = ACCESS_ONCE(node->next);
+
+		/* these bss_priv have been generated by "c2h_survey_event"
+		 * they are not part of the cfg80211 framework and this is
+		 * why we have to managed & destroy them.
+		 */
+		kfree(bss_priv);
+	}
+}
+
+static bool r92su_parse_wmm_cap_ie(struct r92su *r92su, u8 *ies, const u32 len)
+{
+	return r92su_find_wmm_ie(ies, len) != NULL;
+}
+
+static void r92su_connect_bss_work(struct work_struct *work)
+{
+	struct r92su *r92su;
+	struct c2h_join_bss_event *join_bss = NULL;
+	struct cfg80211_bss *cfg_bss;
+	struct r92su_bss_priv *bss_priv;
+	u8 *resp_ie = NULL;
+	unsigned int resp_ie_len = 0;
+	u16 status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+
+	r92su = container_of(work, struct r92su, connect_bss_work);
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_open(r92su))
+		goto out;
+
+	cfg_bss = r92su->want_connect_bss;
+	bss_priv = r92su_get_bss_priv(cfg_bss);
+	join_bss = r92su->connect_result;
+
+	if (!cfg_bss || !join_bss)
+		goto out;
+
+	r92su->connect_result = NULL;
+
+	if (le32_to_cpu(join_bss->bss.ie_length) < 12)
+		goto report_cfg80211;
+
+	if (join_bss->join_result) {
+		struct r92su_bss_priv *bss_priv = r92su_get_bss_priv(cfg_bss);
+		struct r92su_sta *sta;
+
+		sta = r92su_sta_alloc(r92su, join_bss->bss.bssid,
+			5 /* seems like the FW has this hardcoded */,
+			GFP_KERNEL);
+		if (!sta)
+			goto report_cfg80211;
+
+		resp_ie = join_bss->bss.ies.ie;
+		resp_ie_len = le32_to_cpu(join_bss->bss.ie_length) - 12;
+
+		sta->aid = le32_to_cpu(join_bss->aid);
+		sta->enc_sta = le32_to_cpu(join_bss->bss.privacy) ?
+			       true : false;
+		sta->qos_sta = r92su_parse_wmm_cap_ie(r92su, resp_ie,
+						      resp_ie_len);
+
+		/* The 802.11-2012 spec says that a HT STA has to be QoS STA
+		 * as well. So in theory we should do instead:
+		 *	sta->qos_sta |= sta->ht_sta;
+		 * However, the QoS parameters are needed for legacy STAs as
+		 * well. Therefore, there's no excuse for a HT STA to forget
+		 * the WMM IE!
+		 */
+		if (sta->qos_sta)
+			sta->ht_sta = r92su_parse_ht_cap_ie(r92su, resp_ie,
+							    resp_ie_len);
+
+		r92su_sta_add(r92su, sta);
+		status = WLAN_STATUS_SUCCESS;
+
+		bss_priv->sta = sta;
+		rcu_assign_pointer(r92su->connect_bss, r92su->want_connect_bss);
+		r92su->want_connect_bss = NULL;
+		r92su_set_state(r92su, R92SU_CONNECTED);
+	}
+
+report_cfg80211:
+	cfg80211_connect_result(r92su->wdev.netdev, join_bss->bss.bssid,
+		bss_priv->assoc_ie, bss_priv->assoc_ie_len,
+		resp_ie, resp_ie_len, status, GFP_KERNEL);
+
+	kfree(bss_priv->assoc_ie);
+	bss_priv->assoc_ie = NULL;
+
+out:
+	mutex_unlock(&r92su->lock);
+	kfree(join_bss);
+
+	if (status == WLAN_STATUS_SUCCESS) {
+		netif_tx_start_all_queues(r92su->wdev.netdev);
+		netif_carrier_on(r92su->wdev.netdev);
+	}
+}
+
+#define R92SU_SCAN_TIMEOUT	5000
+
+static int r92su_scan(struct wiphy *wiphy, struct cfg80211_scan_request *req)
+{
+	struct r92su *r92su = wiphy_priv(wiphy);
+	int err = -EINVAL;
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_open(r92su)) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	if (r92su->scan_request) {
+		err = -EAGAIN;
+		goto out;
+	}
+
+	r92su->scan_request = req;
+	err = r92su_h2c_survey(r92su, req->n_ssids == 1 ? req->ssids : NULL);
+	if (err) {
+		r92su->scan_request = NULL;
+		goto out;
+	}
+
+	queue_delayed_work(r92su->wq, &r92su->survey_done_work,
+			   msecs_to_jiffies(R92SU_SCAN_TIMEOUT));
+
+	err = 0;
+out:
+	mutex_unlock(&r92su->lock);
+	return err;
+}
+
+static int r92su_change_virtual_intf(struct wiphy *wiphy,
+				     struct net_device *ndev,
+				     enum nl80211_iftype type, u32 *flags,
+				     struct vif_params *params)
+{
+	struct r92su *r92su = wiphy_priv(wiphy);
+	int err = -EAGAIN;
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_stopped(r92su))
+		goto out;
+
+	switch (type) {
+	case NL80211_IFTYPE_MONITOR:
+		ndev->type = ARPHRD_IEEE80211_RADIOTAP;
+		break;
+
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_ADHOC:
+		ndev->type = ARPHRD_ETHER;
+		break;
+
+	default:
+		err = -EOPNOTSUPP;
+		goto out;
+	}
+
+	if (r92su_is_open(r92su)) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	r92su->wdev.iftype = type;
+	err = 0;
+
+out:
+	mutex_unlock(&r92su->lock);
+	return err;
+}
+
+static int _r92su_set_channel(struct r92su *r92su)
+{
+	struct ieee80211_channel *chan = r92su->current_channel;
+	if (!chan)
+		return 0;
+
+	return r92su_h2c_set_channel(r92su, chan->hw_value);
+}
+
+static int r92su_set_monitor_channel(struct wiphy *wiphy,
+				     struct cfg80211_chan_def *chandef)
+{
+	struct r92su *r92su = wiphy_priv(wiphy);
+	int err = -EAGAIN;
+
+	mutex_lock(&r92su->lock);
+
+	r92su->current_channel = chandef->chan;
+
+	if (!r92su_is_open(r92su)) {
+		/* the channel can be set while the device is not up
+		 * therefore cache the new channel, until the device
+		 * goes up.
+		 */
+		err = 0;
+		goto out;
+	}
+
+	err = _r92su_set_channel(r92su);
+out:
+	mutex_unlock(&r92su->lock);
+
+	return err;
+}
+
+static int r92su_add_key(struct wiphy *wiphy, struct net_device *ndev,
+			 u8 idx, bool pairwise, const u8 *mac_addr,
+			 struct key_params *params)
+{
+	struct r92su *r92su = wiphy_priv(wiphy);
+	struct r92su_sta *sta;
+	int err = -EAGAIN;
+	struct r92su_key *new_key, *old_key = NULL;
+
+	new_key = r92su_key_alloc(params->cipher, idx, mac_addr, pairwise,
+				  params->key);
+	if (IS_ERR(new_key))
+		return PTR_ERR(new_key);
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_connected(r92su)) {
+		err = -EAGAIN;
+		goto out_unlock;
+	}
+
+	if (pairwise) {
+		err = r92su_h2c_set_sta_key(r92su, new_key->type,
+					    new_key->mac_addr,
+					    params->key);
+		if (err)
+			goto out_unlock;
+
+		rcu_read_lock();
+		sta = r92su_sta_get(r92su, mac_addr);
+		if (!sta) {
+			rcu_read_unlock();
+			err = -EINVAL;
+			goto out_unlock;
+		}
+		old_key = rcu_dereference(sta->sta_key);
+		rcu_assign_pointer(sta->sta_key, new_key);
+		rcu_read_unlock();
+	} else {
+		struct cfg80211_bss *bss;
+		struct r92su_bss_priv *bss_priv;
+		err = r92su_h2c_set_key(r92su, new_key->type,
+					new_key->index,
+					!new_key->pairwise,
+					params->key);
+		if (err)
+			goto out_unlock;
+
+		bss = rcu_dereference(r92su->connect_bss);
+		bss_priv = r92su_get_bss_priv(bss);
+		old_key = rcu_dereference(bss_priv->group_key[idx]);
+		rcu_assign_pointer(bss_priv->group_key[idx],
+				   new_key);
+	}
+
+	r92su_key_free(old_key);
+
+out_unlock:
+	mutex_unlock(&r92su->lock);
+	if (err)
+		kfree(new_key);
+	return err;
+}
+
+static int r92su_del_key(struct wiphy *wiphy, struct net_device *ndev,
+			 u8 idx, bool pairwise, const u8 *mac_addr)
+{
+	static const enum r92su_enc_alg no_key = NO_ENCRYPTION;
+	struct r92su *r92su = wiphy_priv(wiphy);
+	struct r92su_key *old_key = NULL;
+	int err = -EAGAIN;
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_connected(r92su))
+		goto out;
+
+	if (pairwise) {
+		struct r92su_sta *sta;
+		err = r92su_h2c_set_sta_key(r92su, no_key, mac_addr,
+					    NULL);
+		if (err)
+			goto out;
+
+		rcu_read_lock();
+		sta = r92su_sta_get(r92su, mac_addr);
+		if (!sta)
+			goto out_free;
+
+		old_key = rcu_dereference(sta->sta_key);
+		rcu_assign_pointer(sta->sta_key, NULL);
+	} else {
+		struct cfg80211_bss *bss;
+		struct r92su_bss_priv *bss_priv;
+		err = r92su_h2c_set_key(r92su, no_key, idx, !pairwise,
+					NULL);
+		if (err)
+			goto out;
+
+		rcu_read_lock();
+		bss = rcu_dereference(r92su->connect_bss);
+		if (bss) {
+			bss_priv = r92su_get_bss_priv(bss);
+			old_key = rcu_dereference(bss_priv->group_key[idx]);
+			rcu_assign_pointer(bss_priv->group_key[idx], NULL);
+		} else {
+			/* BSS which held the key is already gone! */
+		}
+	}
+
+out_free:
+	r92su_key_free(old_key);
+	rcu_read_unlock();
+
+out:
+	mutex_unlock(&r92su->lock);
+	return err;
+}
+
+static int r92su_set_default_key(struct wiphy *wiphy, struct net_device *ndev,
+				 u8 idx, bool unicast, bool multicast)
+{
+	struct r92su *r92su = wiphy_priv(wiphy);
+	struct cfg80211_bss *bss;
+	struct r92su_bss_priv *bss_priv;
+	int err = -EAGAIN;
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_connected(r92su))
+		goto out;
+
+	rcu_read_lock();
+	bss = rcu_dereference(r92su->connect_bss);
+	if (!bss)
+		goto out_rcu;
+
+	bss_priv = r92su_get_bss_priv(bss);
+
+	if (unicast)
+		bss_priv->def_uni_key_idx = idx;
+
+	if (multicast)
+		bss_priv->def_multi_key_idx = idx;
+
+	err = 0;
+out_rcu:
+	rcu_read_unlock();
+
+out:
+	mutex_unlock(&r92su->lock);
+	return err;
+}
+
+static int r92su_set_wiphy_params(struct wiphy *wiphy, u32 changed)
+{
+	struct r92su *r92su = wiphy_priv(wiphy);
+
+	if (changed & WIPHY_PARAM_FRAG_THRESHOLD) {
+		/* For some reason, the firmware increases the sequence
+		 * counter for fragments. This breaks the defragmentation
+		 * on the receiver because all fragments have to have the
+		 * same sequence couter.
+		 */
+		WARN_ONCE(1, "fragmentation is not supported");
+
+		/* for now, reset fragmentation threshold. However, once the
+		 * fragmentation bug get fixed, this can be removed altogether
+		 + and "everything should just work (tm)".
+		 */
+		r92su->wdev.wiphy->frag_threshold =
+			IEEE80211_MAX_FRAG_THRESHOLD;
+		return 0;
+	} else
+		return -EOPNOTSUPP;
+}
+
+static const struct cfg80211_ops r92su_cfg80211_ops = {
+	.change_virtual_intf = r92su_change_virtual_intf,
+	.set_monitor_channel = r92su_set_monitor_channel,
+
+	.get_station = r92su_get_station,
+
+	.add_key = r92su_add_key,
+	.del_key = r92su_del_key,
+	.set_default_key = r92su_set_default_key,
+
+	.scan = r92su_scan,
+	.connect = r92su_connect,
+	.disconnect = r92su_disconnect,
+
+	.set_wiphy_params = r92su_set_wiphy_params,
+};
+
+static const void *r92su_priv_id = &r92su_priv_id;
+
+static void r92su_set_rx_mode(struct net_device *ndev)
+{
+	struct r92su *r92su = ndev->ml_priv;
+
+	if (!r92su_is_open(r92su))
+		return;
+}
+
+static int r92su_init_mac(struct r92su *r92su)
+{
+	enum h2c_op_modes fw_mode;
+	int err;
+	bool data = true, all_mgmt = false, ctrl = false, mntr = false;
+
+	switch (r92su->wdev.iftype) {
+	case NL80211_IFTYPE_MONITOR:
+		all_mgmt = true;
+		ctrl = true;
+		mntr = true;
+	case NL80211_IFTYPE_UNSPECIFIED:
+		fw_mode = OP_AUTO;
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		fw_mode = OP_ADHOC;
+		break;
+	case NL80211_IFTYPE_STATION:
+		fw_mode = OP_INFRA;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	err = r92su_hw_mac_set_rx_filter(r92su, data, all_mgmt, ctrl, mntr);
+	if (err)
+		return err;
+
+	/* enable video mode, 40MHz mode and STBC
+	 * bit 8:
+	 *  1 -> enable video mode to 96B AP
+	 *  0 -> disable video mode to 96B AP
+	 *  bit 9:
+	 *  1 -> enable 40MHz mode
+	 *  0 -> disable 40MHz mode
+	 *  bit 10:
+	 *  1 -> enable STBC
+	 *  0 -> disable STBC
+	 */
+	err = r92su_fw_iocmd(r92su, 0xf4000700);
+	if (err)
+		return err;
+
+	err = r92su_h2c_set_opmode(r92su, fw_mode);
+	if (err)
+		return err;
+
+	err = r92su_h2c_set_mac_addr(r92su, r92su->wdev.netdev->dev_addr);
+	if (err)
+		return err;
+
+	err = _r92su_set_channel(r92su);
+	if (err)
+		return err;
+
+	return err;
+}
+
+static int r92su_open(struct net_device *ndev)
+{
+	struct r92su *r92su = ndev->ml_priv;
+	int err = -EAGAIN;
+
+	if (!is_valid_ether_addr(ndev->dev_addr))
+		return -EADDRNOTAVAIL;
+
+	/* Since the firmware starts sending frames as soon as its initialized,
+	 * we have to have a valid current_channel set, otherwise the rx-path
+	 * would panic
+	 */
+	r92su->current_channel =
+		&r92su->wdev.wiphy->bands[IEEE80211_BAND_2GHZ]->channels[0];
+
+	err = r92su_load_firmware(r92su);
+	if (err)
+		return err;
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_stopped(r92su)) {
+		err = -EAGAIN;
+		goto out;
+	}
+
+	err = r92su_hw_early_mac_setup(r92su);
+	if (err)
+		goto out;
+
+	err = r92su_upload_firmware(r92su);
+	if (err)
+		goto out;
+
+	err = r92su_hw_late_mac_setup(r92su);
+	if (err)
+		goto out;
+
+	err = r92su_init_mac(r92su);
+	if (err)
+		goto out;
+
+	if (!r92su_is_stopped(r92su)) {
+		err = -EAGAIN;
+		goto out;
+	}
+
+	switch (r92su->wdev.iftype) {
+	case NL80211_IFTYPE_MONITOR:
+		r92su_set_state(r92su, R92SU_CONNECTED);
+		break;
+
+	default:
+		r92su_set_state(r92su, R92SU_OPEN);
+		break;
+	}
+
+	r92su_hw_queue_service_work(r92su);
+out:
+	mutex_unlock(&r92su->lock);
+	return err;
+}
+
+static void r92su_survey_done_work(struct work_struct *work)
+{
+	struct cfg80211_scan_request *req;
+	struct r92su *r92su = container_of(work, struct r92su,
+					   survey_done_work.work);
+
+	mutex_lock(&r92su->lock);
+	if (!r92su_is_open(r92su))
+		goto out;
+
+	req = r92su->scan_request;
+	r92su->scan_request = NULL;
+
+	if (req)
+		cfg80211_scan_done(req, req->aborted);
+
+out:
+	mutex_unlock(&r92su->lock);
+}
+
+static int r92su_stop(struct net_device *ndev)
+{
+	struct r92su *r92su = ndev->ml_priv;
+	int err = -EINVAL, i;
+
+	mutex_lock(&r92su->lock);
+	if (r92su_is_initializing(r92su)) {
+		err = r92su_hw_mac_deinit(r92su);
+		if (err)
+			goto out;
+	}
+
+	if (r92su_is_initializing(r92su))
+		r92su_set_state(r92su, R92SU_STOP);
+
+	if (r92su->scan_request)
+		cfg80211_scan_done(r92su->scan_request, true);
+
+	r92su_bss_free(r92su, r92su->want_connect_bss);
+	r92su->scan_request = NULL;
+	r92su->want_connect_bss = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(r92su->sta_table); i++)
+		r92su_sta_del(r92su, i);
+out:
+	mutex_unlock(&r92su->lock);
+
+	cancel_delayed_work_sync(&r92su->survey_done_work);
+	cancel_delayed_work_sync(&r92su->service_work);
+	cancel_work_sync(&r92su->add_bss_work);
+	cancel_work_sync(&r92su->connect_bss_work);
+
+	/* wait for keys and stas to be freed */
+	synchronize_rcu();
+
+	return err;
+}
+
+static netdev_tx_t r92su_start_xmit(struct sk_buff *skb,
+				    struct net_device *ndev)
+{
+	struct r92su *r92su = ndev->ml_priv;
+	r92su_tx(r92su, skb);
+	return NETDEV_TX_OK;
+}
+
+static const struct net_device_ops r92su_netdevice_ops = {
+	.ndo_open = r92su_open,
+	.ndo_stop = r92su_stop,
+	.ndo_start_xmit = r92su_start_xmit,
+	.ndo_set_mac_address = eth_mac_addr,
+	.ndo_set_rx_mode = r92su_set_rx_mode,
+	.ndo_change_mtu = eth_change_mtu,
+	.ndo_validate_addr = eth_validate_addr,
+};
+
+static void *devm_dup(struct device *dev, void *src, size_t len)
+{
+	void *tmp;
+
+	tmp = devm_kzalloc(dev, len, GFP_KERNEL);
+	if (tmp)
+		memcpy(tmp, src, len);
+	return tmp;
+}
+
+static int r92su_init_band(struct r92su *r92su)
+{
+	struct ieee80211_supported_band *band;
+
+	band = &r92su->band_2GHZ;
+	band->channels = devm_dup(&r92su->wdev.wiphy->dev,
+		r92su_channeltable, sizeof(r92su_channeltable));
+	if (!band->channels)
+		return -ENOMEM;
+
+	band->bitrates = devm_dup(&r92su->wdev.wiphy->dev,
+		r92su_ratetable, sizeof(r92su_ratetable));
+	if (!band->bitrates)
+		return -ENOMEM;
+
+	band->n_channels = ARRAY_SIZE(r92su_channeltable);
+	band->n_bitrates = ARRAY_SIZE(r92su_ratetable);
+
+	memcpy(&band->ht_cap, &r92su_ht_info, sizeof(r92su_ht_info));
+	switch (r92su->rf_type) {
+	case R92SU_1T1R:
+		/* nothing needs to be done. The default ht_cap
+		 * contains all the necessary bits for just 1T1R
+		 * devices */
+		break;
+
+	case R92SU_1T2R:
+	case R92SU_2T2R:
+		band->ht_cap.mcs.rx_mask[1] = 0xff;
+		band->ht_cap.mcs.rx_highest = cpu_to_le16(300);
+		break;
+	}
+
+	r92su->wdev.wiphy->bands[IEEE80211_BAND_2GHZ] = &r92su->band_2GHZ;
+
+	return 0;
+}
+
+struct r92su *r92su_alloc(struct device *main_dev)
+{
+	struct r92su *r92su = NULL;
+	struct wiphy *wiphy;
+	int err;
+
+	wiphy = wiphy_new(&r92su_cfg80211_ops, sizeof(struct r92su));
+	if (!wiphy) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	r92su = wiphy_priv(wiphy);
+	r92su->wdev.wiphy = wiphy;
+	mutex_init(&r92su->lock);
+	spin_lock_init(&r92su->rx_path);
+
+	set_wiphy_dev(r92su->wdev.wiphy, main_dev);
+	r92su->wdev.iftype = NL80211_IFTYPE_STATION;
+
+	wiphy->privid = r92su_priv_id;
+	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+				 BIT(NL80211_IFTYPE_MONITOR);
+	wiphy->max_scan_ssids = 1;
+	wiphy->max_scan_ie_len = 256;
+	wiphy->signal_type = CFG80211_SIGNAL_TYPE_UNSPEC;
+	wiphy->cipher_suites = r92su_chiper_suites;
+	wiphy->n_cipher_suites = ARRAY_SIZE(r92su_chiper_suites);
+	wiphy->bss_priv_size = sizeof(struct r92su_bss_priv);
+
+	init_llist_head(&r92su->add_bss_list);
+	INIT_WORK(&r92su->add_bss_work, r92su_add_bss_work);
+	INIT_WORK(&r92su->connect_bss_work, r92su_connect_bss_work);
+	INIT_DELAYED_WORK(&r92su->survey_done_work, r92su_survey_done_work);
+	r92su_hw_init(r92su);
+
+	r92su->wq = create_singlethread_workqueue(R92SU_DRVNAME);
+	if (!r92su->wq) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	return r92su;
+
+err_out:
+	r92su_unalloc(r92su);
+	return ERR_PTR(err);
+}
+
+static void r92su_if_setup(struct net_device *ndev)
+{
+	ether_setup(ndev);
+	ndev->priv_flags &= ~IFF_TX_SKB_SHARING;
+	ndev->netdev_ops = &r92su_netdevice_ops;
+	ndev->destructor = free_netdev;
+	ndev->needed_headroom = R92SU_TX_HEAD_ROOM;
+	ndev->needed_tailroom = R92SU_TX_TAIL_ROOM;
+	ndev->flags |= IFF_BROADCAST | IFF_MULTICAST;
+	ndev->watchdog_timeo = 5 * HZ; /* USB_CTRL_TIMEOUT */
+}
+
+static int r92su_alloc_netdev(struct r92su *r92su)
+{
+	struct net_device *ndev;
+	/* The firmware/hardware does not support multiple interfaces.
+	 * So, we are fine with just a single netdevice.
+	 */
+	ndev = alloc_netdev_mqs(0, "wlan%d", r92su_if_setup, NUM_ACS, 1);
+	if (!ndev)
+		return -ENOMEM;
+
+	ndev->ml_priv = r92su;
+	r92su->wdev.netdev = ndev;
+	ndev->ieee80211_ptr = &r92su->wdev;
+	SET_NETDEV_DEV(ndev, wiphy_dev(r92su->wdev.wiphy));
+	return 0;
+}
+
+static int r92su_read_adapter_info(struct r92su *r92su)
+{
+	int err = -EINVAL;
+
+	err = r92su_hw_read_chip_version(r92su);
+	if (err)
+		return err;
+
+	err = r92su_eeprom_read(r92su);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+int r92su_setup(struct r92su *r92su)
+{
+	struct wiphy *wiphy = r92su->wdev.wiphy;
+	int err;
+
+	r92su_rx_init(r92su);
+	r92su_cmd_init(r92su);
+
+	err = r92su_read_adapter_info(r92su);
+	if (err)
+		goto err_out;
+
+	err = r92su_init_band(r92su);
+	if (err)
+		goto err_out;
+
+	err = r92su_alloc_netdev(r92su);
+	if (err)
+		goto err_out;
+
+	memcpy(wiphy->perm_addr, r92su->eeprom.mac_addr, ETH_ALEN);
+	memcpy(r92su->wdev.netdev->dev_addr, r92su->wdev.wiphy->perm_addr,
+	       ETH_ALEN);
+
+err_out:
+	return err;
+}
+
+#define ADD_REV(type)	[(R92SU_##type)] = (#type)
+static const char *rev_to_string[__R92SU_MAX_REV] = {
+	ADD_REV(FPGA),
+	ADD_REV(A_CUT),
+	ADD_REV(B_CUT),
+	ADD_REV(C_CUT),
+};
+
+static const char *rf_to_string(const enum r92su_rf_type_t type)
+{
+#define ADD_RF(type)	case R92SU_##type: return #type
+	switch (type) {
+	ADD_RF(1T1R);
+	ADD_RF(1T2R);
+	ADD_RF(2T2R);
+	default:
+		return "UNKN";
+	};
+}
+#undef ADD_REV
+
+#define NAME_LEN 32
+
+static int r92su_register_wps_button(struct r92su *r92su)
+{
+#ifdef CONFIG_R92SU_WPC
+	struct input_dev *input;
+	char *name, *phys;
+	int err;
+
+	name = devm_kzalloc(&r92su->wdev.wiphy->dev, NAME_LEN, GFP_KERNEL);
+	phys = devm_kzalloc(&r92su->wdev.wiphy->dev, NAME_LEN, GFP_KERNEL);
+
+	input = input_allocate_device();
+	if (!input || !name || !phys)
+		return -ENOMEM;
+
+	snprintf(name, NAME_LEN, "%s WPS Button",
+		 wiphy_name(r92su->wdev.wiphy));
+
+	snprintf(phys, NAME_LEN, "ieee80211/%s/input0",
+		 wiphy_name(r92su->wdev.wiphy));
+
+	input->name = name;
+	input->name = phys;
+	input->id.bustype = BUS_USB; /* SDIO */
+	input->dev.parent = &r92su->wdev.wiphy->dev;
+
+	input_set_capability(input, EV_KEY, KEY_WPS_BUTTON);
+
+	err = input_register_device(input);
+	if (err) {
+		input_free_device(input);
+		return err;
+	}
+	r92su->wps_pbc = input;
+#endif /* CONFIG_R92SU_WPC */
+
+	return 0;
+}
+
+int r92su_register(struct r92su *r92su)
+{
+	int err;
+
+	err = wiphy_register(r92su->wdev.wiphy);
+	if (err)
+		return err;
+
+	err = register_netdev(r92su->wdev.netdev);
+	if (err)
+		return err;
+
+	err = r92su_register_debugfs(r92su);
+	if (err)
+		return err;
+
+	err = r92su_register_wps_button(r92su);
+	if (err)
+		return err;
+
+	dev_info(wiphy_dev(r92su->wdev.wiphy),
+		 "Realtek RTL81XX rev %s, rf:%s is registered as '%s'.\n",
+		 rev_to_string[r92su->chip_rev],
+		 rf_to_string(r92su->rf_type),
+		 wiphy_name(r92su->wdev.wiphy));
+
+	r92su_set_state(r92su, R92SU_STOP);
+	return 0;
+}
+
+void r92su_unalloc(struct r92su *r92su)
+{
+	if (r92su) {
+		mutex_lock(&r92su->lock);
+		r92su_set_state(r92su, R92SU_UNLOAD);
+		mutex_unlock(&r92su->lock);
+
+		if (r92su->wps_pbc) {
+			input_unregister_device(r92su->wps_pbc);
+			r92su->wps_pbc = NULL;
+		}
+
+		r92su_unregister_debugfs(r92su);
+
+		if (r92su->wdev.netdev)
+			unregister_netdev(r92su->wdev.netdev);
+
+		if (r92su->wdev.wiphy->registered)
+			wiphy_unregister(r92su->wdev.wiphy);
+
+		synchronize_rcu();
+
+		destroy_workqueue(r92su->wq);
+		mutex_destroy(&r92su->lock);
+		r92su_release_firmware(r92su);
+		r92su_rx_deinit(r92su);
+		wiphy_free(r92su->wdev.wiphy);
+	}
+}
--- /dev/null
+++ b/drivers/net/wireless/r92su/michael.c
@@ -0,0 +1,86 @@
+/*
+ * Michael MIC implementation - optimized for TKIP MIC operations
+ * Copyright 2002-2003, Instant802 Networks, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/types.h>
+#include <linux/bitops.h>
+#include <linux/ieee80211.h>
+#include <asm/unaligned.h>
+
+#include "michael.h"
+
+static void michael_block(struct michael_mic_ctx *mctx, u32 val)
+{
+	mctx->l ^= val;
+	mctx->r ^= rol32(mctx->l, 17);
+	mctx->l += mctx->r;
+	mctx->r ^= ((mctx->l & 0xff00ff00) >> 8) |
+		   ((mctx->l & 0x00ff00ff) << 8);
+	mctx->l += mctx->r;
+	mctx->r ^= rol32(mctx->l, 3);
+	mctx->l += mctx->r;
+	mctx->r ^= ror32(mctx->l, 2);
+	mctx->l += mctx->r;
+}
+
+static void michael_mic_hdr(struct michael_mic_ctx *mctx, const u8 *key,
+			    struct ieee80211_hdr *hdr)
+{
+	u8 *da, *sa, tid;
+
+	da = ieee80211_get_DA(hdr);
+	sa = ieee80211_get_SA(hdr);
+	if (ieee80211_is_data_qos(hdr->frame_control))
+		tid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;
+	else
+		tid = 0;
+
+	mctx->l = get_unaligned_le32(key);
+	mctx->r = get_unaligned_le32(key + 4);
+
+	/*
+	 * A pseudo header (DA, SA, Priority, 0, 0, 0) is used in Michael MIC
+	 * calculation, but it is _not_ transmitted
+	 */
+	michael_block(mctx, get_unaligned_le32(da));
+	michael_block(mctx, get_unaligned_le16(&da[4]) |
+			    (get_unaligned_le16(sa) << 16));
+	michael_block(mctx, get_unaligned_le32(&sa[2]));
+	michael_block(mctx, tid);
+}
+
+void michael_mic(const u8 *key, struct ieee80211_hdr *hdr,
+		 const u8 *data, size_t data_len, u8 *mic)
+{
+	u32 val;
+	size_t block, blocks, left;
+	struct michael_mic_ctx mctx;
+
+	michael_mic_hdr(&mctx, key, hdr);
+
+	/* Real data */
+	blocks = data_len / 4;
+	left = data_len % 4;
+
+	for (block = 0; block < blocks; block++)
+		michael_block(&mctx, get_unaligned_le32(&data[block * 4]));
+
+	/* Partial block of 0..3 bytes and padding: 0x5a + 4..7 zeros to make
+	 * total length a multiple of 4. */
+	val = 0x5a;
+	while (left > 0) {
+		val <<= 8;
+		left--;
+		val |= data[blocks * 4 + left];
+	}
+
+	michael_block(&mctx, val);
+	michael_block(&mctx, 0);
+
+	put_unaligned_le32(mctx.l, mic);
+	put_unaligned_le32(mctx.r, mic + 4);
+}
--- /dev/null
+++ b/drivers/net/wireless/r92su/michael.h
@@ -0,0 +1,24 @@
+/*
+ * Michael MIC implementation - optimized for TKIP MIC operations
+ * Copyright 2002-2003, Instant802 Networks, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef MICHAEL_H
+#define MICHAEL_H
+
+#include <linux/types.h>
+
+#define MICHAEL_MIC_LEN 8
+
+struct michael_mic_ctx {
+	u32 l, r;
+};
+
+void michael_mic(const u8 *key, struct ieee80211_hdr *hdr,
+		 const u8 *data, size_t data_len, u8 *mic);
+
+#endif /* MICHAEL_H */
--- /dev/null
+++ b/drivers/net/wireless/r92su/r92su.h
@@ -0,0 +1,299 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_R92SU_H__
+#define __R92SU_R92SU_H__
+
+#include <linux/mii.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#include <linux/workqueue.h>
+
+#include <linux/input.h>
+#include <linux/ieee80211.h>
+#include <linux/rcupdate.h>
+#include <linux/mutex.h>
+#include <net/cfg80211.h>
+#include <linux/llist.h>
+
+#include "h2cc2h.h"
+#include "eeprom.h"
+#include "fw.h"
+#include "debugfs.h"
+#include "def.h"
+#include "sta.h"
+
+#define R92SU_DRVNAME		"r92su"
+#define RTL8192SU_FIRMWARE	"rtlwifi/rtl8712u.bin"
+
+#define R92SU_TX_HEAD_ROOM					\
+	(TX_DESC_SIZE + 4 /* HW/FW tx descriptor + align */	\
+	 + 4 * ETH_ALEN /* DA/SA/BSSID/WDS mac addrs */		\
+	 + 2 + 2 + 2 + 2 /* fc, seq, dur, qos */		\
+	 + 8 + 8 /* rfc1042/bridge + (Ext) iv */		\
+	 - ETH_HLEN /* Ethernet header gets replaced */)
+
+#define R92SU_TX_TAIL_ROOM					\
+	(8 /* TKIP & CCMP MIC */ + 4 /* ICV */)
+
+enum r92su_state_t {
+	R92SU_DEAD,	/* unresponsive */
+	R92SU_UNLOAD,	/* unalloc */
+	R92SU_PROBE,	/* when starting */
+	R92SU_STOP,	/* when stopped */
+	R92SU_INIT,	/* before ndo_open */
+	R92SU_OPEN,	/* after ndo_open */
+	R92SU_CONNECTED,/* Either connected to a AP or running an IBSS */
+};
+
+enum r92su_chip_revision_t {
+	R92SU_FPGA  = 0,
+	R92SU_A_CUT = 1,
+	R92SU_B_CUT = 2,
+	R92SU_C_CUT = 3,
+
+	__R92SU_MAX_REV
+};
+
+enum r92su_rf_type_t {
+	R92SU_1T1R = 0x11,
+	R92SU_1T2R = 0x12,
+	R92SU_2T2R = 0x22
+};
+
+enum rtl8712_queues_t {
+	RTL8712_BKQ,
+	RTL8712_BEQ,
+	RTL8712_VIQ,
+	RTL8712_VOQ,
+
+	RTL8712_H2CCMD,
+	RTL8712_BCNQ,
+	RTL8712_BMCQ,
+	RTL8712_MGTQ,
+
+	RTL8712_RX0FF,
+	RTL8712_C2HCMD,
+	__RTL8712_LAST
+};
+
+enum ieee80211_ac_numbers {
+	IEEE80211_AC_VO         = 0,
+	IEEE80211_AC_VI         = 1,
+	IEEE80211_AC_BE         = 2,
+	IEEE80211_AC_BK         = 3,
+};
+
+static const int ieee802_1d_to_ac[8] = {
+	IEEE80211_AC_BE,
+	IEEE80211_AC_BK,
+	IEEE80211_AC_BK,
+	IEEE80211_AC_BE,
+	IEEE80211_AC_VI,
+	IEEE80211_AC_VI,
+	IEEE80211_AC_VO,
+	IEEE80211_AC_VO
+};
+
+struct r92su {
+	struct usb_interface *intf;
+	struct usb_device *udev;
+	struct usb_anchor rx_submitted;
+	struct usb_anchor tx_wait;
+	struct usb_anchor tx_submitted;
+	atomic_t tx_pending_urbs;
+
+	struct mutex lock;
+	struct workqueue_struct *wq;
+
+	enum r92su_state_t state;
+
+	struct wireless_dev wdev;
+
+	struct ieee80211_channel *current_channel;
+
+	unsigned int ampdu_reference;
+
+	/* fw */
+	const struct firmware *fw;
+	const struct fw_hdr *fw_header;
+	const void *fw_imem;
+	const void *fw_sram;
+	u32 fw_imem_len;
+	u32 fw_sram_len;
+	u16 fw_version;
+	struct fw_priv fw_dmem;
+	bool fw_loaded;
+
+	struct delayed_work service_work;
+
+	/* cfg80211 info */
+	struct ieee80211_supported_band band_2GHZ;
+
+	/* scan / site survey */
+	struct cfg80211_scan_request *scan_request;
+	struct c2h_join_bss_event *connect_result;
+	struct cfg80211_bss *want_connect_bss;
+	struct cfg80211_bss __rcu *connect_bss;
+	struct work_struct connect_bss_work;
+	struct delayed_work survey_done_work;
+
+	/* cmd */
+	unsigned int h2c_seq:7;
+	unsigned int c2h_seq:7;
+	spinlock_t tx_cmd_lock;
+
+	/* eeprom / hw_info*/
+	struct r92su_eeprom eeprom;
+	enum r92su_eeprom_type eeprom_type;
+	enum r92su_chip_revision_t chip_rev;
+	enum r92su_rf_type_t rf_type;
+
+	/* debug */
+	struct dentry *dfs;
+	struct r92su_debug debug;
+
+	/* scan */
+	struct llist_head add_bss_list;
+	struct work_struct add_bss_work;
+
+	/* sta + keys */
+	struct r92su_sta __rcu *sta_table[32];
+
+	spinlock_t rx_path;
+	struct sk_buff_head rx_queue;
+	struct tasklet_struct rx_tasklet;
+	unsigned int rx_alignment;
+
+	/* wps pbc button */
+	struct input_dev *wps_pbc;
+	bool wps_pbc_state;
+};
+
+struct r92su_add_bss {
+	struct llist_node head;
+	struct h2cc2h_bss fw_bss;
+};
+
+struct r92su_tx_tid {
+	bool addba_issued;
+	struct sk_buff_head agg_queue;
+};
+
+struct r92su_bss_priv {
+	struct h2cc2h_bss fw_bss;
+	struct r92su_sta *sta;
+
+	/* only valid during connect */
+	u8 *assoc_ie;
+	unsigned int assoc_ie_len;
+
+	int def_uni_key_idx;
+	int def_multi_key_idx;
+	struct r92su_key __rcu *group_key[4];
+
+	struct r92su_tx_tid tx_tid[IEEE80211_NUM_TIDS];
+
+	__be16 control_port_ethertype;
+	bool control_port_no_encrypt;
+	bool control_port;
+};
+
+static inline bool r92su_is_probing(struct r92su *r92su)
+{
+	return r92su->state >= R92SU_PROBE;
+}
+
+static inline bool r92su_is_initializing(struct r92su *r92su)
+{
+	return r92su->state >= R92SU_INIT;
+}
+
+static inline bool r92su_is_stopped(struct r92su *r92su)
+{
+	return r92su->state == R92SU_STOP;
+}
+
+static inline bool r92su_is_open(struct r92su *r92su)
+{
+	return r92su->state >= R92SU_OPEN;
+}
+
+static inline bool r92su_is_connected(struct r92su *r92su)
+{
+	return r92su->state >= R92SU_CONNECTED;
+}
+
+static inline void r92su_set_state(struct r92su *r92su,
+				   enum r92su_state_t new_state)
+{
+	r92su->state = new_state;
+}
+
+static inline void r92su_mark_dead(struct r92su *r92su)
+{
+	r92su_set_state(r92su, R92SU_DEAD);
+}
+
+static inline
+struct r92su_bss_priv *r92su_get_bss_priv(struct cfg80211_bss *bss)
+{
+	return (struct r92su_bss_priv *) bss->priv;
+}
+
+static inline u8 *r92su_get_i3e_payload(struct ieee80211_hdr *hdr)
+{
+	return ((u8 *) hdr) + ieee80211_hdrlen(hdr->frame_control);
+}
+
+static inline unsigned int r92su_get_iv_len(struct r92su_key *key)
+{
+	switch (key->type) {
+	case WEP40_ENCRYPTION:
+	case WEP104_ENCRYPTION:
+		return 4;
+
+	case TKIP_ENCRYPTION:
+	case AESCCMP_ENCRYPTION:
+		return 8;
+
+	default:
+		return 0;
+	}
+}
+
+struct r92su *r92su_alloc(struct device *main_dev);
+int r92su_setup(struct r92su *r92su);
+int r92su_register(struct r92su *r92su);
+void r92su_unalloc(struct r92su *r92su);
+
+void r92su_disconnect_bss_event(struct r92su *r92su);
+
+#endif /* __R92SU_R92SU_H__ */
--- /dev/null
+++ b/drivers/net/wireless/r92su/reg.h
@@ -0,0 +1,835 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_REG_H__
+#define __R92SU_REG_H__
+
+/* Hardware / Firmware Memory Layout */
+#define RTL8712_IOBASE_TXPKT		(0x10200000)
+#define RTL8712_IOBASE_RXPKT		(0x10210000)
+#define RTL8712_IOBASE_RXCMD		(0x10220000)
+#define RTL8712_IOBASE_TXSTATUS		(0x10230000)
+#define RTL8712_IOBASE_RXSTATUS		(0x10240000)
+#define RTL8712_IOBASE_IOREG		(0x10250000)
+#define RTL8712_IOBASE_SCHEDULER	(0x10260000)
+
+#define RTL8712_IOBASE_TRXDMA		(0x10270000)
+#define RTL8712_IOBASE_TXLLT		(0x10280000)
+#define RTL8712_IOBASE_WMAC		(0x10290000)
+#define RTL8712_IOBASE_FW2HW		(0x102A0000)
+#define RTL8712_IOBASE_ACCESS_PHYREG	(0x102B0000)
+
+#define RTL8712_IOBASE_FF		(0x10300000)
+
+/* IOREG Offsets for 8712 and friends */
+#define RTL8712_SYSCFG_			(RTL8712_IOBASE_IOREG)
+#define RTL8712_CMDCTRL_		(RTL8712_IOBASE_IOREG + 0x40)
+#define RTL8712_MACIDSETTING_		(RTL8712_IOBASE_IOREG + 0x50)
+#define RTL8712_TIMECTRL_		(RTL8712_IOBASE_IOREG + 0x80)
+#define RTL8712_FIFOCTRL_		(RTL8712_IOBASE_IOREG + 0xA0)
+#define RTL8712_RATECTRL_		(RTL8712_IOBASE_IOREG + 0x160)
+#define RTL8712_EDCASETTING_		(RTL8712_IOBASE_IOREG + 0x1D0)
+#define RTL8712_WMAC_			(RTL8712_IOBASE_IOREG + 0x200)
+#define RTL8712_SECURITY_		(RTL8712_IOBASE_IOREG + 0x240)
+#define RTL8712_POWERSAVE_		(RTL8712_IOBASE_IOREG + 0x260)
+#define RTL8712_BB_			(RTL8712_IOBASE_IOREG + 0x2C0)
+#define RTL8712_OFFLOAD_		(RTL8712_IOBASE_IOREG + 0x2D0)
+#define RTL8712_GP_			(RTL8712_IOBASE_IOREG + 0x2E0)
+#define RTL8712_INTERRUPT_		(RTL8712_IOBASE_IOREG + 0x300)
+#define RTL8712_DEBUGCTRL_		(RTL8712_IOBASE_IOREG + 0x310)
+#define RTL8712_IOCMD_			(RTL8712_IOBASE_IOREG + 0x370)
+#define RTL8712_PHY_			(RTL8712_IOBASE_IOREG + 0x800)
+#define RTL8712_PHY_P1_			(RTL8712_IOBASE_IOREG + 0x900)
+#define RTL8712_PHY_CCK_		(RTL8712_IOBASE_IOREG + 0xA00)
+#define RTL8712_PHY_OFDM_		(RTL8712_IOBASE_IOREG + 0xC00)
+#define RTL8712_PHY_RXAGC_		(RTL8712_IOBASE_IOREG + 0xE00)
+#define RTL8712_USB_			(RTL8712_IOBASE_IOREG + 0xFE00)
+
+/* ----------------------------------------------------- */
+/* 0x10250000h ~ 0x1025003Fh System Configuration */
+/* ----------------------------------------------------- */
+#define REG_SYS_ISO_CTRL		(RTL8712_SYSCFG_ + 0x0000)
+#define		ISO_MD2PP			BIT(0)
+#define		ISO_PA2PCIE			BIT(3)
+#define		ISO_PLL2MD			BIT(4)
+#define		ISO_PWC_DV2RP			BIT(11)
+#define		ISO_PWC_RV2RP			BIT(12)
+
+#define REG_SYS_FUNC_EN			(RTL8712_SYSCFG_ + 0x0002)
+#define		FEN_CPUEN			BIT(10)
+#define		FEN_DCORE			BIT(11)
+#define		FEN_MREGEN			BIT(15)
+
+#define REG_PMC_FSM			(RTL8712_SYSCFG_ + 0x0004)
+#define		PCM_FSM_VER			0x0000f8000
+#define		PCM_FSM_VER_S			15
+
+#define REG_SYS_CLKR			(RTL8712_SYSCFG_ + 0x0008)
+#define		SYS_CLKSEL_80M			BIT(0)
+#define		SYS_PS_CLKSEL			BIT(1)
+#define		SYS_CPU_CLKSEL			BIT(2)
+#define		SYS_MAC_CLK_EN			BIT(11)
+#define		SYS_SWHW_SEL			BIT(14)
+#define		SYS_FWHW_SEL			BIT(15)
+
+#define REG_EE_9346CR			(RTL8712_SYSCFG_ + 0x000A)
+#define REG_EEPROM_CMD			(RTL8712_SYSCFG_ + 0x000A)/* DUP */
+#define		EEPROM_CMD_93C46		BIT(4)
+#define		EEPROM_CMD_AUTOLOAD_OK		BIT(5)
+
+#define REG_EE_VPD			(RTL8712_SYSCFG_ + 0x000C)
+#define REG_AFE_MISC			(RTL8712_SYSCFG_ + 0x0010)
+#define		AFE_BGEN			BIT(0)
+#define		AFE_MBEN			BIT(1)
+#define		AFE_MISC_I32_EN			BIT(3)
+
+#define REG_SPS0_CTRL			(RTL8712_SYSCFG_ + 0x0011)
+#define REG_SPS1_CTRL			(RTL8712_SYSCFG_ + 0x0018)
+#define REG_RF_CTRL			(RTL8712_SYSCFG_ + 0x001F)
+#define REG_LDOA15_CTRL			(RTL8712_SYSCFG_ + 0x0020)
+#define		LDA15_EN			BIT(0)
+
+#define REG_LDOV12D_CTRL		(RTL8712_SYSCFG_ + 0x0021)
+#define		LDV12_EN			BIT(0)
+#define		LDV12_SDBY			BIT(1)
+
+#define REG_LDOHCI12_CTRL		(RTL8712_SYSCFG_ + 0x0022)
+#define REG_LDO_USB_CTRL		(RTL8712_SYSCFG_ + 0x0023)
+#define REG_LPLDO_CTRL			(RTL8712_SYSCFG_ + 0x0024)
+#define REG_AFE_XTAL_CTRL		(RTL8712_SYSCFG_ + 0x0026)
+#define REG_AFE_PLL_CTRL		(RTL8712_SYSCFG_ + 0x0028)
+#define REG_EFUSE_CTRL			(RTL8712_SYSCFG_ + 0x0030)
+#define REG_EFUSE_TEST			(RTL8712_SYSCFG_ + 0x0034)
+#define REG_PWR_DATA			(RTL8712_SYSCFG_ + 0x0038)
+#define REG_DPS_TIMER			(RTL8712_SYSCFG_ + 0x003C)
+#define REG_RCLK_MON			(RTL8712_SYSCFG_ + 0x003E)
+#define REG_EFUSE_CLK_CTRL		(RTL8712_SYSCFG_ + 0x02F8)
+
+/* ----------------------------------------------------- */
+/* 0x10250040h ~ 0x1025004Fh Command Control */
+/* ----------------------------------------------------- */
+#define REG_CR				(RTL8712_CMDCTRL_ + 0x0000)
+#define		HCI_TXDMA_EN			BIT(2)
+#define		HCI_RXDMA_EN			BIT(3)
+#define		TXDMA_EN			BIT(4)
+#define		RXDMA_EN			BIT(5)
+#define		FW2HW_EN			BIT(6)
+#define		DDMA_EN				BIT(7)
+#define		MACTXEN				BIT(8)
+#define		MACRXEN				BIT(9)
+#define		SCHEDULE_EN			BIT(10)
+#define		BB_GLB_RSTN			BIT(12)
+#define		BBRSTN				BIT(13)
+#define		APSDOFF				BIT(14)
+#define		APSDOFF_STATUS			BIT(15)
+
+#define REG_TXPAUSE			(RTL8712_CMDCTRL_ + 0x0002)
+#define		STOPBK				BIT(0)
+#define		STOPBE				BIT(1)
+#define		STOPVI				BIT(2)
+#define		STOPVO				BIT(3)
+#define		STOPMGT				BIT(4)
+#define		STOPHIGH			BIT(5)
+#define		STOPHCCA			BIT(6)
+
+#define	REG_LBKMD_SEL			(RTL8712_CMDCTRL_ + 0x0003)
+#define		LBK_NORMAL			0x00
+#define		LBK_MAC_DLB			(BIT(0) | BIT(1))
+#define		LBK_DMA_LB			(BIT(0) | BIT(1) | BIT(2))
+#define		LBK_MAC_LB			(BIT(0) | BIT(1) | BIT(3))
+
+#define REG_TCR				(RTL8712_CMDCTRL_ + 0x0004)
+#define		IMEM_CODE_DONE			BIT(0)
+#define		IMEM_CHK_RPT			BIT(1)
+#define		EMEM_CODE_DONE			BIT(2)
+#define		EXT_IMEM_CODE_DONE		BIT(2)	/* DUP */
+#define		EMEM_CHK_RPT			BIT(3)
+#define		EXT_IMEM_CHK_RPT		BIT(3)	/* DUP */
+#define		DMEM_CODE_DONE			BIT(4)
+#define		IMEM_RDY			BIT(5)
+#define		IMEM				BIT(5)	/* DUP */
+#define		BASECHG				BIT(6)
+#define		FWRDY				BIT(7)
+#define		TSFEN				BIT(8)
+#define		TCR_TSFEN			BIT(8)  /* DUP */
+#define		TSFRST				BIT(9)
+#define		TCR_TSFRST			BIT(9)  /* DUP */
+#define		FAKE_IMEM_EN			BIT(15)
+#define		TCR_FAKE_IMEM_EN		BIT(15)  /* DUP */
+#define		TCRCRC				BIT(16)
+#define		TCR_CRC				BIT(16)  /* DUP */
+#define		CFENDFORM			BIT(17)
+#define		TCRICV				BIT(19)
+#define		TCR_ICV				BIT(19)  /* DUP */
+#define		DISCW				BIT(20)
+#define		TCR_DISCW			BIT(20)  /* DUP */
+#define		TXDMAPRE2FULL			BIT(23)
+#define		HWPC_TX_EN			BIT(24)
+#define		TCP_OFDL_EN			BIT(25)
+#define		TCR_HWPC_TX_EN			BIT(24)  /* DUP */
+#define		TCR_TCP_OFDL_EN			BIT(25)
+#define		FWALLRDY			(BIT(0) | BIT(1) | BIT(2) | \
+						BIT(3) | BIT(4) | BIT(5) | \
+						BIT(6) | BIT(7))
+#define		LOAD_FW_READY			(IMEM_CODE_DONE | \
+						IMEM_CHK_RPT | \
+						EMEM_CODE_DONE | \
+						EMEM_CHK_RPT | \
+						DMEM_CODE_DONE | \
+						IMEM_RDY | \
+						BASECHG | \
+						FWRDY)
+#define		TXDMA_INIT_VALUE		(IMEM_CHK_RPT | \
+						EXT_IMEM_CHK_RPT)
+
+#define REG_RCR				(RTL8712_CMDCTRL_ + 0x0008)
+#define		RCR_AAP				BIT(0)
+#define		RCR_APM				BIT(1)
+#define		RCR_AM				BIT(2)
+#define		RCR_AB				BIT(3)
+#define		RCR_RXSHFT_EN			BIT(4)
+#define		RCR_ACRC32			BIT(5)
+#define		RCR_APP_BA_SSN			BIT(6)
+#define		RCR_MXDMA_OFFSET		8
+#define		RCR_RXDESC_LK_EN		BIT(11)
+#define		RCR_AICV			BIT(12)
+#define		RCR_RXFTH			BIT(13)
+#define		RCR_FIFO_OFFSET			13	/* or 14? */
+#define		RCR_APP_ICV			BIT(16)
+#define		RCR_APP_MIC			BIT(17)
+#define		RCR_ADF				BIT(18)
+#define		RCR_ACF				BIT(19)
+#define		RCR_AMF				BIT(20)
+#define		RCR_ADD3			BIT(21)
+#define		RCR_APWRMGT			BIT(22)
+#define		RCR_CBSSID			BIT(23)
+#define		RCR_APP_PHYST_STAFF		BIT(24)
+#define		RCR_APP_PHYST_RXFF		BIT(25)
+#define		RCR_RX_TCPOFDL_EN		BIT(26)
+#define		RCR_ENMBID			BIT(27)
+#define		RCR_HTC_LOC_CTRL		BIT(28)
+#define		RCR_DIS_AES_2BYTE		BIT(29)
+#define		RCR_DIS_ENC_2BYTE		BIT(30)
+#define		RCR_APPFCS			BIT(31)
+
+#define REG_MSR				(RTL8712_CMDCTRL_ + 0x000C)
+#define		MSR_LINK_MASK			(MSR_LINK_NONE |	\
+						 MSR_LINK_MANAGED |	\
+						 MSR_LINK_ADHOC |	\
+						 MSR_LINK_MASTER)
+#define		MSR_LINK_NONE			0
+#define		MSR_LINK_SHIFT			0
+#define		MSR_LINK_ADHOC			BIT(0)
+#define		MSR_LINK_MANAGED		BIT(1)
+#define		MSR_LINK_MASTER			BIT(2)
+
+#define REG_SYSF_CFG			(RTL8712_CMDCTRL_ + 0x000D)
+#define REG_MBIDCTRL			(RTL8712_CMDCTRL_ + 0x000E)
+
+/* ----------------------------------------------------- */
+/* 0x10250050h ~ 0x1025007Fh MAC ID Settings */
+/* ----------------------------------------------------- */
+#define REG_MACID			(RTL8712_MACIDSETTING_ + 0x0000)
+#define REG_BSSIDR			(RTL8712_MACIDSETTING_ + 0x0008)
+#define REG_HWVID			(RTL8712_MACIDSETTING_ + 0x000E)
+#define REG_MAR				(RTL8712_MACIDSETTING_ + 0x0010)
+#define REG_MBIDCANCONTENT		(RTL8712_MACIDSETTING_ + 0x0018)
+#define REG_MBIDCANCFG			(RTL8712_MACIDSETTING_ + 0x0020)
+#define REG_BUILDTIME			(RTL8712_MACIDSETTING_ + 0x0024)
+#define REG_BUILDUSER			(RTL8712_MACIDSETTING_ + 0x0028)
+
+/* ----------------------------------------------------- */
+/* 0x10250080h ~ 0x1025009Fh Timer Control */
+/* ----------------------------------------------------- */
+#define REG_TSFTR			(RTL8712_TIMECTRL_ + 0x00)
+#define REG_USTIME			(RTL8712_TIMECTRL_ + 0x08)
+#define REG_SLOT_TIME			(RTL8712_TIMECTRL_ + 0x09)
+#define REG_TUBASE			(RTL8712_TIMECTRL_ + 0x0A)
+#define REG_SIFS_CCK			(RTL8712_TIMECTRL_ + 0x0C)
+#define REG_SIFS_OFDM			(RTL8712_TIMECTRL_ + 0x0E)
+#define REG_PIFS			(RTL8712_TIMECTRL_ + 0x10)
+#define REG_ACK_TIMEOUT			(RTL8712_TIMECTRL_ + 0x11)
+#define REG_EIFS			(RTL8712_TIMECTRL_ + 0x12)
+#define REG_BCN_INTERVAL		(RTL8712_TIMECTRL_ + 0x14)
+#define REG_ATIMWND			(RTL8712_TIMECTRL_ + 0x16)
+#define REG_DRVERLYINT			(RTL8712_TIMECTRL_ + 0x18)
+#define REG_BCNDMATIM			(RTL8712_TIMECTRL_ + 0x1A)
+#define REG_BCNERRTH			(RTL8712_TIMECTRL_ + 0x1C)
+#define REG_MLT				(RTL8712_TIMECTRL_ + 0x1D)
+
+/* ----------------------------------------------------- */
+/* 0x102500A0h ~ 0x1025015Fh FIFO Control */
+/* ----------------------------------------------------- */
+#define REG_RQPN			(RTL8712_FIFOCTRL_ + 0x00)
+#define REG_RXFF_BNDY			(RTL8712_FIFOCTRL_ + 0x0C)
+#define REG_RXRPT_BNDY			(RTL8712_FIFOCTRL_ + 0x10)
+#define REG_TXPKTBUF_PGBNDY		(RTL8712_FIFOCTRL_ + 0x14)
+#define REG_PBP				(RTL8712_FIFOCTRL_ + 0x15)
+#define		PBP_PAGE_128B			BIT(0)
+#define REG_RX_DRVINFO_SZ		(RTL8712_FIFOCTRL_ + 0x16)
+#define REG_TXFF_STATUS			(RTL8712_FIFOCTRL_ + 0x17)
+#define REG_RXFF_STATUS			(RTL8712_FIFOCTRL_ + 0x18)
+#define REG_TXFF_EMPTY_TH		(RTL8712_FIFOCTRL_ + 0x19)
+#define REG_SDIO_RX_BLKSZ		(RTL8712_FIFOCTRL_ + 0x1C)
+#define REG_RXDMA_RXCTRL		(RTL8712_FIFOCTRL_ + 0x1D)
+#define		RXDMA_AGG_EN			BIT(7)
+
+#define REG_RXPKT_NUM			(RTL8712_FIFOCTRL_ + 0x1E)
+#define REG_RXPKT_NUM_C2H		(RTL8712_FIFOCTRL_ + 0x1F)
+#define REG_C2HCMD_UDT_SIZE		(RTL8712_FIFOCTRL_ + 0x20)
+#define REG_C2HCMD_UDT_ADDR		(RTL8712_FIFOCTRL_ + 0x22)
+#define REG_FIFOPAGE2			(RTL8712_FIFOCTRL_ + 0x24)
+/* PAGE1 after PAGE2?? */
+#define REG_FIFOPAGE1			(RTL8712_FIFOCTRL_ + 0x28)
+#define REG_FW_RSVD_PG_CTRL		(RTL8712_FIFOCTRL_ + 0x30)
+#define	REG_FIFOPAGE5			(RTL8712_FIFOCTRL_ + 0x34)
+#define	REG_FW_RSVD_PG_CRTL		(RTL8712_FIFOCTRL_ + 0x38)
+#define	REG_RXDMA_AGG_PG_TH		(RTL8712_FIFOCTRL_ + 0x39)
+#define	REG_TXDESC_MSK			(RTL8712_FIFOCTRL_ + 0x3C)
+#define REG_TXRPTFF_RDPTR		(RTL8712_FIFOCTRL_ + 0x40)
+#define REG_TXRPTFF_WTPTR		(RTL8712_FIFOCTRL_ + 0x44)
+#define REG_C2HFF_RDPTR			(RTL8712_FIFOCTRL_ + 0x48)
+#define REG_C2HFF_WTPTR			(RTL8712_FIFOCTRL_ + 0x4C)
+#define REG_RXFF0_RDPTR			(RTL8712_FIFOCTRL_ + 0x50)
+#define REG_RXFF0_WTPTR			(RTL8712_FIFOCTRL_ + 0x54)
+#define REG_RXFF1_RDPTR			(RTL8712_FIFOCTRL_ + 0x58)
+#define REG_RXFF1_WTPTR			(RTL8712_FIFOCTRL_ + 0x5C)
+#define REG_RXRPT0FF_RDPTR		(RTL8712_FIFOCTRL_ + 0x60)
+#define REG_RXRPT0FF_WTPTR		(RTL8712_FIFOCTRL_ + 0x64)
+#define REG_RXRPT1FF_RDPTR		(RTL8712_FIFOCTRL_ + 0x68)
+#define REG_RXRPT1FF_WTPTR		(RTL8712_FIFOCTRL_ + 0x6C)
+#define REG_RX0PKTNUM			(RTL8712_FIFOCTRL_ + 0x72)
+#define REG_RX1PKTNUM			(RTL8712_FIFOCTRL_ + 0x74)
+#define REG_RXFLTMAP0			(RTL8712_FIFOCTRL_ + 0x76)
+#define REG_RXFLTMAP1			(RTL8712_FIFOCTRL_ + 0x78)
+#define REG_RXFLTMAP2			(RTL8712_FIFOCTRL_ + 0x7A)
+#define REG_RXFLTMAP3			(RTL8712_FIFOCTRL_ + 0x7c)
+#define REG_TBDA			(RTL8712_FIFOCTRL_ + 0x84)
+#define REG_THPDA			(RTL8712_FIFOCTRL_ + 0x88)
+#define REG_TCDA			(RTL8712_FIFOCTRL_ + 0x8C)
+#define REG_TMDA			(RTL8712_FIFOCTRL_ + 0x90)
+#define REG_HDA				(RTL8712_FIFOCTRL_ + 0x94)
+#define REG_TVODA			(RTL8712_FIFOCTRL_ + 0x98)
+#define REG_TVIDA			(RTL8712_FIFOCTRL_ + 0x9C)
+#define REG_TBEDA			(RTL8712_FIFOCTRL_ + 0xA0)
+#define REG_TBKDA			(RTL8712_FIFOCTRL_ + 0xA4)
+#define REG_RCDA			(RTL8712_FIFOCTRL_ + 0xA8)
+#define REG_RDSA			(RTL8712_FIFOCTRL_ + 0xAC)
+#define REG_TXPKT_NUM_CTRL		(RTL8712_FIFOCTRL_ + 0xB0)
+#define REG_TXQ_PGADD			(RTL8712_FIFOCTRL_ + 0xB3)
+#define REG_TXFF_PG_NUM			(RTL8712_FIFOCTRL_ + 0xB4)
+
+/* ----------------------------------------------------- */
+/* 0x10250160h ~ 0x102501CFh Adaptive Control */
+/* ----------------------------------------------------- */
+#define REG_INIMCS_SEL			(RTL8712_RATECTRL_ + 0x00)
+#define REG_INIRTSMCS_SEL		(RTL8712_RATECTRL_ + 0x20)
+#define		RRSR_RSC_OFFSET			21
+#define		RRSR_SHORT_OFFSET		23
+#define		RRSR_1M				BIT(0)
+#define		RRSR_2M				BIT(1)
+#define		RRSR_5_5M			BIT(2)
+#define		RRSR_11M			BIT(3)
+#define		RRSR_6M				BIT(4)
+#define		RRSR_9M				BIT(5)
+#define		RRSR_12M			BIT(6)
+#define		RRSR_18M			BIT(7)
+#define		RRSR_24M			BIT(8)
+#define		RRSR_36M			BIT(9)
+#define		RRSR_48M			BIT(10)
+#define		RRSR_54M			BIT(11)
+#define		RRSR_MCS0			BIT(12)
+#define		RRSR_MCS1			BIT(13)
+#define		RRSR_MCS2			BIT(14)
+#define		RRSR_MCS3			BIT(15)
+#define		RRSR_MCS4			BIT(16)
+#define		RRSR_MCS5			BIT(17)
+#define		RRSR_MCS6			BIT(18)
+#define		RRSR_MCS7			BIT(19)
+#define		BRSR_ACKSHORTPMB		BIT(23)
+#define		RATR_1M				0x00000001
+#define		RATR_2M				0x00000002
+#define		RATR_55M			0x00000004
+#define		RATR_11M			0x00000008
+#define		RATR_6M				0x00000010
+#define		RATR_9M				0x00000020
+#define		RATR_12M			0x00000040
+#define		RATR_18M			0x00000080
+#define		RATR_24M			0x00000100
+#define		RATR_36M			0x00000200
+#define		RATR_48M			0x00000400
+#define		RATR_54M			0x00000800
+#define		RATR_MCS0			0x00001000
+#define		RATR_MCS1			0x00002000
+#define		RATR_MCS2			0x00004000
+#define		RATR_MCS3			0x00008000
+#define		RATR_MCS4			0x00010000
+#define		RATR_MCS5			0x00020000
+#define		RATR_MCS6			0x00040000
+#define		RATR_MCS7			0x00080000
+#define		RATR_MCS8			0x00100000
+#define		RATR_MCS9			0x00200000
+#define		RATR_MCS10			0x00400000
+#define		RATR_MCS11			0x00800000
+#define		RATR_MCS12			0x01000000
+#define		RATR_MCS13			0x02000000
+#define		RATR_MCS14			0x04000000
+#define		RATR_MCS15			0x08000000
+#define		RATE_ALL_CCK			(RATR_1M | RATR_2M | \
+						RATR_55M | RATR_11M)
+#define		RATE_ALL_OFDM_AG		(RATR_6M | RATR_9M | \
+						RATR_12M | RATR_18M | \
+						RATR_24M | RATR_36M | \
+						RATR_48M | RATR_54M)
+#define		RATE_ALL_OFDM_1SS		(RATR_MCS0 | RATR_MCS1 | \
+						RATR_MCS2 | RATR_MCS3 | \
+						RATR_MCS4 | RATR_MCS5 | \
+						RATR_MCS6 | RATR_MCS7)
+#define		RATE_ALL_OFDM_2SS		(RATR_MCS8 | RATR_MCS9 | \
+						RATR_MCS10 | RATR_MCS11 | \
+						RATR_MCS12 | RATR_MCS13 | \
+						RATR_MCS14 | RATR_MCS15)
+#define REG_RRSR			(RTL8712_RATECTRL_ + 0x21)
+/* that's a bit weird, why not use BIT(28)? */
+#define		RRSR_RSC_LOWSUBCHNL		0x00200000
+#define		RRSR_RSC_UPSUBCHNL		0x00400000
+#define		RRSR_RSC_BW_40M			0x00600000
+#define		RRSR_SHORT			0x00800000
+
+#define REG_ARFR0			(RTL8712_RATECTRL_ + 0x24)
+#define REG_ARFR1			(RTL8712_RATECTRL_ + 0x28)
+#define REG_ARFR2			(RTL8712_RATECTRL_ + 0x2C)
+#define REG_ARFR3			(RTL8712_RATECTRL_ + 0x30)
+#define REG_ARFR4			(RTL8712_RATECTRL_ + 0x34)
+#define REG_ARFR5			(RTL8712_RATECTRL_ + 0x38)
+#define REG_ARFR6			(RTL8712_RATECTRL_ + 0x3C)
+#define REG_ARFR7			(RTL8712_RATECTRL_ + 0x40)
+#define REG_AGGLEN_LMT_H		(RTL8712_RATECTRL_ + 0x47)
+#define REG_AGGLEN_LMT_L		(RTL8712_RATECTRL_ + 0x48)
+#define REG_DARFRC			(RTL8712_RATECTRL_ + 0x50)
+#define REG_RARFRC			(RTL8712_RATECTRL_ + 0x58)
+#define REG_MCS_TXAGC0			(RTL8712_RATECTRL_ + 0x60)
+#define REG_MCS_TXAGC1			(RTL8712_RATECTRL_ + 0x61)
+#define REG_MCS_TXAGC2			(RTL8712_RATECTRL_ + 0x62)
+#define REG_MCS_TXAGC3			(RTL8712_RATECTRL_ + 0x63)
+#define REG_MCS_TXAGC4			(RTL8712_RATECTRL_ + 0x64)
+#define REG_MCS_TXAGC5			(RTL8712_RATECTRL_ + 0x65)
+#define REG_MCS_TXAGC6			(RTL8712_RATECTRL_ + 0x66)
+#define REG_MCS_TXAGC7			(RTL8712_RATECTRL_ + 0x67)
+#define REG_CCK_TXAGC			(RTL8712_RATECTRL_ + 0x68)
+
+/* ----------------------------------------------------- */
+/* 0x102501D0h ~ 0x102501FFh EDCA Configuration */
+/* ----------------------------------------------------- */
+#define REG_EDCA_VO_PARAM		(RTL8712_EDCASETTING_ + 0x00)
+#define REG_EDCA_VI_PARAM		(RTL8712_EDCASETTING_ + 0x04)
+#define REG_EDCA_BE_PARAM		(RTL8712_EDCASETTING_ + 0x08)
+#define REG_EDCA_BK_PARAM		(RTL8712_EDCASETTING_ + 0x0C)
+#define REG_BCNTCFG			(RTL8712_EDCASETTING_ + 0x10)
+#define REG_CWRR			(RTL8712_EDCASETTING_ + 0x12)
+#define REG_ACMAVG			(RTL8712_EDCASETTING_ + 0x16)
+#define REG_ACMHWCTRL			(RTL8712_EDCASETTING_ + 0x17)
+#define		ACMHW_HWEN			BIT(0)
+#define		ACMHW_BEQEN			BIT(1)
+#define		ACMHW_VIQEN			BIT(2)
+#define		ACMHW_VOQEN			BIT(3)
+#define		ACMHW_BEQSTATUS			BIT(4)
+#define		ACMHW_VIQSTATUS			BIT(5)
+#define		ACMHW_VOQSTATUS			BIT(6)
+
+#define REG_VO_ADMTIME			(RTL8712_EDCASETTING_ + 0x18)
+#define REG_VI_ADMTIME			(RTL8712_EDCASETTING_ + 0x1C)
+#define REG_BE_ADMTIME			(RTL8712_EDCASETTING_ + 0x20)
+#define REG_RETRY_LIMIT			(RTL8712_EDCASETTING_ + 0x24)
+#define		RETRY_LIMIT_SHORT_SHIFT		8
+#define		RETRY_LIMIT_LONG_SHIFT		0
+
+#define	REG_SG_RATE			(RTL8712_EDCASETTING_ + 0x26)
+
+/* ----------------------------------------------------- */
+/* 0x10250200h ~ 0x1025023Fh Wireless MAC */
+/* ----------------------------------------------------- */
+#define REG_NAVCTRL			(RTL8712_WMAC_ + 0x00)
+#define		NAV_UPPER_EN			BIT(16)
+#define		NAV_UPPER			0xFF00
+#define		NAV_RTSRST			0xFF
+
+#define REG_BWOPMODE			(RTL8712_WMAC_ + 0x03)
+#define		BW_OPMODE_11J			BIT(0)
+#define		BW_OPMODE_5G			BIT(1)
+#define		BW_OPMODE_20MHZ			BIT(2)
+
+#define REG_BACAMCMD			(RTL8712_WMAC_ + 0x04)
+#define REG_BACAMCONTENT		(RTL8712_WMAC_ + 0x08)
+#define REG_LBDLY			(RTL8712_WMAC_ + 0x10)
+#define REG_FWDLY			(RTL8712_WMAC_ + 0x11)
+#define REG_HWPC_RX_CTRL		(RTL8712_WMAC_ + 0x18)
+#define REG_MQ				(RTL8712_WMAC_ + 0x20)
+#define REG_MA				(RTL8712_WMAC_ + 0x22)
+#define REG_MS				(RTL8712_WMAC_ + 0x24)
+#define REG_CLM_RESULT			(RTL8712_WMAC_ + 0x27)
+#define REG_NHM_RPI_CNT			(RTL8712_WMAC_ + 0x28)
+#define REG_RXERR_RPT			(RTL8712_WMAC_ + 0x30)
+#define REG_NAV_PROT_LEN		(RTL8712_WMAC_ + 0x34)
+#define REG_CFEND_TH			(RTL8712_WMAC_ + 0x36)
+#define REG_AMPDU_MIN_SPACE		(RTL8712_WMAC_ + 0x37)
+#define		MAX_MSS_OFFSET			3
+#define		MAX_MSS_DENSITY_2T		0x13
+#define		MAX_MSS_DENSITY_1T		0x0A
+#define	REG_TXOP_STALL_CTRL		(RTL8712_WMAC_ + 0x38)
+
+/* ----------------------------------------------------- */
+/* 0x10250240h ~ 0x1025025Fh CAM / Security Engine */
+/* ----------------------------------------------------- */
+#define	REG_RWCAM			(RTL8712_SECURITY_ + 0x00)
+#define	REG_WCAMI			(RTL8712_SECURITY_ + 0x04)
+#define	REG_RCAMO			(RTL8712_SECURITY_ + 0x08)
+#define	REG_CAMDBG			(RTL8712_SECURITY_ + 0x0C)
+#define	REG_SECR			(RTL8712_SECURITY_ + 0x10)
+#define		SCR_TXUSEDK			BIT(0)
+#define		SCR_RXUSEDK			BIT(1)
+#define		SCR_TXENCENABLE			BIT(2)
+#define		SCR_RXENCENABLE			BIT(3)
+#define		SCR_SKBYA2			BIT(4)
+#define		SCR_NOSKMC			BIT(5)
+
+/* ----------------------------------------------------- */
+/* 0x10250260h ~ 0x102502BFh Powersave Control */
+/* ----------------------------------------------------- */
+#define REG_WOWCTRL			(RTL8712_POWERSAVE_ + 0x00)
+#define REG_PSSTATUS			(RTL8712_POWERSAVE_ + 0x01)
+#define REG_PSSWITCH			(RTL8712_POWERSAVE_ + 0x02)
+#define REG_MIMOPS_WAITPERIOD		(RTL8712_POWERSAVE_ + 0x03)
+#define REG_LPNAV_CTRL			(RTL8712_POWERSAVE_ + 0x04)
+#define REG_WFM0			(RTL8712_POWERSAVE_ + 0x10)
+#define REG_WFM1			(RTL8712_POWERSAVE_ + 0x20)
+#define REG_WFM2			(RTL8712_POWERSAVE_ + 0x30)
+#define REG_WFM3			(RTL8712_POWERSAVE_ + 0x40)
+#define REG_WFM4			(RTL8712_POWERSAVE_ + 0x50)
+#define REG_WFM5			(RTL8712_POWERSAVE_ + 0x60)
+#define REG_WFCRC			(RTL8712_POWERSAVE_ + 0x70)
+#define REG_RPWM			(RTL8712_POWERSAVE_ + 0x7C)
+#define REG_CPWM			(RTL8712_POWERSAVE_ + 0x7D)
+
+/* ----------------------------------------------------- */
+/* 0x102502C0h ~ 0x102502CFh Base Band Control */
+/* ----------------------------------------------------- */
+#define REG_RF_BB_CMD_ADDR		(RTL8712_BB_ + 0x00)
+#define REG_RF_BB_CMD_DATA		(RTL8712_BB_ + 0x04)
+
+/* ----------------------------------------------------- */
+/* 0x102502D0h ~ 0x102502DFh Offload Control */
+/* ----------------------------------------------------- */
+
+/* ----------------------------------------------------- */
+/* 0x102502E0h ~ 0x102502FFh GPIO */
+/* ----------------------------------------------------- */
+#define REG_PSTIMER			(RTL8712_GP_ + 0x00)
+#define REG_TIMER1			(RTL8712_GP_ + 0x04)
+#define REG_TIMER2			(RTL8712_GP_ + 0x08)
+#define REG_GPIO_CTRL			(RTL8712_GP_ + 0x0C)
+#define		HAL_8192S_HW_GPIO_OFF_BIT	BIT(3)
+#define		HAL_8192S_HW_GPIO_WPS_BIT	BIT(4)
+
+#define REG_GPIO_IO_SEL			(RTL8712_GP_ + 0x0E)
+#define		GPIOSEL_PHYDBG			1
+#define		GPIOSEL_BT			2
+#define		GPIOSEL_WLANDBG			3
+#define		GPIOSEL_GPIO_MASK		(~(BIT(0)|BIT(1)))
+
+#define REG_GPIO_INTCTRL		(RTL8712_GP_ + 0x10)
+#define REG_MAC_PINMUX_CTRL		(RTL8712_GP_ + 0x11)
+#define		GPIOSEL_GPIO			0
+#define		GPIOMUX_EN			BIT(3)
+
+#define REG_LEDCFG			(RTL8712_GP_ + 0x12)
+#define REG_PHY_REG_RPT			(RTL8712_GP_ + 0x13)
+#define REG_PHY_REG_DATA		(RTL8712_GP_ + 0x14)
+#define REG_EFUSE_CLK			(RTL8712_GP_ + 0x18)
+
+/* ----------------------------------------------------- */
+/* 0x10250300h ~ 0x1025030Fh Interrupt Controller */
+/* ----------------------------------------------------- */
+#define REG_HIMR			(RTL8712_INTERRUPT_ + 0x08)
+
+/* ----------------------------------------------------- */
+/* 0x10250310h ~ 0x1025035Fh Debug */
+/* ----------------------------------------------------- */
+#define REG_BIST			(RTL8712_DEBUGCTRL_ + 0x00)
+#define REG_DBS				(RTL8712_DEBUGCTRL_ + 0x04)
+#define REG_LMS				(RTL8712_DEBUGCTRL_ + 0x05)
+#define REG_CPUINST			(RTL8712_DEBUGCTRL_ + 0x08)
+#define REG_CPUCAUSE			(RTL8712_DEBUGCTRL_ + 0x0C)
+#define REG_LBUS_ERR_ADDR		(RTL8712_DEBUGCTRL_ + 0x10)
+#define REG_LBUS_ERR_CMD		(RTL8712_DEBUGCTRL_ + 0x14)
+#define REG_LBUS_ERR_DATA_L		(RTL8712_DEBUGCTRL_ + 0x18)
+#define REG_LBUS_ERR_DATA_H		(RTL8712_DEBUGCTRL_ + 0x1C)
+#define REG_LBUS_EXCEPTION_ADDR		(RTL8712_DEBUGCTRL_ + 0x20)
+#define REG_WDG_CTRL			(RTL8712_DEBUGCTRL_ + 0x24)
+#define REG_INTMTU			(RTL8712_DEBUGCTRL_ + 0x28)
+#define REG_INTM			(RTL8712_DEBUGCTRL_ + 0x2A)
+#define REG_FDLOCKTURN0			(RTL8712_DEBUGCTRL_ + 0x2C)
+#define REG_FDLOCKTURN1			(RTL8712_DEBUGCTRL_ + 0x2D)
+#define REG_FDLOCKFLAG0			(RTL8712_DEBUGCTRL_ + 0x2E)
+#define REG_FDLOCKFLAG1			(RTL8712_DEBUGCTRL_ + 0x2F)
+#define REG_TRXPKTBUF_DBG_DATA		(RTL8712_DEBUGCTRL_ + 0x30)
+#define REG_TRXPKTBUF_DBG_CTRL		(RTL8712_DEBUGCTRL_ + 0x38)
+#define REG_DPLL_MON			(RTL8712_DEBUGCTRL_ + 0x3A)
+
+/* ----------------------------------------------------- */
+/* 0x10250310h ~ 0x1025035Fh IO Command Control */
+/* ----------------------------------------------------- */
+#define REG_IOCMD_CTRL			(RTL8712_IOCMD_ + 0x00)
+#define REG_IOCMD_DATA			(RTL8712_IOCMD_ + 0x04)
+
+/* ----------------------------------------------------- */
+/* 0x10250800 ~ 0x10250DFF PHY */
+/* ----------------------------------------------------- */
+#define REG_RFPGA0_RFMOD		(RTL8712_PHY_ + 0x00)
+#define REG_RFPGA0_TXINFO		(RTL8712_PHY_ + 0x04)
+#define REG_RFPGA0_PSDFUNCTION		(RTL8712_PHY_ + 0x08)
+#define REG_RFPGA0_TXGAINSTAGE		(RTL8712_PHY_ + 0x0C)
+#define REG_RFPGA0_RFTIMING1		(RTL8712_PHY_ + 0x10)
+#define REG_RFPGA0_RFTIMING2		(RTL8712_PHY_ + 0x14)
+#define REG_RFPGA0_XA_HSSIPARAMETER1	(RTL8712_PHY_ + 0x20)
+#define REG_RFPGA0_XA_HSSIPARAMETER2	(RTL8712_PHY_ + 0x24)
+#define REG_RFPGA0_XB_HSSIPARAMETER1	(RTL8712_PHY_ + 0x28)
+#define REG_RFPGA0_XB_HSSIPARAMETER2	(RTL8712_PHY_ + 0x2C)
+#define REG_RFPGA0_XC_HSSIPARAMETER1	(RTL8712_PHY_ + 0x30)
+#define REG_RFPGA0_XC_HSSIPARAMETER2	(RTL8712_PHY_ + 0x34)
+#define REG_RFPGA0_XD_HSSIPARAMETER1	(RTL8712_PHY_ + 0x38)
+#define REG_RFPGA0_XD_HSSIPARAMETER2	(RTL8712_PHY_ + 0x3C)
+#define REG_RFPGA0_XA_LSSIPARAMETER	(RTL8712_PHY_ + 0x40)
+#define REG_RFPGA0_XB_LSSIPARAMETER	(RTL8712_PHY_ + 0x44)
+#define REG_RFPGA0_XC_LSSIPARAMETER	(RTL8712_PHY_ + 0x48)
+#define REG_RFPGA0_XD_LSSIPARAMETER	(RTL8712_PHY_ + 0x4C)
+#define REG_RFPGA0_RFWAKEUP_PARAMETER	(RTL8712_PHY_ + 0x50)
+#define REG_RFPGA0_RFSLEEPUP_PARAMETER	(RTL8712_PHY_ + 0x54)
+#define REG_RFPGA0_XAB_SWITCHCONTROL	(RTL8712_PHY_ + 0x58)
+#define REG_RFPGA0_XCD_SWITCHCONTROL	(RTL8712_PHY_ + 0x5C)
+#define REG_RFPGA0_XA_RFINTERFACEOE	(RTL8712_PHY_ + 0x60)
+#define REG_RFPGA0_XB_RFINTERFACEOE	(RTL8712_PHY_ + 0x64)
+#define REG_RFPGA0_XC_RFINTERFACEOE	(RTL8712_PHY_ + 0x68)
+#define REG_RFPGA0_XD_RFINTERFACEOE	(RTL8712_PHY_ + 0x6C)
+#define REG_RFPGA0_XAB_RFINTERFACESW	(RTL8712_PHY_ + 0x70)
+#define REG_RFPGA0_XCD_RFINTERFACESW	(RTL8712_PHY_ + 0x74)
+#define REG_RFPGA0_XAB_RFPARAMETER	(RTL8712_PHY_ + 0x78)
+#define REG_RFPGA0_XCD_RFPARAMETER	(RTL8712_PHY_ + 0x7C)
+#define REG_RFPGA0_ANALOGPARAMETER1	(RTL8712_PHY_ + 0x80)
+#define REG_RFPGA0_ANALOGPARAMETER2	(RTL8712_PHY_ + 0x84)
+#define REG_RFPGA0_ANALOGPARAMETER3	(RTL8712_PHY_ + 0x88)
+#define REG_RFPGA0_ANALOGPARAMETER4	(RTL8712_PHY_ + 0x8C)
+#define REG_RFPGA0_XA_LSSIREADBACK	(RTL8712_PHY_ + 0xa0)
+#define REG_RFPGA0_XB_LSSIREADBACK	(RTL8712_PHY_ + 0xA4)
+#define REG_RFPGA0_XC_LSSIREADBACK	(RTL8712_PHY_ + 0xA8)
+#define REG_RFPGA0_XD_LSSIREADBACK	(RTL8712_PHY_ + 0xAC)
+#define REG_RFPGA0_PSDREPORT		(RTL8712_PHY_ + 0xB4)
+#define REG_TRANSCEIVERA_HSPI_READBACK	(RTL8712_PHY_ + 0xB8)
+#define REG_TRANSCEIVERB_HSPI_READBACK	(RTL8712_PHY_ + 0xBC)
+#define REG_RFPGA0_XAB_RFINTERFACERB	(RTL8712_PHY_ + 0xE0)
+#define REG_RFPGA0_XCD_RFINTERFACERB	(RTL8712_PHY_ + 0xE4)
+
+/* ----------------------------------------------------- */
+/* 0x10250900 ~ 0x102509FF PHY Page 9*/
+/* ----------------------------------------------------- */
+#define REG_RFPGA1_RFMOD		(RTL8712_PHY_P1_ + 0x00)
+#define REG_RFPGA1_TXBLOCK		(RTL8712_PHY_P1_ + 0x04)
+#define REG_RFPGA1_DEBUGSELECT		(RTL8712_PHY_P1_ + 0x08)
+#define REG_RFPGA1_TXINFO		(RTL8712_PHY_P1_ + 0x0C)
+
+/* ----------------------------------------------------- */
+/* 0x10250A00 ~ 0x10250AFF PHY CCK */
+/* ----------------------------------------------------- */
+#define REG_RCCK0_SYSTEM		(RTL8712_PHY_CCK_ + 0x00)
+#define REG_RCCK0_AFESETTING		(RTL8712_PHY_CCK_ + 0x04)
+#define REG_RCCK0_CCA			(RTL8712_PHY_CCK_ + 0x08)
+#define REG_RCCK0_RXAGC1		(RTL8712_PHY_CCK_ + 0x0C)
+#define REG_RCCK0_RXAGC2		(RTL8712_PHY_CCK_ + 0x10)
+#define REG_RCCK0_RXHP			(RTL8712_PHY_CCK_ + 0x14)
+#define REG_RCCK0_DSPPARAMETER1		(RTL8712_PHY_CCK_ + 0x18)
+#define REG_RCCK0_DSPPARAMETER2		(RTL8712_PHY_CCK_ + 0x1C)
+#define REG_RCCK0_TXFILTER1		(RTL8712_PHY_CCK_ + 0x20)
+#define REG_RCCK0_TXFILTER2		(RTL8712_PHY_CCK_ + 0x24)
+#define REG_RCCK0_DEBUGPORT		(RTL8712_PHY_CCK_ + 0x28)
+#define REG_RCCK0_FALSEALARMREPORT	(RTL8712_PHY_CCK_ + 0x2C)
+#define REG_RCCK0_TRSSIREPORT		(RTL8712_PHY_CCK_ + 0x50)
+#define REG_RCCK0_RXREPORT		(RTL8712_PHY_CCK_ + 0x54)
+#define REG_RCCK0_FACOUNTERLOWER	(RTL8712_PHY_CCK_ + 0x5C)
+#define REG_RCCK0_FACOUNTERUPPER	(RTL8712_PHY_CCK_ + 0x58)
+
+/* ----------------------------------------------------- */
+/* 0x10250C00 ~ 0x10250DFF PHY OFDM */
+/* ----------------------------------------------------- */
+#define REG_ROFDM0_LSTF			(RTL8712_PHY_OFDM_ + 0x00)
+#define REG_ROFDM0_TRXPATHENABLE	(RTL8712_PHY_OFDM_ + 0x04)
+#define REG_ROFDM0_TRMUXPAR		(RTL8712_PHY_OFDM_ + 0x08)
+#define REG_ROFDM0_TRSWISOLATION	(RTL8712_PHY_OFDM_ + 0x0C)
+#define REG_ROFDM0_XARXAFE		(RTL8712_PHY_OFDM_ + 0x10)
+#define REG_ROFDM0_XARXIQIMBALANCE	(RTL8712_PHY_OFDM_ + 0x14)
+#define REG_ROFDM0_XBRXAFE		(RTL8712_PHY_OFDM_ + 0x18)
+#define REG_ROFDM0_XBRXIQIMBALANCE	(RTL8712_PHY_OFDM_ + 0x1C)
+#define REG_ROFDM0_XCRXAFE		(RTL8712_PHY_OFDM_ + 0x20)
+#define REG_ROFDM0_XCRXIQIMBALANCE	(RTL8712_PHY_OFDM_ + 0x24)
+#define REG_ROFDM0_XDRXAFE		(RTL8712_PHY_OFDM_ + 0x28)
+#define REG_ROFDM0_XDRXIQIMBALANCE	(RTL8712_PHY_OFDM_ + 0x2C)
+#define REG_ROFDM0_RXDETECTOR1		(RTL8712_PHY_OFDM_ + 0x30)
+#define REG_ROFDM0_RXDETECTOR2		(RTL8712_PHY_OFDM_ + 0x34)
+#define REG_ROFDM0_RXDETECTOR3		(RTL8712_PHY_OFDM_ + 0x38)
+#define REG_ROFDM0_RXDETECTOR4		(RTL8712_PHY_OFDM_ + 0x3C)
+#define REG_ROFDM0_RXDSP		(RTL8712_PHY_OFDM_ + 0x40)
+#define REG_ROFDM0_CFO_AND_DAGC		(RTL8712_PHY_OFDM_ + 0x44)
+#define REG_ROFDM0_CCADROP_THRESHOLD	(RTL8712_PHY_OFDM_ + 0x48)
+#define REG_ROFDM0_ECCA_THRESHOLD	(RTL8712_PHY_OFDM_ + 0x4C)
+#define REG_ROFDM0_XAAGCCORE1		(RTL8712_PHY_OFDM_ + 0x50)
+#define REG_ROFDM0_XAAGCCORE2		(RTL8712_PHY_OFDM_ + 0x54)
+#define REG_ROFDM0_XBAGCCORE1		(RTL8712_PHY_OFDM_ + 0x58)
+#define REG_ROFDM0_XBAGCCORE2		(RTL8712_PHY_OFDM_ + 0x5C)
+#define REG_ROFDM0_XCAGCCORE1		(RTL8712_PHY_OFDM_ + 0x60)
+#define REG_ROFDM0_XCAGCCORE2		(RTL8712_PHY_OFDM_ + 0x64)
+#define REG_ROFDM0_XDAGCCORE1		(RTL8712_PHY_OFDM_ + 0x68)
+#define REG_ROFDM0_XDAGCCORE2		(RTL8712_PHY_OFDM_ + 0x6C)
+#define REG_ROFDM0_AGCPARAMETER1	(RTL8712_PHY_OFDM_ + 0x70)
+#define REG_ROFDM0_AGCPARAMETER2	(RTL8712_PHY_OFDM_ + 0x74)
+#define REG_ROFDM0_AGCRSSITABLE		(RTL8712_PHY_OFDM_ + 0x78)
+#define REG_ROFDM0_HTSTFAGC		(RTL8712_PHY_OFDM_ + 0x7C)
+#define REG_ROFDM0_XATXIQIMBALANCE	(RTL8712_PHY_OFDM_ + 0x80)
+#define REG_ROFDM0_XATXAFE		(RTL8712_PHY_OFDM_ + 0x84)
+#define REG_ROFDM0_XBTXIQIMBALANCE	(RTL8712_PHY_OFDM_ + 0x88)
+#define REG_ROFDM0_XBTXAFE		(RTL8712_PHY_OFDM_ + 0x8C)
+#define REG_ROFDM0_XCTXIQIMBALANCE	(RTL8712_PHY_OFDM_ + 0x90)
+#define REG_ROFDM0_XCTXAFE		(RTL8712_PHY_OFDM_ + 0x94)
+#define REG_ROFDM0_XDTXIQIMBALANCE	(RTL8712_PHY_OFDM_ + 0x98)
+#define REG_ROFDM0_XDTXAFE		(RTL8712_PHY_OFDM_ + 0x9C)
+#define REG_ROFDM0_TXCOEFF1		(RTL8712_PHY_OFDM_ + 0xA4)
+#define REG_ROFDM0_TXCOEFF2		(RTL8712_PHY_OFDM_ + 0xA8)
+#define REG_ROFDM0_TXCOEFF3		(RTL8712_PHY_OFDM_ + 0xAC)
+#define REG_ROFDM0_TXCOEFF4		(RTL8712_PHY_OFDM_ + 0xB0)
+#define REG_ROFDM0_TXCOEFF5		(RTL8712_PHY_OFDM_ + 0xB4)
+#define REG_ROFDM0_TXCOEFF6		(RTL8712_PHY_OFDM_ + 0xB8)
+#define REG_ROFDM0_RXHP_PARAMETER	(RTL8712_PHY_OFDM_ + 0xe0)
+#define REG_ROFDM0_TXPSEUDO_NOISE_WGT	(RTL8712_PHY_OFDM_ + 0xe4)
+#define REG_ROFDM0_FRAME_SYNC		(RTL8712_PHY_OFDM_ + 0xf0)
+#define REG_ROFDM0_DFSREPORT		(RTL8712_PHY_OFDM_ + 0xf4)
+
+#define REG_ROFDM1_LSTF			(RTL8712_PHY_OFDM_ + 0x100)
+#define REG_ROFDM1_TRXPATHENABLE	(RTL8712_PHY_OFDM_ + 0x104)
+#define REG_ROFDM1_CFO			(RTL8712_PHY_OFDM_ + 0x108)
+
+#define REG_ROFDM1_CSI1			(RTL8712_PHY_OFDM_ + 0x110)
+#define REG_ROFDM1_SBD			(RTL8712_PHY_OFDM_ + 0x114)
+#define REG_ROFDM1_CSI2			(RTL8712_PHY_OFDM_ + 0x118)
+
+#define REG_ROFDM1_CFOTRACKING		(RTL8712_PHY_OFDM_ + 0x12C)
+
+#define REG_ROFDM1_TRXMESAURE1		(RTL8712_PHY_OFDM_ + 0x134)
+
+#define REG_ROFDM1_INTF_DET		(RTL8712_PHY_OFDM_ + 0x13C)
+
+#define REG_ROFDM1_PSEUDO_NOISESTATEAB	(RTL8712_PHY_OFDM_ + 0x150)
+#define REG_ROFDM1_PSEUDO_NOISESTATECD	(RTL8712_PHY_OFDM_ + 0x154)
+#define REG_ROFDM1_RX_PSEUDO_NOISE_WGT	(RTL8712_PHY_OFDM_ + 0x158)
+
+#define REG_ROFDM_PHYCOUNTER1		(RTL8712_PHY_OFDM_ + 0x1A0)
+#define REG_ROFDM_PHYCOUNTER2		(RTL8712_PHY_OFDM_ + 0x1A4)
+#define REG_ROFDM_PHYCOUNTER3		(RTL8712_PHY_OFDM_ + 0x1A8)
+#define REG_ROFDM_SHORT_CFOAB		(RTL8712_PHY_OFDM_ + 0x1AC)
+#define REG_ROFDM_SHORT_CFOCD		(RTL8712_PHY_OFDM_ + 0x1B0)
+#define REG_ROFDM_LONG_CFOAB		(RTL8712_PHY_OFDM_ + 0x1B4)
+#define REG_ROFDM_LONG_CFOCD		(RTL8712_PHY_OFDM_ + 0x1B8)
+#define REG_ROFDM_TAIL_CFOAB		(RTL8712_PHY_OFDM_ + 0x1BC)
+#define REG_ROFDM_TAIL_CFOCD		(RTL8712_PHY_OFDM_ + 0x1C0)
+#define REG_ROFDM_PW_MEASURE1		(RTL8712_PHY_OFDM_ + 0x1C4)
+#define REG_ROFDM_PW_MEASURE2		(RTL8712_PHY_OFDM_ + 0x1C8)
+#define REG_ROFDM_BW_REPORT		(RTL8712_PHY_OFDM_ + 0x1CC)
+#define REG_ROFDM_AGC_REPORT		(RTL8712_PHY_OFDM_ + 0x1D0)
+#define REG_ROFDM_RXSNR			(RTL8712_PHY_OFDM_ + 0x1D4)
+#define REG_ROFDM_RXEVMCSI		(RTL8712_PHY_OFDM_ + 0x1D8)
+#define REG_ROFDM_SIG_REPORT		(RTL8712_PHY_OFDM_ + 0x1DC)
+
+/* ----------------------------------------------------- */
+/* 0x10250E00 ~ 0x10250EFF PHY Automatic Gain Control */
+/* ----------------------------------------------------- */
+#define REG_RTXAGC_RATE18_06		(RTL8712_PHY_RXAGC_ + 0x00)
+#define REG_RTXAGC_RATE54_24		(RTL8712_PHY_RXAGC_ + 0x04)
+#define REG_RTXAGC_CCK_MCS32		(RTL8712_PHY_RXAGC_ + 0x08)
+#define REG_RTXAGC_MCS03_MCS00		(RTL8712_PHY_RXAGC_ + 0x10)
+#define REG_RTXAGC_MCS07_MCS04		(RTL8712_PHY_RXAGC_ + 0x14)
+#define REG_RTXAGC_MCS11_MCS08		(RTL8712_PHY_RXAGC_ + 0x18)
+#define REG_RTXAGC_MCS15_MCS12		(RTL8712_PHY_RXAGC_ + 0x1c)
+
+/* ----------------------------------------------------- */
+/* 0x1025FE00 ~ 0x1025FEFF USB Configuration */
+/* ----------------------------------------------------- */
+#define REG_USB_INFO			(RTL8712_USB_ + 0x17)
+#define REG_USB_MAGIC			(RTL8712_USB_ + 0x1C)
+#define		USB_MAGIC_BIT7			BIT(7)
+
+#define REG_USB_SPECIAL_OPTION		(RTL8712_USB_ + 0x55)
+#define REG_USB_HCPWM			(RTL8712_USB_ + 0x57)
+#define REG_USB_HRPWM			(RTL8712_USB_ + 0x58)
+#define REG_USB_DMA_AGG_TO		(RTL8712_USB_ + 0x5B)
+#define REG_USB_AGG_TO			(RTL8712_USB_ + 0x5C)
+#define REG_USB_AGG_TH			(RTL8712_USB_ + 0x5D)
+
+#define REG_USB_VID			(RTL8712_USB_ + 0x60)
+#define REG_USB_PID			(RTL8712_USB_ + 0x62)
+#define REG_USB_OPTIONAL		(RTL8712_USB_ +	0x64)
+#define REG_USB_CHIRP_K			(RTL8712_USB_ + 0x65) /* REG_USB_EP */
+#define REG_USB_PHY			(RTL8712_USB_ + 0x66) /* 0xFE68? */
+#define REG_USB_MAC_ADDR		(RTL8712_USB_ + 0x70)
+#define REG_USB_STRING			(RTL8712_USB_ + 0x80)
+
+/* ----------------------------------------------------- */
+/* 0x10300000 ~ 0x103FFFFF FIFOs for 8712 */
+/* ----------------------------------------------------- */
+#define REG_RTL8712_DMA_BCNQ		(RTL8712_IOBASE_FF + 0x10000)
+#define REG_RTL8712_DMA_MGTQ		(RTL8712_IOBASE_FF + 0x20000)
+#define REG_RTL8712_DMA_BMCQ		(RTL8712_IOBASE_FF + 0x30000)
+#define REG_RTL8712_DMA_VOQ		(RTL8712_IOBASE_FF + 0x40000)
+#define REG_RTL8712_DMA_VIQ		(RTL8712_IOBASE_FF + 0x50000)
+#define REG_RTL8712_DMA_BEQ		(RTL8712_IOBASE_FF + 0x60000)
+#define REG_RTL8712_DMA_BKQ		(RTL8712_IOBASE_FF + 0x70000)
+#define REG_RTL8712_DMA_RX0FF		(RTL8712_IOBASE_FF + 0x80000)
+#define REG_RTL8712_DMA_H2CCMD		(RTL8712_IOBASE_FF + 0x90000)
+#define REG_RTL8712_DMA_C2HCMD		(RTL8712_IOBASE_FF + 0xA0000)
+
+#define SET_VAL(reg, value, newvalue)					\
+	(value = ((value) & ~(reg)) | (((newvalue) << (reg##_S)) & (reg)))
+
+#define SET_CONSTVAL(reg, newvalue)					\
+	(((newvalue) << (reg##_S)) & (reg))
+
+#define MOD_VAL(reg, value, newvalue)					\
+	(((value) & ~(reg)) | (((newvalue) << (reg##_S)) & (reg)))
+
+#define GET_VAL(reg, value)						\
+	(((value) & (reg)) >> (reg##_S))
+
+#endif /* __R92SU_REG_H__*/
--- /dev/null
+++ b/drivers/net/wireless/r92su/rx.c
@@ -0,0 +1,1187 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+#include <linux/etherdevice.h>
+
+#include <net/ieee80211_radiotap.h>
+#include <asm/unaligned.h>
+
+#include "r92su.h"
+#include "rx.h"
+#include "usb.h"
+#include "def.h"
+#include "event.h"
+#include "michael.h"
+
+static void r92su_rx_add_radiotap(struct r92su *r92su,
+				  const struct rx_hdr *rx_hdr,
+				  struct sk_buff *skb,
+				  const unsigned int rtap_len)
+{
+	unsigned char *pos;
+	struct ieee80211_radiotap_header *rthdr;
+
+	rthdr = (struct ieee80211_radiotap_header *)skb_push(skb, rtap_len);
+	memset(rthdr, 0, sizeof(*rthdr));
+
+	rthdr->it_present =
+		cpu_to_le32((1 << IEEE80211_RADIOTAP_FLAGS) |
+			    (1 << IEEE80211_RADIOTAP_CHANNEL) |
+			    (1 << IEEE80211_RADIOTAP_ANTENNA) |
+			    (1 << IEEE80211_RADIOTAP_RX_FLAGS) |
+			    (1 << IEEE80211_RADIOTAP_TSFT));
+	rthdr->it_len = cpu_to_le16(rtap_len);
+
+	pos = (unsigned char *)(rthdr + 1);
+
+	/* Note: the order of the entries is important! */
+
+	/* IEEE80211_RADIOTAP_TSFT + TSFT Alignment */
+	while ((pos - (u8 *)rthdr) & 7)
+		*pos++ = 0;
+
+	put_unaligned_le64(le32_to_cpu(rx_hdr->tsf32), pos);
+	pos += 8;
+
+	/* IEEE80211_RADIOTAP_FLAGS */
+	*pos = IEEE80211_RADIOTAP_F_FCS;
+	if (rx_hdr->crc32)
+		*pos |= IEEE80211_RADIOTAP_F_BADFCS;
+	if (rx_hdr->splcp)
+		*pos |= IEEE80211_RADIOTAP_F_SHORTPRE;
+	pos++;
+
+	/* IEEE80211_RADIOTAP_RATE */
+	if (rx_hdr->rx_ht) {
+		/* Without rate information don't add it. If we have,
+		 * MCS information is a separate field in radiotap,
+		 * added below. The byte here is needed as padding
+		 * for the channel though, so initialise it to 0.
+		 */
+		*pos = 0;
+	} else {
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);
+		*pos = r92su->band_2GHZ.bitrates[rx_hdr->rx_mcs].bitrate / 5;
+	}
+	pos++;
+
+	/* IEEE80211_RADIOTAP_CHANNEL */
+	put_unaligned_le16(r92su->current_channel->center_freq, pos);
+	pos += 2;
+	if (rx_hdr->rx_ht)
+		put_unaligned_le16(IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ,
+				   pos);
+	else if (rx_hdr->rx_mcs > 3)
+		put_unaligned_le16(IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ,
+				   pos);
+	else
+		put_unaligned_le16(IEEE80211_CHAN_CCK | IEEE80211_CHAN_2GHZ,
+				   pos);
+	pos += 2;
+
+	/* IEEE80211_RADIOTAP_ANTENNA */
+	*pos++ = 0;
+
+	/* IEEE80211_RADIOTAP_RX_FLAGS */
+	/* ensure 2 byte alignment for the 2 byte field as required */
+	if ((pos - (u8 *)rthdr) & 1)
+		*pos++ = 0;
+	put_unaligned_le16(0, pos);
+	pos += 2;
+
+	if (rx_hdr->rx_ht) {
+		rthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_MCS);
+		*pos++ = IEEE80211_RADIOTAP_MCS_HAVE_MCS |
+			 IEEE80211_RADIOTAP_MCS_HAVE_BW;
+		*pos = 0;
+		if (rx_hdr->bw)
+			*pos |= IEEE80211_RADIOTAP_MCS_BW_40;
+		pos++;
+		*pos++ = rx_hdr->rx_mcs;
+	}
+
+	if (rx_hdr->paggr) {
+		u16 flags = 0;
+
+		/* ensure 4 byte alignment */
+		while ((pos - (u8 *)rthdr) & 3)
+			pos++;
+
+		rthdr->it_present |=
+			cpu_to_le32(1 << IEEE80211_RADIOTAP_AMPDU_STATUS);
+
+		if (rx_hdr->faggr)
+			r92su->ampdu_reference++;
+
+		put_unaligned_le32(r92su->ampdu_reference, pos);
+		pos += 4;
+
+		/* ampdu flags, no flags ? */
+		put_unaligned_le16(flags, pos);
+		pos += 2;
+
+		*pos++ = 0;	/* no crc delim */
+		*pos++ = 0;
+	}
+}
+
+static unsigned int r92su_rx_calc_radiotap_len(struct r92su *r92su,
+					       const struct rx_hdr *rx_hdr)
+{
+	unsigned int rtap_len;
+
+	/* Note: the order of the entries is important! */
+
+	rtap_len = sizeof(struct ieee80211_radiotap_header);
+	rtap_len += 9;
+
+	/* TSF + Align */
+	rtap_len = ALIGN(rtap_len, 8);
+	rtap_len += 8;
+
+	/* padding for RX_FLAGS if necessary */
+	rtap_len = ALIGN(rtap_len, 2);
+
+	if (rx_hdr->rx_ht)
+		rtap_len += 3;
+
+	if (rx_hdr->paggr) {
+		rtap_len = ALIGN(rtap_len, 4);
+		rtap_len += 8;
+	}
+
+	return rtap_len;
+}
+
+static void r92su_rx_dropped(struct r92su *r92su, unsigned int count)
+{
+	r92su->wdev.netdev->stats.rx_dropped += count;
+}
+
+static void __r92su_rx_deliver(struct r92su *r92su, struct sk_buff *skb)
+{
+	int rc;
+
+	skb_orphan(skb);
+
+	if (in_interrupt())
+		rc = netif_rx_ni(skb);
+	else
+		rc = netif_rx(skb);
+
+	if (rc == NET_RX_SUCCESS) {
+		skb->dev->stats.rx_packets++;
+		skb->dev->stats.rx_bytes += skb->len;
+	} else
+		r92su_rx_dropped(r92su, 1);
+}
+
+static void r92su_rx_monitor(struct r92su *r92su, const struct rx_packet *rx,
+			     const struct ieee80211_hdr *hdr,
+			     struct sk_buff *skb)
+{
+	struct rx_hdr rx_hdr;
+	unsigned int rtap_len;
+
+	memcpy(&rx_hdr, &rx->hdr, sizeof(rx_hdr));
+
+	rtap_len = r92su_rx_calc_radiotap_len(r92su, &rx_hdr);
+	r92su_rx_add_radiotap(r92su, &rx_hdr, skb, rtap_len);
+
+	skb_reset_mac_header(skb);
+	skb->dev = r92su->wdev.netdev;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_802_2);
+	__r92su_rx_deliver(r92su, skb);
+}
+
+static void r92su_rx_deliver(struct r92su *r92su, struct sk_buff *skb)
+{
+	skb_reset_mac_header(skb);
+	skb->dev = r92su->wdev.netdev;
+	/* TODO: we can check the TCP checksum in the header */
+	skb->ip_summed = CHECKSUM_NONE;
+	skb->protocol = eth_type_trans(skb, skb->dev);
+	__r92su_rx_deliver(r92su, skb);
+}
+
+struct r92su_rx_info {
+	struct r92su_sta *sta;
+	struct r92su_key *key;
+	u64 iv;
+	bool has_protect;
+};
+
+enum r92su_rx_control_t {
+	RX_CONTINUE,
+	RX_QUEUE,
+	RX_DROP,
+};
+
+static struct r92su_rx_info *r92su_get_rx_info(struct sk_buff *skb)
+{
+	BUILD_BUG_ON(sizeof(struct r92su_rx_info) > sizeof(skb->cb));
+	return (struct r92su_rx_info *) skb->cb;
+}
+
+static inline u16 get_seq_h(struct ieee80211_hdr *hdr)
+{
+	return le16_to_cpu(hdr->seq_ctrl) >> 4;
+}
+
+static inline u16 get_tid_h(struct ieee80211_hdr *hdr)
+{
+	return (ieee80211_get_qos_ctl(hdr))[0] & IEEE80211_QOS_CTL_TID_MASK;
+}
+
+static enum r92su_rx_control_t
+r92su_rx_deduplicate(struct r92su *r92su, struct sk_buff *skb,
+		     struct r92su_bss_priv *bss_priv)
+{
+	struct ieee80211_hdr *i3e = (void *)skb->data;
+	struct r92su_rx_info *rx_info = r92su_get_rx_info(skb);
+	struct r92su_sta *sta = rx_info->sta;
+	__le16 *rx_seq;
+
+	if (sta) {
+		if (ieee80211_is_data_qos(i3e->frame_control))
+			rx_seq = &sta->rx_seq_tid[get_tid_h(i3e)];
+		else
+			rx_seq = &sta->rx_seq;
+
+		if (*rx_seq == i3e->seq_ctrl) {
+			sta->drop_dup++;
+			return RX_DROP;
+		}
+
+		*rx_seq = i3e->seq_ctrl;
+	}
+	return RX_CONTINUE;
+}
+
+static enum r92su_rx_control_t
+r92su_rx_find_sta(struct r92su *r92su, struct sk_buff *skb,
+		  struct r92su_bss_priv *bss_priv)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct r92su_sta *sta;
+	struct r92su_rx_info *rx_info = r92su_get_rx_info(skb);
+
+	sta = r92su_sta_get(r92su, ieee80211_get_SA(hdr));
+	if (!sta)
+		sta = bss_priv->sta;
+
+	rx_info->sta = sta;
+	return RX_CONTINUE;
+}
+
+static enum r92su_rx_control_t
+r92su_rx_find_key(struct r92su *r92su, struct sk_buff *skb,
+		  struct r92su_bss_priv *bss_priv)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct r92su_rx_info *rx_info = r92su_get_rx_info(skb);
+	struct r92su_key *key;
+
+	if (rx_info->has_protect) {
+		u8 *iv = r92su_get_i3e_payload(hdr);
+		u8 idx = iv[3] >> 6 & 0x3;
+
+		key = rcu_dereference(bss_priv->group_key[idx]);
+
+		if (!key)
+			key = rcu_dereference(rx_info->sta->sta_key);
+
+		if (!key)
+			key = rcu_dereference(bss_priv->sta->sta_key);
+
+		if (!key)
+			return RX_DROP;
+
+		rx_info->key = key;
+	} else {
+		/* see r92su_rx_port_check */
+	}
+
+	return RX_CONTINUE;
+}
+
+static enum r92su_rx_control_t
+r92su_rx_port_check(struct r92su *r92su, struct sk_buff *skb,
+		 struct r92su_bss_priv *bss_priv)
+{
+	struct r92su_rx_info *rx_info = r92su_get_rx_info(skb);
+
+	if (bss_priv->sta->enc_sta && !rx_info->has_protect) {
+		if (bss_priv->control_port_no_encrypt &&
+		    skb->protocol != bss_priv->control_port_ethertype) {
+			return RX_DROP;
+		}
+	}
+	return RX_CONTINUE;
+}
+
+static enum r92su_rx_control_t
+r92su_rx_handle_iv(struct r92su *r92su, struct sk_buff *skb,
+		   struct r92su_bss_priv *bss_priv)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct r92su_rx_info *rx_info = r92su_get_rx_info(skb);
+	struct r92su_key *key;
+	unsigned int hdr_len = ieee80211_hdrlen(hdr->frame_control);
+	unsigned int iv_len;
+	u8 *iv;
+
+	key = rx_info->key;
+
+	if (!key)
+		return RX_CONTINUE;
+
+	iv_len = r92su_get_iv_len(key);
+	iv = ((u8 *) hdr) + hdr_len;
+
+	switch (key->type) {
+	case WEP40_ENCRYPTION:
+	case WEP104_ENCRYPTION:
+		break;
+
+	case TKIP_ENCRYPTION: {
+		u64 seq;
+
+		/* check ext iv */
+		if (!(iv[3] & BIT(5)))
+			return RX_DROP;
+
+		seq = iv[7];
+		seq = (seq << 8) + iv[6];
+		seq = (seq << 8) + iv[5];
+		seq = (seq << 8) + iv[4];
+		seq = (seq << 8) + iv[0];
+		seq = (seq << 8) + iv[2];
+
+		if (key->tkip.rx_seq >= seq)
+			return RX_DROP;
+
+		rx_info->iv = seq;
+		break;
+	}
+
+	case AESCCMP_ENCRYPTION: {
+		u64 seq;
+		/* check ext iv */
+		if (!(iv[3] & BIT(5)))
+			return RX_DROP;
+
+		seq = iv[7];
+		seq = (seq << 8) + iv[6];
+		seq = (seq << 8) + iv[5];
+		seq = (seq << 8) + iv[4];
+		seq = (seq << 8) + iv[1];
+		seq = (seq << 8) + iv[0];
+		if (seq <= key->ccmp.rx_seq)
+			return RX_DROP;
+
+		rx_info->iv = seq;
+		break;
+	}
+
+	default:
+		WARN(1, "invalid key type %d\n", key->type);
+		return RX_DROP;
+	}
+
+	if (skb->len <= iv_len)
+		return RX_DROP;
+
+	memmove(((u8 *) hdr) + iv_len, hdr, hdr_len);
+	skb_pull(skb, iv_len);
+	return RX_CONTINUE;
+}
+
+static enum r92su_rx_control_t
+r92su_rx_check_iv(struct r92su *r92su, struct sk_buff *skb,
+		  struct r92su_bss_priv *bss_priv)
+{
+	struct r92su_rx_info *rx_info = r92su_get_rx_info(skb);
+	struct r92su_key *key;
+
+	key = rx_info->key;
+
+	if (!key)
+		return RX_CONTINUE;
+
+	switch (key->type) {
+	case WEP40_ENCRYPTION:
+	case WEP104_ENCRYPTION:
+		break;
+
+	case TKIP_ENCRYPTION:
+		key->tkip.rx_seq = rx_info->iv;
+		break;
+
+	case AESCCMP_ENCRYPTION:
+		key->ccmp.rx_seq = rx_info->iv;
+		break;
+
+	default:
+		WARN(1, "invalid key type %d\n", key->type);
+		return RX_DROP;
+	}
+	return RX_CONTINUE;
+}
+
+static enum r92su_rx_control_t
+r92su_rx_handle_icv_mic(struct r92su *r92su, struct sk_buff *skb,
+			struct r92su_bss_priv *bss_priv)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct r92su_rx_info *rx_info = r92su_get_rx_info(skb);
+	struct r92su_key *key = rx_info->key;
+	int remove_len, data_len;
+	int hdr_len = ieee80211_hdrlen(hdr->frame_control);
+	void *tail, *data;
+
+	if (!key)
+		return RX_CONTINUE;
+
+	data = ((void *) hdr) + hdr_len;
+
+	switch (key->type) {
+	case WEP40_ENCRYPTION:
+	case WEP104_ENCRYPTION:
+		remove_len = 4;
+		break;
+
+	case TKIP_ENCRYPTION: {
+		u8 mic[MICHAEL_MIC_LEN];
+
+		data_len = skb->len - hdr_len - MICHAEL_MIC_LEN - 4;
+		if (data_len < 0)
+			return RX_DROP;
+
+		tail = data + data_len;
+		michael_mic(&key->tkip.key.key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY],
+			    hdr, data, data_len, mic);
+
+		if (memcmp(mic, tail, MICHAEL_MIC_LEN) != 0) {
+			cfg80211_michael_mic_failure(r92su->wdev.netdev,
+				hdr->addr2,
+				is_multicast_ether_addr(hdr->addr1) ?
+				NL80211_KEYTYPE_GROUP :
+				NL80211_KEYTYPE_PAIRWISE,
+				key->index, NULL, GFP_ATOMIC);
+			return RX_DROP;
+		}
+
+		key->tkip.rx_seq = rx_info->iv;
+		remove_len = 12;
+		break;
+	}
+
+	case AESCCMP_ENCRYPTION:
+		remove_len = 8;
+		break;
+
+	default:
+		WARN(1, "invalid key type %d\n", key->type);
+		return RX_DROP;
+	}
+
+	if (skb->len <= remove_len)
+		return RX_DROP;
+
+	skb_trim(skb, skb->len - remove_len);
+	return RX_CONTINUE;
+}
+
+static enum r92su_rx_control_t
+r92su_rx_data_to_8023(struct r92su *r92su, struct sk_buff *skb,
+		      struct r92su_bss_priv *bss_priv, struct sk_buff **_skb,
+		      struct sk_buff_head *queue)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	bool is_amsdu = false;
+
+	if (ieee80211_is_data_qos(hdr->frame_control)) {
+		u8 *qos = ieee80211_get_qos_ctl(hdr);
+		is_amsdu = !!(qos[0] & BIT(7));
+	}
+
+	if (is_amsdu) {
+		struct r92su_rx_info tmp_rx_info;
+
+		memcpy(&tmp_rx_info, r92su_get_rx_info(skb),
+		       sizeof(tmp_rx_info));
+
+		/* we can use the skb queue without spinlocks */
+		ieee80211_amsdu_to_8023s(skb, queue,
+					 wdev_address(&r92su->wdev),
+					 r92su->wdev.iftype, 0, true);
+		*_skb = NULL;
+
+		if (skb_queue_empty(queue)) {
+			/* amsdu_to_8023s encountered an error. */
+			return RX_DROP;
+		}
+
+		skb_queue_walk(queue, skb) {
+			struct r92su_rx_info *new_info;
+
+			new_info = r92su_get_rx_info(skb);
+			memcpy(new_info, &tmp_rx_info, sizeof(*new_info));
+		}
+
+	} else {
+		int err;
+
+		err = ieee80211_data_to_8023(skb, wdev_address(&r92su->wdev),
+					     r92su->wdev.iftype);
+
+		if (err)
+			return RX_DROP;
+
+		__skb_queue_tail(queue, skb);
+		*_skb = NULL;
+	}
+
+	return RX_CONTINUE;
+}
+
+static u8 r92su_get_priority(struct r92su *r92su, struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	if (ieee80211_is_data_qos(hdr->frame_control)) {
+		u8 *qos = ieee80211_get_qos_ctl(hdr);
+		skb->priority = qos[0] & IEEE80211_QOS_CTL_TAG1D_MASK;
+	} else
+		skb->priority = 0;
+
+	return ieee802_1d_to_ac[skb->priority];
+}
+
+static enum r92su_rx_control_t
+r92su_rx_hw_header_check(struct r92su *r92su, struct sk_buff *skb,
+			 struct r92su_bss_priv *bss_priv,
+			 const struct rx_packet *rx)
+{
+	struct r92su_rx_info *rx_info;
+	struct ieee80211_hdr *hdr;
+	unsigned int min_len;
+	bool has_protect;
+	if (skb->len < (sizeof(*hdr) + FCS_LEN))
+		return RX_DROP;
+
+	/* remove FCS - see comment in rx_filter about APPFCS */
+	skb_trim(skb, skb->len - FCS_LEN);
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+
+	/* filter out frames with bad fcs... if they did end up here */
+	if (rx->hdr.crc32)
+		return RX_DROP;
+
+	has_protect = ieee80211_has_protected(hdr->frame_control);
+
+	if (has_protect && rx->hdr.swdec) {
+		wiphy_err(r92su->wdev.wiphy, "hw didn't decipher frame.\n");
+		return RX_DROP;
+	}
+
+	/* report icv error
+	 * The vendor driver ignores the flag, probably because someone
+	 * "knew" that the hardware/firmware doesn't calculate the right
+	 * icv in all cases (especially with fragments).
+	 * if (rx->hdr.icv) {
+	 *	return RX_DROP;
+	 * }
+	 */
+
+	if (!ieee80211_is_data_present(hdr->frame_control))
+		return RX_DROP;
+
+	/* just in case: clear out the whole skb->cb */
+	memset(skb->cb, 0, sizeof(skb->cb));
+
+	min_len = ieee80211_hdrlen(hdr->frame_control);
+	if (skb->len < min_len)
+		return RX_DROP;
+
+	skb_set_queue_mapping(skb, r92su_get_priority(r92su, skb));
+
+	rx_info = r92su_get_rx_info(skb);
+	rx_info->has_protect = has_protect;
+	return RX_CONTINUE;
+}
+
+static bool r92su_check_if_match(struct r92su *r92su,
+				 struct sk_buff *new_skb,
+				 struct sk_buff_head *defrag,
+				 struct r92su_key *key)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) new_skb->data;
+	struct ieee80211_hdr *tmp_hdr;
+	struct sk_buff *tmp;
+	u16 cur_seq, cur_frag, tmp_frag, tmp_seq;
+
+	tmp = skb_peek_tail(defrag);
+	if (!tmp)
+		return false;
+
+	cur_seq = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;
+	cur_frag = le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG;
+
+	tmp_hdr = (struct ieee80211_hdr *) tmp->data;
+	tmp_frag = le16_to_cpu(tmp_hdr->seq_ctrl) & IEEE80211_SCTL_FRAG;
+	tmp_seq = (le16_to_cpu(tmp_hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;
+	if (tmp_seq != cur_seq && cur_frag != (1 + tmp_frag))
+		return false;
+
+	if (key && key->type == AESCCMP_ENCRYPTION) {
+		struct r92su_rx_info *old_rx_info = r92su_get_rx_info(tmp);
+		struct r92su_rx_info *new_rx_info = r92su_get_rx_info(new_skb);
+
+		if (old_rx_info->iv + 1 != new_rx_info->iv)
+			return false;
+	}
+
+	return true;
+}
+
+static void r92su_drop_defrag(struct r92su *r92su,
+			      struct r92su_defrag_entry *defrag)
+{
+	r92su_rx_dropped(r92su, skb_queue_len(&defrag->queue));
+	__skb_queue_purge(&defrag->queue);
+	defrag->size = 0;
+}
+
+static void r92su_add_to_defrag(struct r92su *r92su,
+				struct r92su_defrag_entry *defrag,
+				struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	int hdrlen = ieee80211_hdrlen(hdr->frame_control);
+
+	memset(skb->cb, 0, sizeof(skb->cb));
+	__skb_queue_tail(&defrag->queue, skb);
+	defrag->size += skb->len - hdrlen;
+}
+
+static enum r92su_rx_control_t
+r92su_rx_defrag(struct r92su *r92su, struct sk_buff *skb,
+		struct r92su_bss_priv *bss_priv)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct r92su_rx_info *rx_info = r92su_get_rx_info(skb);
+	struct r92su_sta *sta = rx_info->sta;
+	int hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	u16 qidx = skb_get_queue_mapping(skb);
+	u16 cur_frag = le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG;
+	struct r92su_defrag_entry *defrag = &sta->defrag[qidx];
+	struct sk_buff_head *dq = &defrag->queue;
+
+	if (unlikely(ieee80211_has_morefrags(hdr->frame_control))) {
+		if (cur_frag == 0)
+			goto new_queued;
+
+		if (!r92su_check_if_match(r92su, skb, dq, rx_info->key))
+			goto dropped;
+		else
+			goto queued;
+	} else {
+		struct sk_buff *tmp;
+
+		if (likely(cur_frag == 0)) {
+			r92su_drop_defrag(r92su, defrag);
+			return RX_CONTINUE;
+		}
+
+		if (!r92su_check_if_match(r92su, skb, dq, rx_info->key))
+			goto dropped;
+
+		defrag->size += skb->len - hdrlen;
+
+		if (unlikely(pskb_expand_head(skb, defrag->size -
+			     skb->len, 0, GFP_ATOMIC)))
+			goto dropped;
+
+		while ((tmp = __skb_dequeue_tail(dq))) {
+			/* this also replaces the current ieee80211 header
+			 * with the one queued in the defrag queue.
+			 */
+			hdr = (struct ieee80211_hdr *) skb->data;
+			skb_pull(skb, ieee80211_hdrlen(hdr->frame_control));
+			memcpy(skb_push(skb, tmp->len), tmp->data, tmp->len);
+			dev_kfree_skb_any(tmp);
+		}
+		return RX_CONTINUE;
+	}
+
+new_queued:
+	r92su_drop_defrag(r92su, defrag);
+queued:
+	r92su_add_to_defrag(r92su, defrag, skb);
+	return RX_QUEUE;
+
+dropped:
+	r92su_drop_defrag(r92su, defrag);
+	return RX_DROP;
+}
+
+static void
+r92su_release_reorder_frame(struct r92su *r92su, struct r92su_rx_tid *tid,
+			    int index, struct sk_buff_head *queue)
+{
+	struct sk_buff *skb = tid->reorder_buf[index];
+
+	if (!skb)
+		goto no_frame;
+
+	tid->len--;
+	tid->reorder_buf[index] = NULL;
+	__skb_queue_tail(queue, skb);
+
+no_frame:
+	tid->head_seq = ieee80211_sn_inc(tid->head_seq);
+}
+
+static void
+r92su_release_reorder_frames(struct r92su *r92su, struct r92su_rx_tid *tid,
+			     u16 new_head_seq, struct sk_buff_head *queue)
+{
+	int index;
+
+	while (ieee80211_sn_less(tid->head_seq, new_head_seq)) {
+		index = ieee80211_sn_sub(tid->head_seq, tid->ssn) % tid->size;
+		r92su_release_reorder_frame(r92su, tid, index, queue);
+	}
+}
+
+#define HT_RX_REORDER_BUF_TIMEOUT (HZ / 10)
+
+static void
+r92su_sta_reorder_release(struct r92su *r92su, struct r92su_rx_tid *tid,
+			  struct sk_buff_head *queue)
+{
+	int index, j;
+
+	index = ieee80211_sn_sub(tid->head_seq, tid->ssn) % tid->size;
+	if (tid->len && !tid->reorder_buf[index]) {
+		int skipped = 1;
+		for (j = (index + 1) % tid->size; j != index;
+		     j = (j + 1) % tid->size) {
+			if (!tid->reorder_buf[j]) {
+				skipped++;
+				continue;
+			}
+
+			if (skipped &&
+			    time_is_before_jiffies(tid->reorder_time[j]))
+				goto set_release_timer;
+
+			tid->head_seq = ieee80211_sn_add(tid->head_seq,
+							 skipped);
+			r92su_release_reorder_frame(r92su, tid, j, queue);
+			skipped = 0;
+		}
+	} else {
+		while (tid->reorder_buf[index]) {
+			r92su_release_reorder_frame(r92su, tid, index, queue);
+			index = ieee80211_sn_sub(tid->head_seq, tid->ssn) %
+				tid->size;
+		}
+	}
+
+	if (tid->len) {
+		j = index = ieee80211_sn_sub(tid->head_seq, tid->ssn) %
+			tid->size;
+
+		for (; j != (index - 1) % tid->size; j = (j + 1) % tid->size) {
+			if (tid->reorder_buf[j])
+				break;
+		}
+set_release_timer:
+		mod_timer(&tid->reorder_timer, tid->reorder_time[j] + 1);
+	} else {
+		del_timer(&tid->reorder_timer);
+	}
+}
+
+#define HT_RX_REORDER_INIT (HZ * 5)
+
+static enum r92su_rx_control_t
+r92su_rx_ampdu_reorder(struct r92su *r92su, struct sk_buff *skb,
+		       struct r92su_bss_priv *bss_priv,
+		       struct sk_buff **_skb,
+		       struct sk_buff_head *queue)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct r92su_rx_info *rx_info = r92su_get_rx_info(skb);
+	struct r92su_rx_tid *tid;
+	u16 sc = le16_to_cpu(hdr->seq_ctrl);
+	u16 mpdu_seq = (sc & IEEE80211_SCTL_SEQ) >> 4;
+	u16 head_seq;
+	int index;
+	bool queue_frame = true;
+
+	/* Currently, qos-nullfunc frames are not passed to the driver
+	 * by the firmware. The qos-nullfunc check is actually not
+	 * necessary.
+	 */
+	if (!ieee80211_is_data_qos(hdr->frame_control) ||
+	    ieee80211_is_qos_nullfunc(hdr->frame_control))
+		goto out;
+
+	if (!rx_info->sta)
+		goto out;
+
+	tid = rcu_dereference(rx_info->sta->rx_tid[get_tid_h(hdr)]);
+	if (!tid)
+		goto out;
+
+	spin_lock(&tid->lock);
+
+	head_seq = tid->head_seq;
+
+	/* frame with out of date sequence number */
+	if (ieee80211_sn_less(mpdu_seq, head_seq))
+		goto drop_unlock;
+
+	if (!ieee80211_sn_less(mpdu_seq, head_seq + tid->size)) {
+		head_seq = ieee80211_sn_inc(
+			ieee80211_sn_sub(mpdu_seq, tid->size));
+
+
+		r92su_release_reorder_frames(r92su, tid, head_seq, queue);
+	}
+
+	index = ieee80211_sn_sub(mpdu_seq, tid->ssn) % tid->size;
+
+	if (tid->reorder_buf[index])
+		goto drop_unlock;
+
+	if (mpdu_seq == tid->head_seq && tid->len == 0) {
+		tid->head_seq = ieee80211_sn_inc(mpdu_seq);
+	} else {
+		queue_frame = false;
+		tid->reorder_buf[index] = skb;
+		tid->reorder_time[index] = jiffies + HT_RX_REORDER_BUF_TIMEOUT;
+		tid->len++;
+		r92su_sta_reorder_release(r92su, tid, queue);
+	}
+
+	tid->last_rx = jiffies + HT_RX_REORDER_INIT;
+	spin_unlock(&tid->lock);
+
+out:
+	if (queue_frame)
+		__skb_queue_tail(queue, skb);
+	*_skb = NULL;
+	return RX_CONTINUE;
+
+drop_unlock:
+	spin_unlock(&tid->lock);
+	return RX_DROP;
+}
+
+#define __RX_HANDLER(func, dropgoto, queuegoto, args...) do {	\
+	enum r92su_rx_control_t __ret;				\
+	__ret = func(r92su, skb, bss_priv, ## args);		\
+	switch (__ret) {					\
+	case RX_CONTINUE:					\
+		break;						\
+	case RX_QUEUE:						\
+		goto queuegoto;					\
+	case RX_DROP:						\
+		goto dropgoto;					\
+	}							\
+} while (0)
+
+static void r92su_rx_handler(struct r92su *r92su,
+			     struct r92su_bss_priv *bss_priv,
+			     struct sk_buff_head *queue)
+{
+	struct sk_buff_head frames;
+	struct sk_buff *skb;
+
+	__skb_queue_head_init(&frames);
+
+#define RX_HANDLER_PREP(func, args...)				\
+	__RX_HANDLER(func, rx_drop, out, ## args)
+
+#define RX_HANDLER_MAIN(func, args...)				\
+	__RX_HANDLER(func, rx_drop_main, queued_main, ## args)
+
+	spin_lock(&r92su->rx_path);
+
+	while ((skb = __skb_dequeue(queue))) {
+		RX_HANDLER_PREP(r92su_rx_find_key);
+		RX_HANDLER_PREP(r92su_rx_handle_iv);
+		RX_HANDLER_PREP(r92su_rx_handle_icv_mic);
+		RX_HANDLER_PREP(r92su_rx_defrag);
+		RX_HANDLER_PREP(r92su_rx_check_iv);
+		RX_HANDLER_PREP(r92su_rx_data_to_8023, &skb, &frames);
+out:
+		continue;
+rx_drop:
+		r92su_rx_dropped(r92su, 1);
+		dev_kfree_skb_any(skb);
+	}
+
+	while ((skb = __skb_dequeue(&frames))) {
+		RX_HANDLER_MAIN(r92su_rx_port_check);
+		r92su_rx_deliver(r92su, skb);
+queued_main:
+		continue;
+
+rx_drop_main:
+		r92su_rx_dropped(r92su, 1);
+		dev_kfree_skb_any(skb);
+	}
+
+	spin_unlock(&r92su->rx_path);
+#undef RX_HANDLER_PREP
+#undef RX_HANDLER_MAIN
+}
+
+static void r92su_rx_sta_adhoc_data(struct r92su *r92su,
+	const struct rx_packet *rx, struct ieee80211_hdr *hdr,
+	struct sk_buff *skb)
+{
+	struct sk_buff_head frames;
+	struct cfg80211_bss *bss;
+	struct r92su_bss_priv *bss_priv;
+
+#define RX_HANDLER(func, args...)			\
+	__RX_HANDLER(func, rx_drop, out, ## args)
+
+	__skb_queue_head_init(&frames);
+
+	rcu_read_lock();
+	if (!r92su_is_connected(r92su))
+		goto rx_drop;
+
+	bss = rcu_dereference(r92su->connect_bss);
+	if (!bss)
+		goto rx_drop;
+
+	bss_priv = r92su_get_bss_priv(bss);
+	RX_HANDLER(r92su_rx_hw_header_check, rx);
+	RX_HANDLER(r92su_rx_find_sta);
+	RX_HANDLER(r92su_rx_deduplicate);
+
+	/* this moves the frame onto the in_frames queue */
+	RX_HANDLER(r92su_rx_ampdu_reorder, &skb, &frames);
+
+	r92su_rx_handler(r92su, bss_priv, &frames);
+out:
+	rcu_read_unlock();
+	return;
+
+rx_drop:
+	rcu_read_unlock();
+	r92su_rx_dropped(r92su, 1);
+	__skb_queue_purge(&frames);
+
+#undef __RX_HANDLER
+#undef RX_HANDLER
+}
+
+void r92su_rx_tid_reorder_timer(unsigned long arg)
+{
+	struct sk_buff_head frames;
+	struct r92su_rx_tid *tid;
+	struct r92su *r92su;
+	struct r92su_sta *sta;
+	struct cfg80211_bss *bss;
+	struct r92su_bss_priv *bss_priv;
+
+	__skb_queue_head_init(&frames);
+
+	rcu_read_lock();
+	tid = (struct r92su_rx_tid *) arg;
+	r92su = tid->r92su;
+	sta = tid->sta;
+
+	if (!r92su_is_connected(r92su))
+		goto out;
+
+	bss = rcu_dereference(r92su->connect_bss);
+	if (!bss || !sta)
+		goto out;
+
+	bss_priv = r92su_get_bss_priv(bss);
+
+	spin_lock(&tid->lock);
+	r92su_sta_reorder_release(r92su, tid, &frames);
+	spin_unlock(&tid->lock);
+
+	r92su_rx_handler(r92su, bss_priv, &frames);
+
+out:
+	rcu_read_unlock();
+}
+
+static struct sk_buff *rx92su_rx_copy_data(
+	const struct rx_packet *rx, unsigned int rx_len,
+	struct ieee80211_hdr *frame, unsigned int frame_len)
+{
+	struct sk_buff *skb;
+	int reserved = 0;
+
+	if (ieee80211_is_data_qos(frame->frame_control)) {
+		u8 *qc = ieee80211_get_qos_ctl(frame);
+		reserved += NET_IP_ALIGN;
+
+		if (*qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT)
+			reserved += NET_IP_ALIGN;
+	}
+
+	if (ieee80211_has_a4(frame->frame_control))
+		reserved += NET_IP_ALIGN;
+
+	reserved = 32 + (reserved & NET_IP_ALIGN);
+
+	skb = dev_alloc_skb(rx_len + frame_len + reserved);
+	if (likely(skb)) {
+		skb_reserve(skb, reserved);
+		memcpy(skb_put(skb, rx_len), rx, rx_len);
+		memcpy(skb_put(skb, frame_len), frame, frame_len);
+	}
+	return skb;
+}
+
+static void r92su_rx_tasklet(unsigned long arg0)
+{
+	struct r92su *r92su = (struct r92su *) arg0;
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&r92su->rx_queue))) {
+		struct rx_packet *rx;
+		struct ieee80211_hdr *hdr;
+
+		rx = (struct rx_packet *) skb->data;
+		hdr = (struct ieee80211_hdr *) skb_pull(skb,
+			RX_DESC_SIZE + rx->hdr.drvinfo_size * 8);
+		switch (r92su->wdev.iftype) {
+		case NL80211_IFTYPE_MONITOR:
+			r92su_rx_monitor(r92su, rx, hdr, skb);
+			break;
+		default:
+			r92su_rx_sta_adhoc_data(r92su, rx, hdr, skb);
+			break;
+		}
+	}
+}
+
+void r92su_rx_init(struct r92su *r92su)
+{
+	skb_queue_head_init(&r92su->rx_queue);
+	tasklet_init(&r92su->rx_tasklet, r92su_rx_tasklet,
+		     (unsigned long) r92su);
+}
+
+void r92su_rx_deinit(struct r92su *r92su)
+{
+	tasklet_kill(&r92su->rx_tasklet);
+	skb_queue_purge(&r92su->rx_queue);
+}
+
+void r92su_rx(struct r92su *r92su, void *buf, const unsigned int len)
+{
+	struct rx_packet *rx = (struct rx_packet *) buf;
+	void *end;
+	unsigned int pkt_cnt, pkt_len, hdr_len;
+
+	end = ((void *) buf) + min_t(unsigned int, len,
+		RTL92SU_SIZE_MAX_RX_BUFFER - RX_DESC_SIZE);
+
+	/* pkt_cnt seems to be valid only for the first aggregated packet?! */
+	pkt_cnt = max_t(unsigned int, rx->hdr.pkt_cnt, 1);
+
+	while (buf < end && pkt_cnt--) {
+		rx = (struct rx_packet *) buf;
+
+		pkt_len = le16_to_cpu(rx->hdr.pkt_len);
+		hdr_len = RX_DESC_SIZE + rx->hdr.drvinfo_size * 8;
+
+		if (buf + pkt_len + hdr_len + rx->hdr.shift > end)
+			goto err_garbage;
+
+		if (rx->hdr.mac_id == 0x1f && rx->hdr.tid == 0xf) {
+			if (len - sizeof(rx->hdr) <
+			    le16_to_cpu(rx->c2h.len) + sizeof(rx->c2h)) {
+				wiphy_err(r92su->wdev.wiphy, "received clipped c2h command.");
+				r92su_mark_dead(r92su);
+			} else
+				r92su_c2h_event(r92su, &rx->c2h);
+		} else {
+			struct ieee80211_hdr *i3e;
+			struct sk_buff *skb;
+
+			if (!r92su_is_connected(r92su))
+				continue;
+
+			i3e = ((void *) buf) + hdr_len + rx->hdr.shift;
+			skb = rx92su_rx_copy_data(rx, hdr_len, i3e, pkt_len);
+			if (skb)
+				skb_queue_tail(&r92su->rx_queue, skb);
+			else
+				r92su_rx_dropped(r92su, 1);
+		}
+		buf += ALIGN(hdr_len + pkt_len, r92su->rx_alignment);
+	}
+	tasklet_schedule(&r92su->rx_tasklet);
+	return;
+
+err_garbage:
+	wiphy_err(r92su->wdev.wiphy, "received clipped frame.");
+	return;
+}
+
+u8 *r92su_find_ie(u8 *ies, const u32 len, const u8 ie)
+{
+	u8 *pos, *end;
+
+	pos = ies;
+	end = ies + len;
+	while (pos < end) {
+		if (pos + 2 + pos[1] > end)
+			return NULL;
+
+		if (pos[0] == ie)
+			return pos;
+
+		pos += 2 + pos[1];
+	}
+	return NULL;
+}
--- /dev/null
+++ b/drivers/net/wireless/r92su/rx.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_RX_H__
+#define __R92SU_RX_H__
+
+#include <linux/mm.h>
+#include <linux/skbuff.h>
+
+#include "r92su.h"
+
+void r92su_rx_init(struct r92su *r92su);
+void r92su_rx_deinit(struct r92su *r92su);
+
+u8 *r92su_find_ie(u8 *ies, const u32 len, const u8 ie);
+
+void r92su_rx_tid_reorder_timer(unsigned long arg);
+void r92su_rx(struct r92su *r92su, void *skb, const unsigned int len);
+
+#endif /* __R92SU_RX_H__ */
+
+
--- /dev/null
+++ b/drivers/net/wireless/r92su/sta.c
@@ -0,0 +1,261 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+#include <linux/random.h>
+#include "r92su.h"
+#include "sta.h"
+#include "rx.h"
+
+static void r92su_free_tid_rcu(struct rcu_head *head)
+{
+	struct r92su_rx_tid *tid = container_of(head, struct r92su_rx_tid,
+						rcu_head);
+	int i;
+
+	del_timer_sync(&tid->reorder_timer);
+
+	spin_lock_bh(&tid->lock);
+	tid->len = 0;
+	for (i = 0; i < ARRAY_SIZE(tid->reorder_buf); i++) {
+		if (tid->reorder_buf[i]) {
+			dev_kfree_skb_any(tid->reorder_buf[i]);
+			tid->reorder_buf[i] = NULL;
+		}
+	}
+	spin_unlock_bh(&tid->lock);
+	kfree_rcu(tid, rcu_head);
+}
+
+static void r92su_free_tid(struct r92su_rx_tid *tid)
+{
+	if (tid) {
+		tid->sta = NULL;
+		call_rcu(&tid->rcu_head, r92su_free_tid_rcu);
+	}
+}
+
+static void r92su_free_sta_rcu(struct rcu_head *rch)
+{
+	struct r92su_sta *sta = container_of(rch, struct r92su_sta, rcu_head);
+	struct r92su_key *key;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sta->defrag); i++)
+		skb_queue_purge(&sta->defrag[i].queue);
+
+	rcu_read_lock();
+	for (i = 0; i < ARRAY_SIZE(sta->rx_tid); i++) {
+		struct r92su_rx_tid *rx_tid;
+		rx_tid = rcu_dereference(sta->rx_tid[i]);
+		rcu_assign_pointer(sta->rx_tid[i], NULL);
+		r92su_free_tid(rx_tid);
+	}
+	key = rcu_dereference(sta->sta_key);
+	rcu_assign_pointer(sta->sta_key, NULL);
+	r92su_key_free(key);
+
+	rcu_read_unlock();
+	kfree(sta);
+}
+
+static void r92su_free_sta(struct r92su_sta *sta)
+{
+	if (sta)
+		call_rcu(&sta->rcu_head, r92su_free_sta_rcu);
+}
+
+void r92su_sta_alloc_tid(struct r92su *r92su,
+			 struct r92su_sta *sta,
+			 const u8 tid, u16 ssn)
+{
+	struct r92su_rx_tid *new_tid;
+	struct r92su_rx_tid *old_tid;
+
+	new_tid = kzalloc(sizeof(*new_tid), GFP_ATOMIC);
+
+	rcu_read_lock();
+	old_tid = rcu_dereference(sta->rx_tid[tid]);
+	if (new_tid) {
+		spin_lock_init(&new_tid->lock);
+		new_tid->tid = tid;
+
+		setup_timer(&new_tid->reorder_timer,
+			    r92su_rx_tid_reorder_timer,
+		    (unsigned long) new_tid);
+		new_tid->r92su = r92su;
+		new_tid->sta = sta;
+		new_tid->last_rx = jiffies;
+		new_tid->head_seq = new_tid->ssn = ssn >> 4;
+		new_tid->size = 32;	 /* taken from a monitor */
+
+		rcu_assign_pointer(sta->rx_tid[tid], new_tid);
+	} else {
+		rcu_assign_pointer(sta->rx_tid[tid], NULL);
+	}
+	r92su_free_tid(old_tid);
+	rcu_read_unlock();
+}
+
+struct r92su_sta *r92su_sta_alloc(struct r92su *r92su, const u8 *mac_addr,
+				  const unsigned int mac_id,
+				  const gfp_t flag)
+{
+	struct r92su_sta *sta;
+
+	sta = kzalloc(sizeof(*sta), flag);
+	if (sta) {
+		int i;
+		for (i = 0; i < ARRAY_SIZE(sta->defrag); i++)
+			skb_queue_head_init(&sta->defrag[i].queue);
+
+		if (mac_addr)
+			memcpy(sta->mac_addr, mac_addr, ETH_ALEN);
+		sta->mac_id = mac_id;
+	}
+	return sta;
+}
+
+struct r92su_sta *r92su_sta_get(struct r92su *r92su, const u8 *mac_addr)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(r92su->sta_table); i++) {
+		struct r92su_sta *sta;
+
+		sta = rcu_dereference(r92su->sta_table[i]);
+		if (sta && !memcmp(sta->mac_addr, mac_addr, ETH_ALEN))
+			return sta;
+	}
+	return NULL;
+}
+
+static struct r92su_sta *r92su_sta_xchg(struct r92su *r92su,
+					struct r92su_sta *new_sta)
+{
+	struct r92su_sta *old_sta;
+	unsigned int mac_id = new_sta->mac_id % ARRAY_SIZE(r92su->sta_table);
+
+	old_sta = rcu_dereference(r92su->sta_table[mac_id]);
+	rcu_assign_pointer(r92su->sta_table[mac_id], new_sta);
+	return old_sta;
+}
+
+void r92su_sta_replace(struct r92su *r92su, struct r92su_sta *new_sta)
+{
+	rcu_read_lock();
+	r92su_free_sta(r92su_sta_xchg(r92su, new_sta));
+	rcu_read_unlock();
+}
+
+void r92su_sta_del(struct r92su *r92su, int mac_id)
+{
+	struct r92su_sta *old_sta;
+	BUG_ON(mac_id > ARRAY_SIZE(r92su->sta_table));
+
+	old_sta = rcu_dereference(r92su->sta_table[mac_id]);
+	rcu_assign_pointer(r92su->sta_table[mac_id], NULL);
+	r92su_free_sta(old_sta);
+}
+
+void r92su_sta_add(struct r92su *r92su, struct r92su_sta *new_sta)
+{
+	r92su_free_sta(r92su_sta_xchg(r92su, new_sta));
+}
+
+static u32 get_random_wep_seq(void)
+{
+	u32 buf;
+	get_random_bytes(&buf, sizeof(buf));
+	return buf;
+}
+
+struct r92su_key *r92su_key_alloc(const u32 cipher, const u8 idx,
+				  const u8 *mac_addr, const bool pairwise,
+				  const u8 *key)
+{
+	struct r92su_key *new_key;
+
+	new_key = kzalloc(sizeof(*new_key), GFP_KERNEL);
+	if (!new_key)
+		return ERR_PTR(-ENOMEM);
+
+	new_key->pairwise = pairwise;
+	new_key->index = idx;
+	if (mac_addr)
+		memcpy(new_key->mac_addr, mac_addr, ETH_ALEN);
+
+	switch (cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+		new_key->type = WEP40_ENCRYPTION;
+		new_key->key_len = WLAN_KEY_LEN_WEP40;
+		new_key->wep.seq = get_random_wep_seq();
+		memcpy(new_key->wep.wep40_key, key,
+		       sizeof(new_key->wep.wep40_key));
+		break;
+
+	case WLAN_CIPHER_SUITE_WEP104:
+		new_key->type = WEP104_ENCRYPTION;
+		new_key->key_len = WLAN_KEY_LEN_WEP104;
+		new_key->wep.seq = get_random_wep_seq();
+		memcpy(new_key->wep.wep104_key, key,
+		       sizeof(new_key->wep.wep104_key));
+		break;
+
+	case WLAN_CIPHER_SUITE_TKIP:
+		new_key->type = TKIP_ENCRYPTION;
+		new_key->key_len = WLAN_KEY_LEN_TKIP;
+		new_key->tkip.tx_seq = 1;
+		new_key->tkip.rx_seq = 1;
+		memcpy(new_key->tkip.key.key, key,
+		       sizeof(new_key->tkip.key.key));
+		break;
+
+	case WLAN_CIPHER_SUITE_CCMP:
+		new_key->type = AESCCMP_ENCRYPTION;
+		new_key->key_len = WLAN_KEY_LEN_CCMP;
+		new_key->ccmp.tx_seq = 0;
+		new_key->ccmp.rx_seq = 0;
+		memcpy(new_key->ccmp.key, key, sizeof(new_key->ccmp.key));
+		break;
+
+	default:
+		WARN(1, "invalid cipher suite 0x%x\n", cipher);
+		kfree(new_key);
+		return ERR_PTR(-EINVAL);
+	}
+	return new_key;
+}
+
+void r92su_key_free(struct r92su_key *key)
+{
+	if (key)
+		kfree_rcu(key, rcu_head);
+}
--- /dev/null
+++ b/drivers/net/wireless/r92su/sta.h
@@ -0,0 +1,154 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_STA_H__
+#define __R92SU_STA_H__
+
+#include <linux/kernel.h>
+#include <linux/rcupdate.h>
+#include <linux/skbuff.h>
+#include <linux/timer.h>
+
+#include "def.h"
+
+struct r92su;
+struct r92su_key;
+struct r92su_sta;
+
+struct r92su_rx_tid {
+	struct rcu_head rcu_head;
+	spinlock_t lock;
+
+	u16 dropped;
+
+	u16 tid;
+	u16 ssn;
+	u16 head_seq;
+	u16 len;
+	u16 size;
+	struct sk_buff *reorder_buf[64];
+	unsigned long reorder_time[64];
+
+	struct r92su *r92su;
+	struct r92su_sta *sta;
+	struct timer_list reorder_timer;
+
+	unsigned long last_rx;
+};
+
+struct r92su_key {
+	struct rcu_head rcu_head;
+
+	u8 mac_addr[ETH_ALEN];
+	enum r92su_enc_alg type;
+	unsigned int key_len;
+	unsigned int seq_len;
+	bool pairwise;
+	unsigned int index;
+	union {
+		struct {
+			u64 tx_seq:48;
+			u64 rx_seq:48;
+			u8 key[WLAN_KEY_LEN_CCMP];
+		} ccmp;
+
+		struct {
+			u64 tx_seq:48;
+			u64 rx_seq:48;
+			union {
+				struct {
+					u8 key[16];
+					u8 mic1[8];
+					u8 mic2[8];
+				} __packed _key;
+				u8 key[WLAN_KEY_LEN_TKIP];
+			} key;
+		} tkip;
+
+		struct {
+			u32 seq:24; /* only for tx */
+			union {
+				u8 wep104_key[WLAN_KEY_LEN_WEP104];
+				u8 wep40_key[WLAN_KEY_LEN_WEP40];
+			};
+		} wep;
+	};
+};
+
+struct r92su_defrag_entry {
+	struct sk_buff_head queue;
+	unsigned int size;
+};
+
+struct r92su_sta {
+	struct rcu_head rcu_head;
+
+	u8 mac_addr[ETH_ALEN];
+	unsigned int mac_id;
+	unsigned int tx_seq[16];
+	unsigned int aid;
+
+	bool qos_sta;
+	bool ht_sta;
+	bool enc_sta;
+
+	/* deduplication */
+	__le16 rx_seq;
+	__le16 rx_seq_tid[IEEE80211_NUM_TIDS];
+
+	struct r92su_rx_tid __rcu *rx_tid[IEEE80211_NUM_TIDS];
+
+	u64 drop_dup;
+
+	struct r92su_defrag_entry defrag[NUM_ACS];
+
+	struct r92su_key __rcu *sta_key;
+};
+
+struct r92su_sta *r92su_sta_alloc(struct r92su *r92su, const u8 *mac_addr,
+				  const unsigned int mac_id, const gfp_t flag);
+
+void r92su_sta_replace(struct r92su *r92su, struct r92su_sta *new_sta);
+
+void r92su_sta_alloc_tid(struct r92su *r92su, struct r92su_sta *sta,
+			 const u8 tid, u16 size);
+
+struct r92su_key *r92su_key_alloc(const u32 cipher, const u8 idx,
+				  const u8 *mac_addr, const bool pairwise,
+				  const u8 *key);
+
+void r92su_key_free(struct r92su_key *key);
+
+/* the following functions need rcu_read_lock! */
+struct r92su_sta *r92su_sta_get(struct r92su *r92su, const u8 *mac_addr);
+void r92su_sta_del(struct r92su *r92su, int mac_id);
+void r92su_sta_add(struct r92su *r92su, struct r92su_sta *new_sta);
+
+#endif /* __R92SU_STA_H__ */
--- /dev/null
+++ b/drivers/net/wireless/r92su/tx.c
@@ -0,0 +1,600 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+#include <net/cfg80211.h>
+#include <linux/etherdevice.h>
+#include <linux/ieee80211.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+
+#include "r92su.h"
+#include "tx.h"
+#include "def.h"
+#include "usb.h"
+#include "cmd.h"
+#include "michael.h"
+
+static const enum rtl8712_queues_t r92su_802_1d_to_ac[] = {
+	[IEEE80211_AC_BK] = RTL8712_BKQ,
+	[IEEE80211_AC_BE] = RTL8712_BEQ,
+	[IEEE80211_AC_VI] = RTL8712_VIQ,
+	[IEEE80211_AC_VO] = RTL8712_VOQ,
+};
+
+enum r92su_tx_control_t {
+	TX_CONTINUE,
+	TX_DROP,
+};
+
+struct r92su_tx_info {
+	struct r92su_sta *sta;
+	struct r92su_key *key;
+	u8 tid;
+	bool low_rate;
+	bool ampdu;
+	bool ht_possible;
+};
+
+static inline struct r92su_tx_info *r92su_get_tx_info(struct sk_buff *skb)
+{
+	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct r92su_tx_info));
+	return (struct r92su_tx_info *) skb->cb;
+}
+
+static enum r92su_tx_control_t
+r92su_tx_fill_desc(struct r92su *r92su, struct sk_buff *skb,
+		   struct r92su_bss_priv *bss_priv)
+{
+	struct r92su_tx_info *tx_info = r92su_get_tx_info(skb);
+	struct ieee80211_hdr *i3e = (struct ieee80211_hdr *) skb->data;
+	struct tx_hdr *hdr = NULL;
+	u8 prio = skb->priority % ARRAY_SIZE(ieee802_1d_to_ac);
+
+	hdr = (struct tx_hdr *) skb_push(skb, sizeof(*hdr));
+	memset(hdr, 0 , sizeof(*hdr));
+
+	hdr->pkt_len = cpu_to_le16(skb->len - sizeof(*hdr));
+	hdr->offset = sizeof(*hdr);
+	hdr->linip = 0;
+
+	if (ieee80211_is_data(i3e->frame_control))
+		hdr->mac_id = tx_info->sta->mac_id;
+	else if (ieee80211_is_mgmt(i3e->frame_control))
+		hdr->mac_id = 5;
+
+	hdr->queue_sel = r92su_802_1d_to_ac[ieee802_1d_to_ac[prio]];
+
+	/* firmware will increase the seqnum by itself, when
+	 * the driver passes the correct "priority" to it */
+	hdr->seq = prio;
+	hdr->more_frag = !!(i3e->frame_control &
+		cpu_to_le16(IEEE80211_FCTL_MOREFRAGS));
+	hdr->more_data = !!(i3e->frame_control &
+		cpu_to_le16(IEEE80211_FCTL_MOREDATA));
+	hdr->frag = le16_to_cpu(i3e->seq_ctrl & IEEE80211_SCTL_FRAG);
+
+	hdr->non_qos = !ieee80211_is_data_qos(i3e->frame_control);
+	hdr->bmc = is_multicast_ether_addr(ieee80211_get_DA(i3e));
+
+	if (tx_info->key) {
+		switch (tx_info->key->type) {
+		case WEP40_ENCRYPTION:
+		case WEP104_ENCRYPTION: {
+			hdr->sec_type = 1;
+			hdr->key_id = tx_info->key->index;
+			break;
+		}
+
+		case TKIP_ENCRYPTION:
+			hdr->sec_type = 2;
+			break;
+
+		case AESCCMP_ENCRYPTION:
+			hdr->sec_type = 3;
+			break;
+
+		default:
+			WARN(1, "invalid encryption type %d\n",
+			     tx_info->key->type);
+			return TX_DROP;
+		}
+	}
+
+	/* send EAPOL with failsafe rate */
+	if (tx_info->low_rate) {
+		hdr->user_rate = 1;
+		hdr->dis_fb = 1;
+		hdr->data_rate_fb_limit = 0x1f;
+		hdr->agg_break = 1;
+	} else if (tx_info->ampdu) {
+		/* The firmware will automatically enable aggregation
+		 * there's no need to set hdr->agg_en = 1 and hdr->tx_ht = 1;
+		 */
+	}
+
+	hdr->own = 1;
+	hdr->first_seg = 1;
+	hdr->last_seg = 1;
+	return TX_CONTINUE;
+}
+
+#define WEP_IV_LEN		4
+#define WEP_ICV_LEN		4
+#define CCMP_HDR_LEN		8
+#define CCMP_MIC_LEN		8
+#define CCMP_TK_LEN		16
+#define TKIP_IV_LEN		8
+#define TKIP_ICV_LEN		4
+
+static enum r92su_tx_control_t
+r92su_tx_add_iv(struct r92su *r92su, struct sk_buff *skb,
+		struct r92su_bss_priv *bss_priv)
+{
+	struct ieee80211_hdr *hdr = (void *) skb->data;
+	struct r92su_tx_info *tx_info = r92su_get_tx_info(skb);
+	struct r92su_key *key = tx_info->key;
+	unsigned int iv_len, hdr_len;
+	u8 *iv;
+
+	if (!key)
+		return TX_CONTINUE;
+
+	iv_len = r92su_get_iv_len(key);
+	hdr_len = ieee80211_hdrlen(hdr->frame_control);
+
+	/* make room for iv and move the ieee80211 header
+	 * to the new location */
+	hdr = (void *) skb_push(skb, iv_len);
+	memmove(hdr, (u8 *) hdr + iv_len, hdr_len);
+
+	/* the space for the IV is now right behind the
+	 * IEEE 802.11 MAC header (QoS + HTC are optional)
+	 */
+	iv = ((u8 *) hdr) + hdr_len;
+
+	switch (key->type) {
+	case WEP40_ENCRYPTION:
+	case WEP104_ENCRYPTION:
+		/* filter weak wep iv */
+		if ((key->wep.seq & 0xff00) == 0xff00) {
+			u8 B = (key->wep.seq >> 16) & 0xff;
+			if (B >= 3 && B < (3 + key->key_len))
+				key->wep.seq += 0x0100;
+		}
+
+		iv[0] = (key->wep.seq >> 16) & 0xff;
+		iv[1] = (key->wep.seq >> 8) & 0xff;
+		iv[2] = (key->wep.seq) & 0xff;
+		iv[3] = key->index;
+		key->wep.seq++;
+		break;
+
+	case TKIP_ENCRYPTION:
+		iv[0] = (key->tkip.tx_seq >> 8) & 0xff;
+		iv[1] = ((key->tkip.tx_seq >> 8) | 0x20) & 0x7f;
+		iv[2] = (key->tkip.tx_seq) & 0xff;
+		iv[3] = (key->index << 6) | BIT(5 /* Ext IV */);
+		iv[4] = (key->tkip.tx_seq >> 16) & 0xff;
+		iv[5] = (key->tkip.tx_seq >> 24) & 0xff;
+		iv[6] = (key->tkip.tx_seq >> 32) & 0xff;
+		iv[7] = (key->tkip.tx_seq >> 40) & 0xff;
+		key->tkip.tx_seq++;
+		break;
+
+	case AESCCMP_ENCRYPTION:
+		iv[0] = (key->ccmp.tx_seq) & 0xff;
+		iv[1] = (key->ccmp.tx_seq >> 8) & 0xff;
+		iv[2] = 0;
+		iv[3] = (key->index << 6) | BIT(5 /* Ext IV */);
+		iv[4] = (key->ccmp.tx_seq >> 16) & 0xff;
+		iv[5] = (key->ccmp.tx_seq >> 24) & 0xff;
+		iv[6] = (key->ccmp.tx_seq >> 32) & 0xff;
+		iv[7] = (key->ccmp.tx_seq >> 40) & 0xff;
+		key->ccmp.tx_seq++;
+		break;
+
+	default:
+		WARN(1, "invalid encryption type %d\n", key->type);
+		return TX_DROP;
+	}
+
+	return TX_CONTINUE;
+}
+
+static enum r92su_tx_control_t
+r92su_tx_add_icv_mic(struct r92su *r92su, struct sk_buff *skb,
+			struct r92su_bss_priv *bss_priv)
+{
+	struct ieee80211_hdr *hdr = (void *) skb->data;
+	struct r92su_tx_info *tx_info = r92su_get_tx_info(skb);
+	struct r92su_key *key = tx_info->key;
+	unsigned int data_len, hdr_len;
+	u8 *data;
+
+	if (!key)
+		return TX_CONTINUE;
+
+	hdr_len = ieee80211_hdrlen(hdr->frame_control);
+	data_len = skb->len - hdr_len;
+	data = ((u8 *) hdr) + hdr_len;
+
+	switch (key->type) {
+	case WEP40_ENCRYPTION:
+	case WEP104_ENCRYPTION:
+		/* done by the firmware/hardware, just alloc the space */
+		memset(skb_put(skb, WEP_ICV_LEN), 0, WEP_ICV_LEN);
+		tx_info->ht_possible = false;
+		return TX_CONTINUE;
+
+	case TKIP_ENCRYPTION:
+		michael_mic(&key->tkip.key.key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY],
+			    hdr, data, data_len, skb_put(skb, MICHAEL_MIC_LEN));
+		tx_info->ht_possible = false;
+		return TX_CONTINUE;
+
+	case AESCCMP_ENCRYPTION:
+		/* done by the firmware/hardware, just alloc the space */
+		memset(skb_put(skb, CCMP_MIC_LEN), 0, CCMP_MIC_LEN);
+		return TX_CONTINUE;
+
+	default:
+		WARN(1, "invalid encryption type %d\n", key->type);
+		return TX_DROP;
+	}
+}
+
+static enum r92su_tx_control_t
+r92su_tx_prepare_tx_info_and_find_sta(struct r92su *r92su, struct sk_buff *skb,
+				      struct r92su_bss_priv *bss_priv)
+{
+	struct r92su_tx_info *tx_info = r92su_get_tx_info(skb);
+	struct r92su_sta *sta;
+	struct ethhdr *hdr = (void *) skb->data;
+
+	/* clean up tx info */
+	memset(tx_info, 0, sizeof(tx_info));
+
+	sta = r92su_sta_get(r92su, hdr->h_dest);
+	if (!sta) {
+		sta = bss_priv->sta;
+		if (!sta)
+			return TX_DROP;
+
+		/* We only support aggregation when we are talking to the AP */
+		tx_info->ht_possible = sta->ht_sta;
+	}
+
+	tx_info->sta = sta;
+	return TX_CONTINUE;
+}
+
+static enum r92su_tx_control_t
+r92su_tx_rate_control_hint(struct r92su *r92su, struct sk_buff *skb,
+			   struct r92su_bss_priv *bss_priv)
+{
+	/* The rate control starts out with the faster rates
+	 * and if it doesn't work, it will move down.
+	 * This means that the few, but very important PAE,
+	 * ARP, DHCP frames which are in serious danger of
+	 * being "dropped" on a weak link... And the
+	 * connection could never be established... unless
+	 * we force the firmware/hardware to use lower and
+	 * more robust rates.
+	 */
+	bool low_rate = false;
+
+	struct r92su_tx_info *tx_info = r92su_get_tx_info(skb);
+	switch (skb->protocol) {
+	case cpu_to_be16(ETH_P_PAE):
+	case cpu_to_be16(ETH_P_ARP):
+		low_rate = true;
+		break;
+
+	/* detect DHCP */
+	case cpu_to_be16(ETH_P_IP): {
+		struct iphdr *ip;
+
+		ip = ((void *) skb->data) + ETH_HLEN;
+		if (ip->protocol == IPPROTO_UDP) {
+			struct udphdr *udp = (struct udphdr *)((u8 *) ip +
+							       (ip->ihl << 2));
+			if ((udp->source == cpu_to_be16(68) &&
+			     udp->dest == cpu_to_be16(67)) ||
+			    (udp->source == cpu_to_be16(67) &&
+			     udp->dest == cpu_to_be16(68))) {
+				/* 68 : UDP BOOTP client
+				 * 67 : UDP BOOTP server
+				 */
+				low_rate = true;
+			}
+		}
+		break;
+	}
+	}
+
+	if (low_rate) {
+		tx_info->ht_possible = false;
+		tx_info->low_rate = true;
+	}
+
+	return TX_CONTINUE;
+}
+
+static enum r92su_tx_control_t
+r92su_tx_add_80211(struct r92su *r92su, struct sk_buff *skb,
+		   struct r92su_bss_priv *bss_priv)
+{
+	struct r92su_tx_info *tx_info = r92su_get_tx_info(skb);
+	struct wireless_dev *wdev = &r92su->wdev;
+	int err, tid;
+	bool qos;
+
+	qos = tx_info->sta->qos_sta;
+	if (bss_priv->control_port_ethertype == skb->protocol)
+		qos = false;
+
+	err = ieee80211_data_from_8023(skb, wdev_address(wdev), wdev->iftype,
+				       bss_priv->fw_bss.bssid, qos);
+	if (err)
+		return TX_DROP;
+
+	if (qos) {
+		struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+		u8 *qos_ctl = ieee80211_get_qos_ctl(hdr);
+		memset(qos_ctl, 0, 2);
+
+		tid = skb->priority % ARRAY_SIZE(ieee802_1d_to_ac);
+		qos_ctl[0] = tid;
+
+		if (tx_info->ht_possible &&
+		    skb_get_queue_mapping(skb) != IEEE80211_AC_VO) {
+			if (!bss_priv->tx_tid[tid].addba_issued) {
+				r92su_h2c_start_ba(r92su, tid);
+				bss_priv->tx_tid[tid].addba_issued = true;
+			} else {
+				tx_info->ampdu = true;
+				tx_info->tid = tid;
+			}
+		}
+	}
+
+	return TX_CONTINUE;
+}
+
+static enum r92su_tx_control_t
+r92su_tx_fragment(struct r92su *r92su, struct sk_buff *skb,
+		  struct r92su_bss_priv *bss_priv, struct sk_buff_head *queue)
+{
+	struct ieee80211_hdr *hdr;
+	unsigned int limit = r92su->wdev.wiphy->frag_threshold;
+	unsigned int hdr_len;
+	unsigned int frag_num = 0;
+	unsigned int per_frag;
+	unsigned int pos;
+	int rem;
+
+	if ((skb->len + FCS_LEN) < limit) {
+		__skb_queue_tail(queue, skb);
+		return TX_CONTINUE;
+	}
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+	hdr_len = ieee80211_hdrlen(hdr->frame_control);
+	per_frag = limit - hdr_len - FCS_LEN;
+	pos = hdr_len;
+	rem = skb->len - hdr_len - per_frag;
+
+	if (WARN(rem <= 0, "can't make zero length fragment."))
+		return TX_DROP;
+
+	while (rem) {
+		struct sk_buff *tmp;
+		int frag_len = per_frag;
+
+		if (frag_len > rem)
+			frag_len = rem;
+
+		rem -= frag_len;
+		tmp = dev_alloc_skb(R92SU_TX_HEAD_ROOM +
+				    limit +
+				    R92SU_TX_TAIL_ROOM);
+		if (!tmp)
+			return TX_DROP;
+
+		skb_reserve(tmp, TX_DESC_SIZE + 4 + 8); /* + align + iv */
+		memcpy(tmp->cb, skb->cb, sizeof(tmp->cb));
+
+		skb_copy_queue_mapping(tmp, skb);
+		tmp->protocol = skb->protocol;
+		tmp->priority = skb->priority;
+		tmp->dev = skb->dev;
+
+		memcpy(skb_put(tmp, hdr_len), skb->data, hdr_len);
+		memcpy(skb_put(tmp, frag_len), skb->data + pos, frag_len);
+
+		hdr = (struct ieee80211_hdr *) tmp->data;
+
+		if (rem) {
+			hdr->frame_control |=
+				cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);
+		}
+
+		hdr->seq_ctrl |= cpu_to_le16(frag_num++ & IEEE80211_SCTL_FRAG);
+
+		pos += frag_len;
+
+		__skb_queue_tail(queue, tmp);
+	}
+
+	/* no longer needed */
+	dev_kfree_skb_any(skb);
+	return TX_CONTINUE;
+}
+
+static enum r92su_tx_control_t
+r92su_tx_select_key(struct r92su *r92su, struct sk_buff *skb,
+		    struct r92su_bss_priv *bss_priv)
+{
+	struct r92su_tx_info *tx_info = r92su_get_tx_info(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct r92su_sta *sta = tx_info->sta;
+	struct r92su_key *key = NULL;
+
+	if (!bss_priv->sta->enc_sta)
+		return TX_CONTINUE;
+
+	if (is_multicast_ether_addr(ieee80211_get_DA(hdr))) {
+		key = rcu_dereference(bss_priv->
+			group_key[bss_priv->def_multi_key_idx]);
+	} else {
+		sta = r92su_sta_get(r92su, ieee80211_get_DA(hdr));
+		if (sta)
+			key = rcu_dereference(sta->sta_key);
+	}
+
+	if (!key)
+		key = rcu_dereference(bss_priv->sta->sta_key);
+
+	if (!key) {
+		key = rcu_dereference(bss_priv->group_key
+				[bss_priv->def_uni_key_idx]);
+	}
+
+	if (!key) {
+		/* check control_port and control_port_no_encrypt ? */
+		if (bss_priv->control_port_ethertype != skb->protocol)
+			return TX_DROP;
+		else
+			return TX_CONTINUE;
+	}
+
+	hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+	tx_info->key = key;
+	return TX_CONTINUE;
+}
+
+static enum r92su_tx_control_t
+r92su_tx_invalidate_rcu_data(struct r92su *r92su, struct sk_buff *skb,
+			     struct r92su_bss_priv *bss_priv)
+{
+	struct r92su_tx_info *tx_info = r92su_get_tx_info(skb);
+	tx_info->sta = NULL;
+	tx_info->key = NULL;
+	return TX_CONTINUE;
+}
+
+void r92su_tx(struct r92su *r92su, struct sk_buff *skb)
+{
+	struct cfg80211_bss *bss;
+	struct r92su_bss_priv *bss_priv;
+
+	struct sk_buff_head in_queue;
+	struct sk_buff_head out_queue;
+
+#define __TX_HANDLER(func, drop_goto, args...) do {	\
+	enum r92su_tx_control_t __ret;			\
+							\
+	__ret = func(r92su, skb, bss_priv, ## args);	\
+	switch (__ret) {				\
+	case TX_CONTINUE:				\
+		break;					\
+	case TX_DROP:					\
+		goto drop_goto;				\
+	}						\
+} while (0)
+
+#define TX_HANDLER_PREP(func, args...)			\
+	__TX_HANDLER(func, err_unlock, ## args)
+
+#define TX_HANDLER(func, args...)			\
+	__TX_HANDLER(func, tx_drop, ## args)
+
+	__skb_queue_head_init(&in_queue);
+	__skb_queue_head_init(&out_queue);
+
+	/* isn't this check sort of done by the caller already?! */
+	if (skb->len < ETH_ALEN + ETH_ALEN + 2)
+		goto err_out;
+
+	if (!r92su_is_connected(r92su))
+		goto err_out;
+
+	rcu_read_lock();
+	bss = rcu_dereference(r92su->connect_bss);
+	if (!bss)
+		goto err_unlock;
+
+	bss_priv = r92su_get_bss_priv(bss);
+
+	TX_HANDLER_PREP(r92su_tx_prepare_tx_info_and_find_sta);
+	TX_HANDLER_PREP(r92su_tx_rate_control_hint);
+	TX_HANDLER_PREP(r92su_tx_add_80211);
+	TX_HANDLER_PREP(r92su_tx_select_key);
+	TX_HANDLER_PREP(r92su_tx_fragment, &in_queue);
+
+	while ((skb = __skb_dequeue(&in_queue))) {
+		TX_HANDLER(r92su_tx_add_icv_mic);
+		TX_HANDLER(r92su_tx_add_iv);
+		TX_HANDLER(r92su_tx_fill_desc);
+		TX_HANDLER(r92su_tx_invalidate_rcu_data);
+		__skb_queue_tail(&out_queue, skb);
+		continue;
+tx_drop:
+		r92su->wdev.netdev->stats.tx_dropped++;
+		dev_kfree_skb_any(skb);
+	}
+
+	while ((skb = __skb_dequeue(&out_queue))) {
+		struct tx_hdr *tx_hdr = (struct tx_hdr *)skb->data;
+
+		r92su->wdev.netdev->stats.tx_packets++;
+		r92su->wdev.netdev->stats.tx_bytes += skb->len;
+
+		r92su_usb_tx(r92su, skb, tx_hdr->queue_sel);
+	}
+	rcu_read_unlock();
+	return;
+
+err_unlock:
+	rcu_read_unlock();
+
+err_out:
+	__skb_queue_purge(&in_queue);
+	__skb_queue_purge(&out_queue);
+	r92su->wdev.netdev->stats.tx_dropped++;
+	dev_kfree_skb_any(skb);
+
+#undef TX_HANDLER
+}
+
+void r92su_tx_cb(struct r92su *r92su, struct sk_buff *skb)
+{
+}
--- /dev/null
+++ b/drivers/net/wireless/r92su/tx.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_TX_H__
+#define __R92SU_TX_H__
+struct r92su;
+struct sk_buff;
+
+void r92su_tx(struct r92su *r92su, struct sk_buff *skb);
+void r92su_tx_cb(struct r92su *r92su, struct sk_buff *skb);
+#endif /* __R92SU_TX_H__ */
--- /dev/null
+++ b/drivers/net/wireless/r92su/usb.c
@@ -0,0 +1,581 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/usb.h>
+#include <linux/export.h>
+
+#include "r92su.h"
+#include "usb.h"
+#include "rx.h"
+#include "tx.h"
+
+static int r92su_sync_write(struct r92su *r92su, __le16 address,
+			    const void *data, u16 size)
+{
+	struct usb_device *udev = r92su->udev;
+	void *dma_data;
+	u16 *_address = (void *) &address;
+	int ret;
+
+	if (!r92su_is_probing(r92su))
+		return -EINVAL;
+
+	dma_data = kmemdup(data, size, GFP_ATOMIC);
+	if (!dma_data)
+		return -ENOMEM;
+
+	ret = usb_control_msg(udev, usb_sndctrlpipe(udev, RTL8712_EP_CTRL),
+		REALTEK_USB_VENQT_CMD_REQ, REALTEK_USB_VENQT_WRITE, *_address,
+		REALTEK_USB_VENQT_CMD_IDX, dma_data, size,
+		USB_CTRL_SET_TIMEOUT);
+
+	kfree(dma_data);
+	return (ret < 0) ? ret : ((ret == size) ? 0 : -EMSGSIZE);
+}
+
+static int r92su_sync_read(struct r92su *r92su, __le16 address,
+			   void *data, u16 size)
+{
+	struct usb_device *udev = r92su->udev;
+	u16 *_address = (void *) &address;
+	void *dma_data;
+	int ret;
+
+	if (!r92su_is_probing(r92su))
+		return -EINVAL;
+
+	dma_data = kmalloc(size, GFP_ATOMIC);
+	if (!dma_data)
+		return -ENOMEM;
+
+	ret = usb_control_msg(udev, usb_rcvctrlpipe(udev, RTL8712_EP_CTRL),
+		REALTEK_USB_VENQT_CMD_REQ, REALTEK_USB_VENQT_READ, *_address,
+		REALTEK_USB_VENQT_CMD_IDX, dma_data, size,
+		USB_CTRL_GET_TIMEOUT);
+	if (ret > 0)
+		memcpy(data, dma_data, ret);
+
+	kfree(dma_data);
+	return (ret < 0) ? ret : ((ret == size) ? 0 : -EMSGSIZE);
+}
+
+static void r92su_read_helper(struct r92su *r92su, const u16 address,
+			      void *data, const u16 size)
+{
+	int ret;
+	ret = r92su_sync_read(r92su, cpu_to_le16(address), data, size);
+	WARN_ONCE(ret, "unable to read %d bytes from address:0x%x (%d).",
+		      size, address, ret);
+
+	if (ret)
+		r92su_mark_dead(r92su);
+}
+
+u8 r92su_read8(struct r92su *r92su, const u32 address)
+{
+	u8 data;
+	r92su_read_helper(r92su, address, &data, sizeof(data));
+	return data;
+}
+
+u16 r92su_read16(struct r92su *r92su, const u32 address)
+{
+	__le16 data;
+	r92su_read_helper(r92su, address, &data, sizeof(data));
+	return le16_to_cpu(data);
+}
+
+u32 r92su_read32(struct r92su *r92su, const u32 address)
+{
+	__le32 data;
+	r92su_read_helper(r92su, address, &data, sizeof(data));
+	return le32_to_cpu(data);
+}
+
+static void r92su_write_helper(struct r92su *r92su, const u16 address,
+			       const void *data, const u16 size)
+{
+	int ret;
+	ret = r92su_sync_write(r92su, cpu_to_le16(address), data, size);
+	WARN_ONCE(ret, "unable to write %d bytes to address:0x%x (%d).",
+		size, address, ret);
+
+	if (ret)
+		r92su_mark_dead(r92su);
+}
+
+void r92su_write8(struct r92su *r92su, const u32 address, const u8 data)
+{
+	u8 tmp = data;
+	r92su_write_helper(r92su, address, &tmp, sizeof(tmp));
+}
+
+void r92su_write16(struct r92su *r92su, const u32 address, const u16 data)
+{
+	__le16 tmp = cpu_to_le16(data);
+	r92su_write_helper(r92su, address, &tmp, sizeof(tmp));
+}
+
+void r92su_write32(struct r92su *r92su, const u32 address, const u32 data)
+{
+	__le32 tmp = cpu_to_le32(data);
+	r92su_write_helper(r92su, address, &tmp, sizeof(tmp));
+}
+
+static void r92su_tx_schedule(struct r92su *r92su)
+{
+	struct urb *urb;
+	int err;
+
+	if (atomic_inc_return(&r92su->tx_pending_urbs) >
+	    RTL_USB_MAX_TX_URBS_NUM)
+		goto err_acc;
+
+	urb = usb_get_from_anchor(&r92su->tx_wait);
+	if (!urb)
+		goto err_acc;
+
+	usb_anchor_urb(urb, &r92su->tx_submitted);
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err) {
+		WARN_ONCE(err, "can't handle urb submit error %d", err);
+
+		usb_unanchor_urb(urb);
+		r92su_mark_dead(r92su);
+
+		dev_kfree_skb_any(urb->context);
+	}
+
+	usb_free_urb(urb);
+	if (likely(err == 0))
+		return;
+
+err_acc:
+	atomic_dec(&r92su->tx_pending_urbs);
+}
+
+static void r92su_tx_usb_cb(struct urb *urb)
+{
+	struct r92su *r92su = usb_get_intfdata(usb_ifnum_to_if(urb->dev, 0));
+	struct sk_buff *skb = urb->context;
+
+	atomic_dec(&r92su->tx_pending_urbs);
+
+	r92su_tx_cb(r92su, skb);
+
+	dev_kfree_skb_any(skb);
+
+	switch (urb->status) {
+	case 0:
+		break;
+
+	case -ENOENT:
+	case -ECONNRESET:
+	case -ENODEV:
+	case -ESHUTDOWN:
+		break;
+
+	default:
+		WARN_ONCE(urb->status, "unhandled urb status %d", urb->status);
+		r92su_mark_dead(r92su);
+		break;
+	}
+
+	r92su_tx_schedule(r92su);
+}
+
+static void r92su_rx_usb_cb(struct urb *urb)
+{
+	struct r92su *r92su = usb_get_intfdata(usb_ifnum_to_if(urb->dev, 0));
+	void *buf = urb->context;
+	int err;
+
+	switch (urb->status) {
+	case 0:
+		break;
+
+	case -ENOENT:
+	case -ECONNRESET:
+	case -ENODEV:
+	case -ESHUTDOWN:
+		goto err_out;
+
+	default:
+		WARN_ONCE(urb->status, "unhandled urb status %d", urb->status);
+		r92su_mark_dead(r92su);
+		goto err_dead;
+	}
+
+	if (!r92su_is_probing(r92su))
+		goto err_dead;
+
+	r92su_rx(r92su, buf, urb->actual_length);
+	usb_anchor_urb(urb, &r92su->rx_submitted);
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err) {
+		WARN_ONCE(err, "can't handle urb submit error %d", err);
+		usb_unanchor_urb(urb);
+		goto err_dead;
+	}
+	return;
+
+err_dead:
+	r92su_mark_dead(r92su);
+err_out:
+	kfree(buf);
+	return;
+}
+
+static struct urb *r92su_get_rx_urb(struct r92su *r92su, gfp_t flag)
+{
+	struct urb *urb = NULL;
+	void *buf;
+
+	buf = kmalloc(RTL92SU_SIZE_MAX_RX_BUFFER, flag);
+	if (!buf)
+		goto err_nomem;
+
+	urb = usb_alloc_urb(0, flag);
+	if (!urb)
+		goto err_nomem;
+
+	usb_fill_bulk_urb(urb, r92su->udev,
+			  usb_rcvbulkpipe(r92su->udev, RTL8712_EP_RX),
+			  buf, RTL92SU_SIZE_MAX_RX_BUFFER,
+			  r92su_rx_usb_cb, buf);
+	return urb;
+
+err_nomem:
+	kfree(buf);
+	usb_free_urb(urb);
+	return ERR_PTR(-ENOMEM);
+}
+
+static const unsigned int ep4_map[__RTL8712_LAST] = {
+	[RTL8712_BKQ] = RTL8712_EP_TX6,
+	[RTL8712_BEQ] = RTL8712_EP_TX6,
+	[RTL8712_VIQ] = RTL8712_EP_TX4,
+	[RTL8712_VOQ] = RTL8712_EP_TX4,
+	[RTL8712_H2CCMD] = RTL8712_EP_TX13,
+	[RTL8712_BCNQ] = RTL8712_EP_TX13,
+	[RTL8712_BMCQ] = RTL8712_EP_TX13,
+	[RTL8712_MGTQ] = RTL8712_EP_TX13,
+	[RTL8712_RX0FF] = RTL8712_EP_RX,
+	[RTL8712_C2HCMD] = RTL8712_EP_RX,
+};
+
+static unsigned int r92su_usb_get_pipe(struct r92su *r92su,
+				       enum rtl8712_queues_t queue)
+{
+	BUILD_BUG_ON(ARRAY_SIZE(ep4_map) != __RTL8712_LAST);
+
+	return ep4_map[queue];
+}
+
+int r92su_usb_tx(struct r92su *r92su, struct sk_buff *skb,
+		 const enum rtl8712_queues_t queue)
+{
+	struct urb *urb;
+	int err = -EINVAL;
+	unsigned int pipe;
+
+	if (!r92su_is_probing(r92su))
+		goto err_out;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	pipe = r92su_usb_get_pipe(r92su, queue);
+	usb_fill_bulk_urb(urb, r92su->udev, usb_sndbulkpipe(r92su->udev, pipe),
+			  skb->data, skb->len, r92su_tx_usb_cb, skb);
+
+	urb->transfer_flags |= URB_ZERO_PACKET;
+
+	usb_anchor_urb(urb, &r92su->tx_wait);
+	usb_free_urb(urb);
+	r92su_tx_schedule(r92su);
+	return 0;
+
+err_out:
+	dev_kfree_skb_any(skb);
+	return err;
+}
+
+static int r92su_usb_init(struct r92su *r92su)
+{
+	struct urb *urb;
+	int i, err = -EINVAL;
+
+	for (i = 0; i < RTL_USB_MAX_RX_URBS_NUM; i++) {
+		urb = r92su_get_rx_urb(r92su, GFP_KERNEL);
+		if (IS_ERR(urb)) {
+			err = PTR_ERR(urb);
+			break;
+		}
+
+		usb_anchor_urb(urb, &r92su->rx_submitted);
+		err = usb_submit_urb(urb, GFP_KERNEL);
+		if (err) {
+			WARN_ONCE(err, "can't handle urb submit error %d",
+				  err);
+
+			usb_unanchor_urb(urb);
+			dev_kfree_skb_any(urb->context);
+			r92su_mark_dead(r92su);
+			break;
+		}
+
+		usb_free_urb(urb);
+	}
+	return err;
+}
+
+#define USB_VENDER_ID_REALTEK		0x0bda
+static struct usb_device_id r92su_usb_product_ids[] = {
+	/* RTL8188SU */
+	/* Realtek */
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8171)},
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8173)},
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8712)},
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8713)},
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0xC512)},
+	/* Abocom */
+	{USB_DEVICE(0x07B8, 0x8188)},
+	/* ASUS */
+	{USB_DEVICE(0x0B05, 0x1786)},
+	{USB_DEVICE(0x0B05, 0x1791)}, /* 11n mode disable */
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x945A)},
+	/* Corega */
+	{USB_DEVICE(0x07AA, 0x0047)},
+	/* D-Link */
+	{USB_DEVICE(0x2001, 0x3306)},
+	{USB_DEVICE(0x07D1, 0x3306)}, /* 11n mode disable */
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7611)},
+	/* EnGenius */
+	{USB_DEVICE(0x1740, 0x9603)},
+	/* Hawking */
+	{USB_DEVICE(0x0E66, 0x0016)},
+	/* Hercules */
+	{USB_DEVICE(0x06F8, 0xE034)},
+	{USB_DEVICE(0x06F8, 0xE032)},
+	/* Logitec */
+	{USB_DEVICE(0x0789, 0x0167)},
+	/* PCI */
+	{USB_DEVICE(0x2019, 0xAB28)},
+	{USB_DEVICE(0x2019, 0xED16)},
+	/* Sitecom */
+	{USB_DEVICE(0x0DF6, 0x0057)},
+	{USB_DEVICE(0x0DF6, 0x0045)},
+	{USB_DEVICE(0x0DF6, 0x0059)}, /* 11n mode disable */
+	{USB_DEVICE(0x0DF6, 0x004B)},
+	{USB_DEVICE(0x0DF6, 0x005B)},
+	{USB_DEVICE(0x0DF6, 0x005D)},
+	{USB_DEVICE(0x0DF6, 0x0063)},
+	/* Sweex */
+	{USB_DEVICE(0x177F, 0x0154)},
+	/* Thinkware */
+	{USB_DEVICE(0x0BDA, 0x5077)},
+	/* Toshiba */
+	{USB_DEVICE(0x1690, 0x0752)},
+	/* - */
+	{USB_DEVICE(0x20F4, 0x646B)},
+	{USB_DEVICE(0x083A, 0xC512)},
+
+/* RTL8191SU */
+	/* Realtek */
+	{USB_DEVICE(0x0BDA, 0x8172)},
+	{USB_DEVICE(0x0BDA, 0x8192)},
+	/* Amigo */
+	{USB_DEVICE(0x0EB0, 0x9061)},
+	/* ASUS/EKB */
+	{USB_DEVICE(0x13D3, 0x3323)},
+	{USB_DEVICE(0x13D3, 0x3311)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3342)},
+	/* ASUS/EKBLenovo */
+	{USB_DEVICE(0x13D3, 0x3333)},
+	{USB_DEVICE(0x13D3, 0x3334)},
+	{USB_DEVICE(0x13D3, 0x3335)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3336)}, /* 11n mode disable */
+	/* ASUS/Media BOX */
+	{USB_DEVICE(0x13D3, 0x3309)},
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x815F)},
+	/* D-Link */
+	{USB_DEVICE(0x07D1, 0x3302)},
+	{USB_DEVICE(0x07D1, 0x3300)},
+	{USB_DEVICE(0x07D1, 0x3303)},
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7612)},
+	/* EnGenius */
+	{USB_DEVICE(0x1740, 0x9605)},
+	/* Guillemot */
+	{USB_DEVICE(0x06F8, 0xE031)},
+	/* Hawking */
+	{USB_DEVICE(0x0E66, 0x0015)},
+	/* Mediao */
+	{USB_DEVICE(0x13D3, 0x3306)},
+	/* PCI */
+	{USB_DEVICE(0x2019, 0xED18)},
+	{USB_DEVICE(0x2019, 0x4901)},
+	/* Sitecom */
+	{USB_DEVICE(0x0DF6, 0x0058)},
+	{USB_DEVICE(0x0DF6, 0x0049)},
+	{USB_DEVICE(0x0DF6, 0x004C)},
+	{USB_DEVICE(0x0DF6, 0x0064)},
+	/* Skyworth */
+	{USB_DEVICE(0x14b2, 0x3300)},
+	{USB_DEVICE(0x14b2, 0x3301)},
+	{USB_DEVICE(0x14B2, 0x3302)},
+	/* - */
+	{USB_DEVICE(0x04F2, 0xAFF2)},
+	{USB_DEVICE(0x04F2, 0xAFF5)},
+	{USB_DEVICE(0x04F2, 0xAFF6)},
+	{USB_DEVICE(0x13D3, 0x3339)},
+	{USB_DEVICE(0x13D3, 0x3340)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3341)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3310)},
+	{USB_DEVICE(0x13D3, 0x3325)},
+
+/* RTL8192SU */
+	/* Realtek */
+	{USB_DEVICE(0x0BDA, 0x8174)},
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x845A)},
+	/* Corega */
+	{USB_DEVICE(0x07AA, 0x0051)},
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7622)},
+	/* NEC */
+	{USB_DEVICE(0x0409, 0x02B6)},
+
+	{ },
+};
+
+static int r92su_usb_probe(struct usb_interface *intf,
+			   const struct usb_device_id *id)
+{
+	struct r92su *r92su;
+	int err;
+
+	r92su = r92su_alloc(&intf->dev);
+	if (IS_ERR(r92su))
+		return PTR_ERR(r92su);
+
+	r92su_set_state(r92su, R92SU_PROBE);
+
+	r92su->udev = interface_to_usbdev(intf);
+
+	usb_set_intfdata(intf, r92su);
+
+	init_usb_anchor(&r92su->rx_submitted);
+	init_usb_anchor(&r92su->tx_submitted);
+	init_usb_anchor(&r92su->tx_wait);
+
+	err = r92su_usb_init(r92su);
+	if (err)
+		goto err_out;
+
+	err = r92su_setup(r92su);
+	if (err)
+		goto err_out;
+
+	err = r92su_register(r92su);
+	if (err)
+		goto err_out;
+
+	return 0;
+
+err_out:
+	r92su_unalloc(r92su);
+	return err;
+}
+
+static void r92su_usb_disconnect(struct usb_interface *intf)
+{
+	struct r92su *r92su = usb_get_intfdata(intf);
+	struct urb *urb;
+
+	r92su_mark_dead(r92su);
+
+	usb_poison_anchored_urbs(&r92su->tx_submitted);
+	usb_poison_anchored_urbs(&r92su->rx_submitted);
+	while ((urb = usb_get_from_anchor(&r92su->tx_wait))) {
+		kfree_skb(urb->context);
+		usb_free_urb(urb);
+	}
+
+	r92su_unalloc(r92su);
+}
+
+static int r92su_usb_suspend(struct usb_interface *pusb_intf,
+			     pm_message_t message)
+{
+	return 0;
+}
+
+void r92su_usb_prepare_firmware(struct r92su *r92su)
+{
+	struct fw_priv *dmem = &r92su->fw_dmem;
+
+	dmem->hci_sel = RTL8712_HCI_TYPE_72USB;
+	dmem->usb_ep_num = 4;
+}
+
+static int r92su_usb_resume(struct usb_interface *pusb_intf)
+{
+	return 0;
+}
+
+static struct usb_driver r92su_driver = {
+	.name		= R92SU_DRVNAME,
+	.id_table	= r92su_usb_product_ids,
+	.probe		= r92su_usb_probe,
+	.disconnect	= r92su_usb_disconnect,
+	.suspend	= r92su_usb_suspend,
+	.resume		= r92su_usb_resume,
+
+	.soft_unbind = 1,
+	.disable_hub_initiated_lpm = 1,
+};
+
+module_usb_driver(r92su_driver);
+
+MODULE_DEVICE_TABLE(usb, r92su_usb_product_ids);
+MODULE_FIRMWARE(RTL8192SU_FIRMWARE);
+MODULE_AUTHOR("Christian Lamparter <chunkeey@googlemail.com>");
+MODULE_LICENSE("GPL");
+
--- /dev/null
+++ b/drivers/net/wireless/r92su/usb.h
@@ -0,0 +1,64 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2013  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Christian Lamparter <chunkeey@googlemail.com>
+ * Joshua Roys <Joshua.Roys@gtri.gatech.edu>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __R92SU_USB_H__
+#define __R92SU_USB_H__
+
+#define RTL_RX_DESC_SIZE		24
+
+#define RTL_USB_MAX_TXQ_NUM		4		/* max tx queue */
+#define RTL_USB_MAX_EP_NUM		6		/* max ep number */
+#define RTL_USB_MAX_TX_URBS_NUM		8
+#define RTL_USB_MAX_RX_URBS_NUM		8
+
+#define	REALTEK_USB_VENQT_READ			0xC0
+#define	REALTEK_USB_VENQT_WRITE			0x40
+#define REALTEK_USB_VENQT_CMD_REQ		0x05
+#define	REALTEK_USB_VENQT_CMD_IDX		0x00
+
+#define RTL92SU_SIZE_MAX_RX_BUFFER		32768
+
+#define RTL8712_EP_RX				3
+#define RTL8712_EP_TX4				4
+#define RTL8712_EP_TX6				6
+#define RTL8712_EP_TX13				13
+#define RTL8712_EP_CTRL				0
+
+u8 r92su_read8(struct r92su *r92su, const u32 address);
+u16 r92su_read16(struct r92su *r92su, const u32 address);
+u32 r92su_read32(struct r92su *r92su, const u32 address);
+void r92su_write8(struct r92su *r92su, const u32 address, const u8 data);
+void r92su_write16(struct r92su *r92su, const u32 address, const u16 data);
+void r92su_write32(struct r92su *r92su, const u32 address, const u32 data);
+void r92su_usb_prepare_firmware(struct r92su *r92su);
+int r92su_usb_tx(struct r92su *r92su, struct sk_buff *skb,
+		 const enum rtl8712_queues_t queue);
+
+#endif /* __R92SU_USB_H__ */
